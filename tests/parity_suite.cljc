;; ============================================================
;; PARITY TEST SUITE
;; Auto-generated by script/gen_parity.clj
;; ============================================================
;;
;; Run on JVM to establish reference results, then compare on PHP/JS.
;;
;; Usage:
;;   JVM: clj -M tests/parity_suite.cljc
;;   PHP: bin/cljpc tests/parity_suite.cljc && php tests/parity_suite.php
;;

(ns tests.parity-suite
  (:require [clojure.test :refer [deftest testing is run-tests]]
            [clojure.parity :as parity]))

(deftest collections-tests
    (testing "vector-literal"
      (is (= [1 2 3] [1 2 3])))

    (testing "vector-fn"
      (is (= [1 2 3] (vector 1 2 3))))

    (testing "vector-empty"
      (is (= [] (vector))))

    (testing "vec-from-list"
      (is (= [1 2 3] (vec (quote (1 2 3))))))

    (testing "vec-from-nil"
      (is (= [] (vec nil))))

    (testing "vector-conj"
      (is (= [1 2 3] (conj [1 2] 3))))

    (testing "vector-get"
      (is (= 2 (get [1 2 3] 1))))

    (testing "vector-nth"
      (is (= 1 (nth [1 2 3] 0))))

    (testing "vector-peek"
      (is (= 3 (peek [1 2 3]))))

    (testing "vector-pop"
      (is (= [1 2] (pop [1 2 3]))))

    (testing "vector-assoc"
      (is (= [1 :x 3] (assoc [1 2 3] 1 :x))))

    (testing "vector-subvec"
      (is (= [2 3 4] (subvec [1 2 3 4 5] 1 4))))

    (testing "vector-count"
      (is (= 3 (count [1 2 3]))))

    (testing "map-literal"
      (is (= {:a 1 :b 2} {:a 1, :b 2})))

    (testing "hash-map-fn"
      (is (= {:a 1 :b 2} (hash-map :a 1 :b 2))))

    (testing "map-empty"
      (is (= {} (hash-map))))

    (testing "map-get"
      (is (= 1 (get {:a 1, :b 2} :a))))

    (testing "map-get-default"
      (is (= :not-found (get {:a 1} :b :not-found))))

    (testing "map-assoc"
      (is (= {:a 1 :b 2} (assoc {:a 1} :b 2))))

    (testing "map-dissoc"
      (is (= {:b 2} (dissoc {:a 1, :b 2} :a))))

    (testing "map-merge"
      (is (= {:a 1 :b 2} (merge {:a 1} {:b 2}))))

    (testing "map-keys"
      (is (= #{:b :a} (set (keys {:a 1, :b 2})))))

    (testing "map-vals"
      (is (= #{1 2} (set (vals {:a 1, :b 2})))))

    (testing "map-count"
      (is (= 2 (count {:a 1, :b 2}))))

    (testing "map-contains"
      (is (= true (contains? {:a 1} :a))))

    (testing "map-keyword-invoke"
      (is (= 1 (:a {:a 1, :b 2}))))

    (testing "map-as-fn"
      (is (= 2 ({:a 1, :b 2} :b))))

    (testing "set-literal"
      (is (= #{1 3 2} #{1 3 2})))

    (testing "hash-set-fn"
      (is (= #{1 3 2} (hash-set 1 2 3))))

    (testing "set-from-vec"
      (is (= #{1 3 2} (set [1 2 2 3]))))

    (testing "set-conj"
      (is (= #{1 3 2} (conj #{1 2} 3))))

    (testing "set-disj"
      (is (= #{1 3} (disj #{1 3 2} 2))))

    (testing "set-contains"
      (is (= true (contains? #{1 3 2} 2))))

    (testing "set-count"
      (is (= 3 (count #{1 3 2}))))

    (testing "set-as-fn"
      (is (= 2 (#{1 3 2} 2))))

    (testing "list-literal"
      (is (= '(1 2 3) (quote (1 2 3)))))

    (testing "list-fn"
      (is (= '(1 2 3) (list 1 2 3))))

    (testing "list-conj"
      (is (= '(1 2 3) (conj (quote (2 3)) 1))))

    (testing "list-count"
      (is (= 3 (count (quote (1 2 3))))))

    (testing "vector?"
      (is (= true (vector? [1 2]))))

    (testing "map?"
      (is (= true (map? {:a 1}))))

    (testing "set?"
      (is (= true (set? #{1 2}))))

    (testing "list?"
      (is (= true (list? (quote (1 2))))))

    (testing "coll?"
      (is (= true (coll? [1 2]))))

    (testing "seq?"
      (is (= true (seq? (seq [1 2])))))

    (testing "sequential?"
      (is (= true (sequential? [1 2]))))

    (testing "associative?"
      (is (= true (associative? {:a 1}))))

    (testing "counted?"
      (is (= true (counted? [1 2])))))

(deftest sequences-tests
    (testing "seq-on-nil"
      (is (= nil (seq nil))))

    (testing "seq-on-empty"
      (is (= nil (seq []))))

    (testing "seq-on-vec"
      (is (= [1 2 3] (vec (seq [1 2 3])))))

    (testing "first-nil"
      (is (= nil (first nil))))

    (testing "first-empty"
      (is (= nil (first []))))

    (testing "first-vec"
      (is (= 1 (first [1 2 3]))))

    (testing "second-vec"
      (is (= 2 (second [1 2 3]))))

    (testing "rest-nil"
      (is (= [] (vec (rest nil)))))

    (testing "rest-vec"
      (is (= [2 3] (vec (rest [1 2 3])))))

    (testing "next-nil"
      (is (= nil (next nil))))

    (testing "next-one"
      (is (= nil (next [1]))))

    (testing "next-vec"
      (is (= [2 3] (vec (next [1 2 3])))))

    (testing "last-vec"
      (is (= 3 (last [1 2 3]))))

    (testing "butlast-vec"
      (is (= [1 2] (vec (butlast [1 2 3])))))

    (testing "cons-nil"
      (is (= [1] (vec (cons 1 nil)))))

    (testing "cons-vec"
      (is (= [0 1 2] (vec (cons 0 [1 2])))))

    (testing "conj-nil"
      (is (= '(1) (conj nil 1))))

    (testing "concat-vecs"
      (is (= [1 2 3 4] (vec (concat [1 2] [3 4])))))

    (testing "concat-nil"
      (is (= [1 2] (vec (concat nil [1 2])))))

    (testing "concat-three"
      (is (= [1 2 3] (vec (concat [1] [2] [3])))))

    (testing "map-inc"
      (is (= [2 3 4] (vec (map inc [1 2 3])))))

    (testing "map-nil"
      (is (= [] (vec (map inc nil)))))

    (testing "map-multi"
      (is (= [4 6] (vec (map + [1 2] [3 4])))))

    (testing "mapv-inc"
      (is (= [2 3 4] (mapv inc [1 2 3]))))

    (testing "filter-even"
      (is (= [2 4] (vec (filter even? [1 2 3 4])))))

    (testing "filterv-odd"
      (is (= [1 3] (filterv odd? [1 2 3 4]))))

    (testing "remove-even"
      (is (= [1 3] (vec (remove even? [1 2 3 4])))))

    (testing "keep-identity"
      (is (= [1 2 3] (vec (keep identity [1 nil 2 nil 3])))))

    (testing "take-3"
      (is (= [1 2 3] (vec (take 3 [1 2 3 4 5])))))

    (testing "drop-2"
      (is (= [3 4 5] (vec (drop 2 [1 2 3 4 5])))))

    (testing "take-while"
      (is (= [1 2] (vec (take-while (fn* [p1__144#] (< p1__144# 3)) [1 2 3 4])))))

    (testing "drop-while"
      (is (= [3 4] (vec (drop-while (fn* [p1__145#] (< p1__145# 3)) [1 2 3 4])))))

    (testing "reverse-vec"
      (is (= [3 2 1] (vec (reverse [1 2 3])))))

    (testing "sort-vec"
      (is (= [1 2 3] (vec (sort [3 1 2])))))

    (testing "sort-by-neg"
      (is (= [3 2 1] (vec (sort-by - [1 2 3])))))

    (testing "distinct"
      (is (= [1 2 3] (vec (distinct [1 2 1 3 2])))))

    (testing "reduce-plus"
      (is (= 6 (reduce + [1 2 3]))))

    (testing "reduce-init"
      (is (= 16 (reduce + 10 [1 2 3]))))

    (testing "reduce-empty"
      (is (= 0 (reduce + []))))

    (testing "reduce-conj"
      (is (= [1 2 3] (reduce conj [] [1 2 3]))))

    (testing "reduce-kv"
      (is (= 3 (reduce-kv (fn [acc k v] (+ acc v)) 0 {:a 1, :b 2}))))

    (testing "reductions"
      (is (= [1 3 6] (vec (reductions + [1 2 3])))))

    (testing "reductions-init"
      (is (= [0 1 3 6] (vec (reductions + 0 [1 2 3])))))

    (testing "partition-2"
      (is (= [[1 2] [3 4]] (vec (map vec (partition 2 [1 2 3 4]))))))

    (testing "partition-all"
      (is (= [[1 2] [3]] (vec (map vec (partition-all 2 [1 2 3]))))))

    (testing "group-by-even"
      (is (= {false [1 3] true [2 4]} (group-by even? [1 2 3 4]))))

    (testing "frequencies"
      (is (= {:a 3 :b 2 :c 1} (frequencies [:a :b :a :c :b :a]))))

    (testing "into-vec"
      (is (= [1 2 3] (into [] (quote (1 2 3))))))

    (testing "into-set"
      (is (= #{1 3 2} (into #{} [1 2 2 3]))))

    (testing "into-map"
      (is (= {:a 1 :b 2} (into {} [[:a 1] [:b 2]]))))

    (testing "range-3"
      (is (= [0 1 2] (vec (range 3)))))

    (testing "range-1-4"
      (is (= [1 2 3] (vec (range 1 4)))))

    (testing "range-step"
      (is (= [0 2 4 6 8] (vec (range 0 10 2)))))

    (testing "repeat-3"
      (is (= [:x :x :x] (vec (repeat 3 :x)))))

    (testing "repeatedly-3"
      (is (= 3 (count (repeatedly 3 (constantly 1))))))

    (testing "interleave"
      (is (= [1 :a 2 :b] (vec (interleave [1 2] [:a :b])))))

    (testing "interpose"
      (is (= [1 :x 2 :x 3] (vec (interpose :x [1 2 3])))))

    (testing "flatten"
      (is (= [1 2 3 4 5] (vec (flatten [[1 2] [3 [4 5]]])))))

    (testing "mapcat"
      (is (= [2 1 4 3] (vec (mapcat reverse [[1 2] [3 4]])))))

    (testing "some-found"
      (is (= true (some even? [1 2 3]))))

    (testing "some-not-found"
      (is (= nil (some even? [1 3 5]))))

    (testing "every-true"
      (is (= true (every? pos? [1 2 3]))))

    (testing "every-false"
      (is (= false (every? pos? [1 -2 3]))))

    (testing "not-every"
      (is (= true (not-every? even? [1 2 3]))))

    (testing "not-any"
      (is (= true (not-any? even? [1 3 5])))))

(deftest functions-tests
    (testing "identity"
      (is (= 42 (identity 42))))

    (testing "constantly"
      (is (= 5 ((constantly 5) :any :args))))

    (testing "comp-empty"
      (is (= 5 ((comp) 5))))

    (testing "comp-single"
      (is (= 2 ((comp inc) 1))))

    (testing "comp-double"
      (is (= 3 ((comp inc inc) 1))))

    (testing "comp-str-inc"
      (is (= "2" ((comp str inc) 1))))

    (testing "partial-one"
      (is (= 3 ((partial + 1) 2))))

    (testing "partial-two"
      (is (= 6 ((partial + 1 2) 3))))

    (testing "partial-str"
      (is (= "ab" ((partial str "a") "b"))))

    (testing "complement-even"
      (is (= true ((complement even?) 3))))

    (testing "juxt-basic"
      (is (= [6 4] ((juxt inc dec) 5))))

    (testing "juxt-triple"
      (is (= [1 3 3] ((juxt first last count) [1 2 3]))))

    (testing "apply-plus"
      (is (= 6 (apply + [1 2 3]))))

    (testing "apply-prefix"
      (is (= 6 (apply + 1 [2 3]))))

    (testing "apply-str"
      (is (= "abc" (apply str ["a" "b" "c"]))))

    (testing "apply-vector"
      (is (= [1 2 3 4] (apply vector 1 2 [3 4]))))

    (testing "fnil-nil"
      (is (= 1 ((fnil inc 0) nil))))

    (testing "fnil-value"
      (is (= 6 ((fnil inc 0) 5))))

    (testing "every-pred"
      (is (= true ((every-pred pos? even?) 2))))

    (testing "some-fn"
      (is (= 2 ((some-fn :a :b) {:b 2})))))

(deftest arithmetic-tests
    (testing "plus-1"
      (is (= 5 (+ 5))))

    (testing "plus-2"
      (is (= 3 (+ 1 2))))

    (testing "plus-many"
      (is (= 15 (+ 1 2 3 4 5))))

    (testing "minus-1"
      (is (= -5 (- 5))))

    (testing "minus-2"
      (is (= 7 (- 10 3))))

    (testing "minus-many"
      (is (= 4 (- 10 1 2 3))))

    (testing "mult-1"
      (is (= 5 (* 5))))

    (testing "mult-2"
      (is (= 6 (* 2 3))))

    (testing "mult-many"
      (is (= 24 (* 2 3 4))))

    (testing "div-2"
      (is (= 5 (/ 10 2))))

    (testing "div-many"
      (is (= 5 (/ 20 2 2))))

    (testing "quot-pos"
      (is (= 3 (quot 10 3))))

    (testing "quot-neg"
      (is (= -3 (quot -10 3))))

    (testing "rem-pos"
      (is (= 1 (rem 10 3))))

    (testing "mod-neg"
      (is (= 2 (mod -10 3))))

    (testing "inc"
      (is (= 6 (inc 5))))

    (testing "dec"
      (is (= 4 (dec 5))))

    (testing "max-2"
      (is (= 5 (max 1 5))))

    (testing "max-many"
      (is (= 5 (max 3 1 4 1 5))))

    (testing "min-2"
      (is (= 1 (min 1 5))))

    (testing "min-many"
      (is (= 1 (min 3 1 4 1 5))))

    (testing "abs-pos"
      (is (= 5 (abs 5))))

    (testing "abs-neg"
      (is (= 5 (abs -5)))))

(deftest comparison-tests
    (testing "eq-2-true"
      (is (= true (= 1 1))))

    (testing "eq-2-false"
      (is (= false (= 1 2))))

    (testing "eq-nil"
      (is (= true (= nil nil))))

    (testing "eq-vec"
      (is (= true (= [1 2] [1 2]))))

    (testing "eq-map"
      (is (= true (= {:a 1} {:a 1}))))

    (testing "eq-set"
      (is (= true (= #{1 2} #{1 2}))))

    (testing "lt-2-true"
      (is (= true (< 1 2))))

    (testing "lt-2-false"
      (is (= false (< 2 1))))

    (testing "gt-2-true"
      (is (= true (> 2 1))))

    (testing "gt-2-false"
      (is (= false (> 1 2))))

    (testing "lte-true"
      (is (= true (<= 1 2))))

    (testing "lte-eq"
      (is (= true (<= 2 2))))

    (testing "gte-true"
      (is (= true (>= 2 1))))

    (testing "gte-eq"
      (is (= true (>= 2 2))))

    (testing "compare-lt"
      (is (= -1 (compare 1 2))))

    (testing "compare-eq"
      (is (= 0 (compare 1 1))))

    (testing "compare-gt"
      (is (= 1 (compare 2 1)))))

(deftest predicates-tests
    (testing "nil?-true"
      (is (= true (nil? nil))))

    (testing "nil?-false"
      (is (= false (nil? 0))))

    (testing "some?-nil"
      (is (= false (some? nil))))

    (testing "some?-value"
      (is (= true (some? false))))

    (testing "true?-true"
      (is (= true (true? true))))

    (testing "true?-1"
      (is (= false (true? 1))))

    (testing "false?-false"
      (is (= true (false? false))))

    (testing "false?-nil"
      (is (= false (false? nil))))

    (testing "boolean?-true"
      (is (= true (boolean? true))))

    (testing "boolean?-num"
      (is (= false (boolean? 0))))

    (testing "number?-int"
      (is (= true (number? 42))))

    (testing "number?-str"
      (is (= false (number? "42"))))

    (testing "integer?-int"
      (is (= true (integer? 42))))

    (testing "integer?-float"
      (is (= false (integer? 3.14))))

    (testing "float?-float"
      (is (= true (float? 3.14))))

    (testing "string?-str"
      (is (= true (string? "hello"))))

    (testing "string?-key"
      (is (= false (string? :hello))))

    (testing "keyword?-key"
      (is (= true (keyword? :foo))))

    (testing "symbol?-sym"
      (is (= true (symbol? (quote foo)))))

    (testing "fn?-fn"
      (is (= true (fn? inc))))

    (testing "empty?-vec"
      (is (= true (empty? []))))

    (testing "empty?-nil"
      (is (= true (empty? nil))))

    (testing "zero?-0"
      (is (= true (zero? 0))))

    (testing "pos?-1"
      (is (= true (pos? 1))))

    (testing "neg?-minus1"
      (is (= true (neg? -1))))

    (testing "even?-2"
      (is (= true (even? 2))))

    (testing "odd?-3"
      (is (= true (odd? 3)))))

(deftest strings-tests
    (testing "str-empty"
      (is (= "" (str))))

    (testing "str-one"
      (is (= "hello" (str "hello"))))

    (testing "str-multi"
      (is (= "abc" (str "a" "b" "c"))))

    (testing "str-mixed"
      (is (= "1:a" (str 1 :a nil))))

    (testing "count-str"
      (is (= 5 (count "hello"))))

    (testing "subs-2"
      (is (= "ello" (subs "hello" 1))))

    (testing "subs-3"
      (is (= "ell" (subs "hello" 1 4))))

    (testing "name-keyword"
      (is (= "foo" (name :foo))))

    (testing "name-symbol"
      (is (= "bar" (name (quote bar)))))

    (testing "namespace-keyword"
      (is (= "foo" (namespace :foo/bar))))

    (testing "keyword-str"
      (is (= :test (keyword "test"))))

    (testing "symbol-str"
      (is (= 'test (symbol "test")))))

(deftest atoms-tests
    (testing "atom-create"
      (is (= 42 (deref (atom 42)))))

    (testing "atom-reset"
      (is (= 2 (let [a (atom 1)] (reset! a 2) (clojure.core/deref a)))))

    (testing "atom-swap"
      (is (= 2 (let [a (atom 1)] (swap! a inc) (clojure.core/deref a)))))

    (testing "atom-swap-args"
      (is (= 6 (let [a (atom 1)] (swap! a + 5) (clojure.core/deref a))))))

(deftest bitops-tests
    (testing "bit-and"
      (is (= 1 (bit-and 5 3))))

    (testing "bit-or"
      (is (= 7 (bit-or 5 3))))

    (testing "bit-xor"
      (is (= 6 (bit-xor 5 3))))

    (testing "bit-not"
      (is (= -1 (bit-not 0))))

    (testing "bit-shift-left"
      (is (= 16 (bit-shift-left 1 4))))

    (testing "bit-shift-right"
      (is (= 1 (bit-shift-right 16 4))))

    (testing "bit-test-true"
      (is (= true (bit-test 4 2))))

    (testing "bit-test-false"
      (is (= false (bit-test 4 0))))

    (testing "bit-set"
      (is (= 4 (bit-set 0 2))))

    (testing "bit-clear"
      (is (= 5 (bit-clear 7 1))))

    (testing "bit-flip"
      (is (= 4 (bit-flip 0 2)))))

(deftest exceptions-tests
    (testing "try-success"
      (is (= 42 (try 42 (catch Exception e -1)))))

    (testing "try-catch"
      (is (= :caught (try (throw (ex-info "test" {})) (catch Exception e :caught)))))

    (testing "ex-info-msg"
      (is (= "test" (try (throw (ex-info "test" {:a 1})) (catch Exception e (ex-message e))))))

    (testing "ex-info-data"
      (is (= {:a 1} (try (throw (ex-info "test" {:a 1})) (catch Exception e (ex-data e)))))))

(deftest scaling-tests
    (testing "vector-nth-O1 - O1"
      (let [setup-fn (fn [n] (vec (range n)))
            test-fn (fn [v] (nth v (quot (count v) 2)))
            timings (into {}
                      (for [n [100 1000 10000 100000]]
                        (let [data (setup-fn n)
                              [_ time] (parity/timed (dotimes [_ 100] (test-fn data)))]
                          [n (/ time 100.0)])))]
        (is (parity/verify-complexity timings :O1))))

    (testing "vector-conj-O1 - O1"
      (let [setup-fn (fn [n] (vec (range n)))
            test-fn (fn [v] (conj v :x))
            timings (into {}
                      (for [n [1000 10000 100000 1000000]]
                        (let [data (setup-fn n)
                              [_ time] (parity/timed (dotimes [_ 100] (test-fn data)))]
                          [n (/ time 100.0)])))]
        (is (parity/verify-complexity timings :O1))))

    (testing "map-get-O1 - O1"
      (let [setup-fn (fn [n] (into {} (map (fn [i] [i i]) (range n))))
            test-fn (fn [m] (get m (quot (count m) 2)))
            timings (into {}
                      (for [n [100 1000 10000 100000]]
                        (let [data (setup-fn n)
                              [_ time] (parity/timed (dotimes [_ 100] (test-fn data)))]
                          [n (/ time 100.0)])))]
        (is (parity/verify-complexity timings :O1))))

    (testing "map-assoc-O1 - O1"
      (let [setup-fn (fn [n] (into {} (map (fn [i] [i i]) (range n))))
            test-fn (fn [m] (assoc m :new :value))
            timings (into {}
                      (for [n [100 1000 10000 100000]]
                        (let [data (setup-fn n)
                              [_ time] (parity/timed (dotimes [_ 100] (test-fn data)))]
                          [n (/ time 100.0)])))]
        (is (parity/verify-complexity timings :O1))))

    (testing "set-contains-O1 - O1"
      (let [setup-fn (fn [n] (set (range n)))
            test-fn (fn [s] (contains? s (quot (count s) 2)))
            timings (into {}
                      (for [n [100 1000 10000 100000]]
                        (let [data (setup-fn n)
                              [_ time] (parity/timed (dotimes [_ 100] (test-fn data)))]
                          [n (/ time 100.0)])))]
        (is (parity/verify-complexity timings :O1)))))

;; ============================================================
;; Run all tests
;; ============================================================

(defn run-parity-suite []
  (parity/reset-results!)
  (let [results (run-tests)]
    (parity/print-test-results-report)
    (parity/export-results "parity_results.edn")
    results))

;; Run when loaded
(run-parity-suite)
