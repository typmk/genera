{"version":3,"sources":["malli/generator.cljc"],"mappings":"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","names":["malli$generator$Generator$_generator$dyn","x__5350__auto__","m__5351__auto__","malli.generator/-generator","goog/typeOf","m__5349__auto__","cljs.core/missing-protocol","malli.generator/Generator","this","options","malli.generator/nil-gen","clojure.test.check.generators/return","p__20865","map__20866","cljs.core/--destructure-map","cljs.core.get","malli.generator/-never-gen","original-generator-schema","_options","cljs.core/with-meta","clojure.test.check.generators/sized","_","malli.core._fail_BANG_","G__20867","cljs.core.assoc","malli.generator/-unreachable-gen?","g","cljs.core/meta","cljs.core/boolean","malli.generator/-not-unreachable","malli.generator/-random","seed","clojure.test.check.random.make_random","malli.generator/-recur","_schema","cljs.core.println","malli.generator/-maybe-recur","malli.generator/-min-max","schema","map__20868","min","max","gen-min","gen-max","malli.core.properties","and__5000__auto__","or__5002__auto__","malli.generator/-double-gen","clojure.test.check.generators/double*","cljs.core.merge","malli.generator/gen-vector-min","gen","G__20870","p1__20869#","clojure.test.check.generators.vector","cljs.core.vary_meta","cljs.core/assoc","malli.generator/-string-gen","map__20871","cljs.core._EQ_","clojure.test.check.generators/fmap","clojure.string/join","clojure.test.check.generators/char-alphanumeric","clojure.test.check.generators/string-alphanumeric","malli.generator/-coll-gen","f","map__20872","child","malli.core.children","cljs.core/first","malli.generator/generator","malli.generator/-coll-distinct-gen","map__20874","G__20875","p1__20873#","clojure.test.check.generators.vector_distinct","malli.core/-exception","malli.generator/-and-gen","temp__5806__auto__","G__20877","G__20878","p1__20876#","clojure.test.check.generators.such_that","malli.core.validator","malli.generator/gen-one-of","gs","cljs.core/count","clojure.test.check.generators/one-of","malli.generator/-seqable-gen","el","p1__20880#","cljs.core.into","p1__20879#","cljs.core.map","cljs.core/identity","cljs.core/vec","cljs.core/eduction","cljs.core.into_array","cljs.core.conj","cljs.core/set","G__20881","malli.core.type","vec__20882","cljs.core.nth","k","v","G__20885","G__20886","malli.generator/-or-gen","cljs.core/not-empty","p1__20887#","cljs.core.keep","malli.generator/-merge-keyword-dispatch-map-into-entries","dispatch","G__20889","cljs.core/Keyword","p1__20888#","malli.util.transform_entries","p__20890","vec__20891","e","G__20894","cljs.core.not_EQ_","cljs.core.update","malli.util/merge","malli.core.options","malli.generator/-multi-gen","malli.core.entries","p1__20895#","G__20896","G__20897","cljs.core/last","malli.generator/-build-map","kvs","cljs.core/persistent!","cljs.core.reduce","p__20898","vec__20899","acc","cljs.core/map?","cljs.core/reduce-kv","cljs.core/assoc!","cljs.core.assoc_BANG_","cljs.core/transient","malli.generator/-value-gen","s","G__20902","malli.generator/-map-gen","G__20909","vec__20910","seq__20911","cljs.core/seq","first__20912","cljs.core/next","vec__20913","vec__20922","seq__20923","first__20924","vec__20925","entries","gens","cljs.core.apply","clojure.test.check.generators/tuple","malli.impl.util/-last","temp__5802__auto__","malli.generator/-map-of-gen","map__20931","vec__20932","k-gen","v-gen","p1__20928#","cljs.core/some","opts","p1__20929#","p1__20930#","clojure.test.check.generators.vector_distinct_by","clojure.test.check.generators.tuple","malli.generator/-identify-ref-schema","malli.core/-options","malli.core._registry","malli.registry/-schemas","malli.core/-ref","malli.generator/-ref-gen","ref-id","cljs.core/force","cljs.core.get_in","scalar-ref-gen","cljs.core/Delay","dschema","malli.core.deref","G__20936","G__20937","G__20938","cljs.core/assoc-in","cljs.core/realized?","p1__20935#","clojure.test.check.generators/recursive-gen","G__20939","G__20940","malli.generator/-=>-gen","output-generator","G__20941","G__20942","malli.core/-function-info","malli.core._instrument","malli.generator/generate","malli.generator/-function-gen","p1__20943#","malli.generator/-regex-generator","malli.core/-regex-op?","G__20944","malli.generator/entry->schema","cljs.core/vector?","malli.generator/-cat-gen","p1__20945#","p1__20946#","cljs.core/concat","malli.generator/-alt-gen","p1__20947#","cljs.core/every?","malli.generator/-?-gen","malli.core/-get","malli.generator/-*-gen","mode","cljs.core.dissoc","G__20950","G__20951","js/Error","p1__20948#","G__20949","malli.generator/-+-gen","malli.generator/-repeat-gen","G__20953","p1__20952#","malli.generator/-qualified-ident-gen","mk-value-with-ns","value-with-ns-gen-size","pred","namespace-unparsed","G__20955","G__20956","cljs.core/name","p1__20954#","malli.generator/-qualified-keyword-gen","cljs.core/keyword","clojure.test.check.generators/keyword","cljs.core/qualified-keyword?","clojure.test.check.generators/keyword-ns","malli.generator/-qualified-symbol-gen","cljs.core/symbol","clojure.test.check.generators/symbol","cljs.core/qualified-symbol?","clojure.test.check.generators/symbol-ns","malli.generator/gen-elements","es","clojure.test.check.generators/elements","js/malli","js/malli.generator","js/malli.generator.-schema-generator","method-table__5599__auto__","cljs.core.atom","prefer-table__5600__auto__","method-cache__5601__auto__","cached-hierarchy__5602__auto__","hierarchy__5603__auto__","fexpr__20957","cljs.core/MultiFn","cljs.core.symbol","malli.generator/-schema-generator","cljs.spec.gen.alpha/gen-for-pred","p1__20958#","p1__20959#","clojure.test.check.generators/any-printable","cljs.core/inc","clojure.test.check.generators/nat","cljs.core.comp","cljs.core/dec","cljs.core/-","p1__20960#","cljs.core/any?","malli.core.into_schema","G__20961","G__20962","G__20963","G__20964","G__20965","p1__20966#","cljs.core/not-any?","clojure.test.check.generators/large-integer*","props","p1__20967#","G__20969","p1__20968#","G__20970","max-float","js/Number","min-float","min-max-props","infinite?","p1__20971#","G__20973","p1__20972#","G__20974","cljs.core/float","clojure.test.check.generators/boolean","clojure.test.check.generators/uuid","G__20975","G__20976","G__20977","G__20978","G__20979","G__20980","G__20981","G__20982","G__20983","G__20984","malli.generator/-create-from-return","cljs.core/contains?","malli.generator/-create-from-elements","G__20985","malli.generator/-create-from-gen","malli.generator/-create-from-schema","G__20986","malli.generator/-create-from-fmap","temp__5808__auto__","fmap","malli.core.eval","malli.generator/-create","malli.impl.util/-merge","malli.core.type_properties","var_args","G__20989","?schema","malli.generator.generator","malli.core.schema","p1__20987#","malli.core/-cached","G__20991","p__20992","map__20993","?gen-or-schema","malli.generator.generate","size","clojure.test.check.generators/generator?","clojure.test.check.rose-tree/root","clojure.test.check.generators/call-gen","G__20997","malli.generator/sample","p__20998","map__20999","malli.generator.sample","clojure.test.check.generators/make-size-range-seq","p1__20994#","p2__20995#","clojure.test.check.generators/lazy-random-states","cljs.core.take","G__21004","malli.generator/function-checker","p__21005","map__21006","malli.generator.function_checker","=>iterations","-try","e21007","check","map__21008","input","output","guard","input-generator","valid-output?","valid-guard?","cljs.core/constantly","validate","args","$","G__21009","map__21010","result","shrunk","p1__21000#","clojure.test.check.properties/for-all*","clojure.test.check/quick-check","smallest","vec__21011","explain-input","malli.core.explain","success","explain-output","cljs.core/not","explain-guard","G__21014","cljs.core/ex-message","malli.core/-function-schema?","checkers","p1__21001#","malli.core/-function-schema-arities","x","p1__21002#","malli.core/-type","G__21017","malli.generator/check","malli.generator.check","p1__21015#","malli.core/-update-options"],"sourcesContent":[";; See also `malli.generator-ast` for viewing generators as data\n(ns malli.generator\n  (:require [clojure.spec.gen.alpha :as ga]\n            [clojure.string :as str]\n            [clojure.test.check :as check]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            [malli.core :as m]\n            [malli.registry :as mr]\n            [malli.util :as mu]\n            [malli.impl.util :refer [-last -merge]]\n            #?(:clj [borkdude.dynaload :as dynaload])))\n\n(declare generator generate -create)\n\n(defprotocol Generator\n  (-generator [this options] \"returns generator for schema\"))\n\n;;\n;; generators\n;;\n\n\n;; # Notes for implementors\n;;\n;; For the most part, -schema-generator is a pretty direct translation from schemas to generators.\n;; However, the naive implementation of recursive ref's (creating a generator for the dereferenced ref\n;; and cutting off the generation at a certain depth) tends to create exponentially large test cases.\n;;\n;; We use a more sophisticated algorithm to achieve linearly sized test cases with recursive refs.\n;; The next section describes the strategy implementors should use to participate in this improved behavior.\n;; The theory behind this strategy is described in the section below (\"Approach for recursive generators\").\n;;\n;; ## Implementation strategy\n;;\n;; Say you have a composite schema you want to generate values for. You should extend `-schema-generator` and\n;; call `generator` recursively on the `m/children`. Now, for every child generator, you need to consider the case\n;; that the child generator generates no values, and how this might change the final generator.\n;;\n;; Use `-unreachable-gen?` to test whether your child generator generates no values (we'll call this an \"unreachable\" schema/generator).\n;; If your parent generator cannot generate values, use `-never-gen` to return an unreachable generator.\n;; \n;; Here are a few examples---compare them with the logic in their respective -schema-generator methods:\n;;   [:maybe M] would generate like :nil if M were unreachable.\n;;   [:map [:a M]] would itself be unreachable if M were unreachable.\n;;   [:map [:a {:optional true} M]] would generate like [:map] if M were unreachable.\n;;   [:vector M] would generate like [:= []] if M were unreachable.\n;;   [:vector {:min 1} M] would itself be unreachable if M were unreachable.\n\n(def nil-gen (gen/return nil))\n\n(defn -never-gen\n  \"Return a generator of no values that is compatible with -unreachable-gen?.\"\n  [{::keys [original-generator-schema] :as _options}]\n  (with-meta (gen/sized (fn [_]\n                          (m/-fail! ::infinitely-expanding-schema\n                                    (cond-> {}\n                                      original-generator-schema (assoc :schema original-generator-schema)))))\n             {::never-gen true\n              ::original-generator-schema original-generator-schema}))\n\n(defn -unreachable-gen?\n  \"Returns true iff generator g generators no values.\"\n  [g] (-> (meta g) ::never-gen boolean))\n\n(defn -not-unreachable [g] (when-not (-unreachable-gen? g) g))\n\n(defn- -random [seed] (if seed (random/make-random seed) (random/make-random)))\n\n(defn ^:deprecated -recur [_schema options]\n  (println (str `-recur \" is deprecated, please update your generators. See instructions in malli.generator.\"))\n  [true options])\n\n(defn ^:deprecated -maybe-recur [_schema options]\n  (println (str `-maybe-recur \" is deprecated, please update your generators. See instructions in malli.generator.\"))\n  options)\n\n(defn -min-max [schema options]\n  (let [{:keys [min max] gen-min :gen/min gen-max :gen/max} (m/properties schema options)]\n    (when (and min gen-min (< gen-min min))\n      (m/-fail! ::invalid-property {:key :gen/min, :value gen-min, :min min}))\n    (when (and max gen-max (> gen-max max))\n      (m/-fail! ::invalid-property {:key :gen/max, :value gen-min, :max min}))\n    {:min (or gen-min min)\n     :max (or gen-max max)}))\n\n(defn- -double-gen [options] (gen/double* (merge {:infinite? false, :NaN? false} options)))\n\n(defn- gen-vector-min [gen min options]\n  (cond-> (gen/sized #(gen/vector gen min (+ min %)))\n    (::generator-ast options) (vary-meta assoc ::generator-ast\n                                         {:op :vector-min\n                                          :generator gen\n                                          :min min})))\n\n(defn- -string-gen [schema options]\n  (let [{:keys [min max]} (-min-max schema options)]\n    (cond\n      (and min (= min max)) (gen/fmap str/join (gen/vector gen/char-alphanumeric min))\n      (and min max) (gen/fmap str/join (gen/vector gen/char-alphanumeric min max))\n      min (gen/fmap str/join (gen-vector-min gen/char-alphanumeric min options))\n      max (gen/fmap str/join (gen/vector gen/char-alphanumeric 0 max))\n      :else gen/string-alphanumeric)))\n\n(defn- -coll-gen [schema f options]\n  (let [{:keys [min max]} (-min-max schema options)\n        child (-> schema m/children first)\n        gen (generator child options)]\n    (if (-unreachable-gen? gen)\n      (if (= 0 (or min 0))\n        (gen/fmap f (gen/return []))\n        (-never-gen options))\n      (gen/fmap f (cond\n                    (and min (= min max)) (gen/vector gen min)\n                    (and min max) (gen/vector gen min max)\n                    min (gen-vector-min gen min options)\n                    max (gen/vector gen 0 max)\n                    :else (gen/vector gen))))))\n\n(defn- -coll-distinct-gen [schema f options]\n  (let [{:keys [min max]} (-min-max schema options)\n        child (-> schema m/children first)\n        gen (generator child options)]\n    (if (-unreachable-gen? gen)\n      (if (= 0 (or min 0))\n        (gen/return (f []))\n        (-never-gen options))\n      (gen/fmap f (gen/vector-distinct gen {:min-elements min, :max-elements max, :max-tries 100\n                                            :ex-fn #(m/-exception ::distinct-generator-failure\n                                                                  (assoc % :schema schema))})))))\n\n(defn -and-gen [schema options]\n  (if-some [gen (-not-unreachable (-> schema (m/children options) first (generator options)))]\n    (gen/such-that (m/validator schema options) gen\n                   {:max-tries 100\n                    :ex-fn #(m/-exception ::and-generator-failure\n                                          (assoc % :schema schema))})\n    (-never-gen options)))\n\n(defn- gen-one-of [gs]\n  (if (= 1 (count gs))\n    (first gs)\n    (gen/one-of gs)))\n\n(defn- -seqable-gen [schema options]\n  (let [el (-> schema m/children first)]\n    (gen-one-of\n     (-> [nil-gen]\n         (into (map #(-coll-gen schema % options))\n               [identity vec eduction #(into-array #?(:clj Object) %)])\n         (conj (-coll-distinct-gen schema set options))\n         (cond->\n           (and (= :tuple (m/type el))\n                (= 2 (count (m/children el))))\n           (conj (let [[k v] (m/children el)]\n                   (generator [:map-of (or (m/properties schema) {}) k v] options))))))))\n\n(defn -or-gen [schema options]\n  (if-some [gs (not-empty\n                (into [] (keep #(-not-unreachable (generator % options)))\n                      (m/children schema options)))]\n    (gen-one-of gs)\n    (-never-gen options)))\n\n(defn- -merge-keyword-dispatch-map-into-entries [schema]\n  (let [dispatch (-> schema m/properties :dispatch)]\n    (cond-> schema\n      (keyword? dispatch)\n      (mu/transform-entries\n       #(map (fn [[k :as e]]\n               (cond-> e\n                 (not= ::m/default k)\n                 (update 2 mu/merge [:map [dispatch [:= nil k]]]))) %)\n       (m/options schema)))))\n\n(defn -multi-gen [schema options]\n  (if-some [gs (->> (m/entries (-merge-keyword-dispatch-map-into-entries schema) options)\n                    (into [] (keep #(-not-unreachable (generator (last %) options))))\n                    (not-empty))]\n    (gen-one-of gs)\n    (-never-gen options)))\n\n(defn- -build-map [kvs]\n  (persistent!\n   (reduce\n    (fn [acc [k v]]\n      (cond (and (= k ::m/default) (map? v)) (reduce-kv assoc! acc v)\n            (nil? k) acc\n            :else (assoc! acc k v)))\n    (transient {}) kvs)))\n\n(defn- -value-gen [k s options]\n  (let [g (generator s options)]\n    (cond->> g (-not-unreachable g) (gen/fmap (fn [v] [k v])))))\n\n(defn -map-gen [schema options]\n  (loop [[[k s :as e] & entries] (m/entries schema)\n         gens []]\n    (if (nil? e)\n      (gen/fmap -build-map (apply gen/tuple gens))\n      (if (-> e -last m/properties :optional)\n        ;; opt\n        (recur\n         entries\n         (conj gens\n               (if-let [g (-not-unreachable (-value-gen k s options))]\n                 (gen-one-of [nil-gen g])\n                 nil-gen)))\n        ;;; req\n        (let [g (-value-gen k s options)]\n          (if (-unreachable-gen? g)\n            (-never-gen options)\n            (recur entries (conj gens g))))))))\n\n(defn -map-of-gen [schema options]\n  (let [{:keys [min max]} (-min-max schema options)\n        [k-gen v-gen :as gs] (map #(generator % options) (m/children schema options))]\n    (if (some -unreachable-gen? gs)\n      (if (= 0 (or min 0))\n        (gen/return {})\n        (-never-gen options))\n      (let [opts (-> (cond\n                       (and min (= min max)) {:num-elements min}\n                       (and min max) {:min-elements min :max-elements max}\n                       min {:min-elements min}\n                       max {:max-elements max})\n                     (assoc :ex-fn #(m/-exception ::distinct-generator-failure (assoc % :schema schema))))]\n        (gen/fmap #(into {} %) (gen/vector-distinct-by first (gen/tuple k-gen v-gen) opts))))))\n\n#?(:clj\n   (defn -re-gen [schema options]\n     ;; [com.gfredericks/test.chuck \"0.2.10\"+]\n     (if-let [string-from-regex @(dynaload/dynaload 'com.gfredericks.test.chuck.generators/string-from-regex {:default nil})]\n       (let [re (or (first (m/children schema options)) (m/form schema options))]\n         (string-from-regex (re-pattern (str/replace (str re) #\"^\\^?(.*?)(\\$?)$\" \"$1\"))))\n       (m/-fail! :test-chuck-not-available))))\n\n;; # Approach for recursive generators\n;;\n;; `-ref-gen` is the only place where recursive generators can be created, and we use `gen/recursive-gen`\n;; to handle the recursion. The challenge is that gen/recursive-gen requires _two_ arguments: the base\n;; case (scalar gen) and the recursive case (container gen). We need to automatically split the schema argument into\n;; these two cases.\n;;\n;; The main insight we use is that a base case for the schema cannot contain recursive references to itself.\n;; A particularly useful base case is simply to \"delete\" all recursive references. To simulate this, we have the concept of\n;; an \"unreachable\" generator, which represents a \"deleted\" recursive reference.\n;;\n;; For infinitely expanding schemas, this will return an unreachable generator--when the base case generator is used,\n;; the error message in `-never-gen` will advise users that their schema is infinite.\n;; \n;; \n;; Examples of base cases of some recursive schemas:\n;;\n;; Schema:    [:schema {:registry {::cons [:maybe [:vector [:tuple pos-int? [:ref ::cons]]]]}} ::cons]\n;; Base case: [:schema {:registry {::cons [:nil                                            ]}} ::cons]\n;;\n;; Schema:    [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] [:maybe [:ref ::ping]]]}}\n;;             ::ping]\n;; Base case: [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] :nil                  ]}}\n;;             ::ping]\n;;\n;; Once we have the base case, we first need determine if the schema is recursive---it's recursive\n;; if more than one recursive reference was successfully \"deleted\" while creating the base case (see below for how we determine recursive references).\n;; We can then construct the recursive case by providing `gen/recursive-gen` the base case\n;; (this is why this particular base case is so useful) and then propagate the (smaller) generator\n;; supplied by `gen/recursive-gen` to convert recursive references.\n\n;; ## Identifying schema recursion\n;; \n;; Refs are uniquely identified by their paired name and scope. If we see a ref with the\n;; same name and scope as another ref we've dereferenced previously, we know that this is a recursion\n;; point back to the previously seen ref. The rest of this section explains why.\n;; \n;; Refs resolve via dynamic scope, which means its dereferenced value is the latest binding found\n;; while expanding the schema until the point of finding the ref.\n;; This makes the (runtime) scope at the ref's location part of a ref's identity---if the scope\n;; is different, then it's (possibly) not the same ref because scope determines how schemas\n;; transitively expand.\n;;\n;; To illustrate why a ref's name is an insufficient identifier, here is a schema that is equivalent to `[:= 42]`:\n;; \n;;   [:schema {:registry {::a [:schema {:registry {::a [:= 42]}}\n;;                             ;; (2)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identify refs just by name, we would have incorrectly detected (2) to be an (infinitely expanding) recursive\n;; reference.\n;;\n;; In studying the previous example, we might think that since (1) and (2) deref to different schemas, it might sufficient to identify refs just by their derefs.\n;; Unfortunately this just pushes the problem elsewhere.\n;;\n;; For example, here is another schema equivalent to `[:= 42]`:\n;;\n;;   [:schema {:registry {::a [:ref ::b] ;; (2)\n;;                        ::b [:schema {:registry {::a [:ref ::b] ;; (4)\n;;                                                 ::b [:= 42]}}\n;;                             ;; (3)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identified ::a by its deref, it would look like (3) deref'ing to (4)\n;; is a recursion point after witnessing (1) deref'ing to (2), since (2) == (4). Except this\n;; is wrong since it's a different ::b at (2) and (4)! OTOH, if we identified (2) and (4) with their\n;; dynamic scopes along with their form, they would be clearly different. Indeed, this\n;; is another way to identify refs: pairing their derefs with their deref's scopes.\n;; It is slightly more direct to use the ref's direct name and scope, which is why\n;; we choose that identifier. The more general insight is that any schema is identified by its form+scope\n;; (note: but only after trimming the scope of irrelevant bindings, see next pararaph).\n;; That insight may be useful for detecting recursion at places other than refs.\n;; \n;; Ref identifiers could be made smarter by trimming irrelevant entries in identifying scope.\n;; Not all scope differences are relevant, so generators may expand more than strictly necessary\n;; in the quest to find the \"same\" ref schema again. It could skip over refs that generate exactly the\n;; same values, but their scopes are uninterestingly different (eg., unused bindings are different).\n;;\n;; For example, the following schema is recursive \"in spirit\" between (1) and (2), but since ::b\n;; changes, the scope will differ, so the recursion will be detected between (2) and itself instead\n;; (where the scope is constant):\n;;\n;;   [:schema {:registry {::a [:schema {:registry {::b :boolean}}\n;;                             ;; (2)\n;;                             [:or [:ref ::a] [:ref ::b]]]}}\n;;    [:schema {:registry {::b :int}}\n;;     ;; (1)\n;;     [:or [:ref ::a] [:ref ::b]]]]\n\n(defn- -identify-ref-schema [schema]\n  {:scope (-> schema m/-options m/-registry mr/-schemas)\n   :name (m/-ref schema)})\n\n(defn -ref-gen [schema options]\n  (let [ref-id (-identify-ref-schema schema)]\n    (or (force (get-in options [::rec-gen ref-id]))\n        (let [scalar-ref-gen (delay (-never-gen options))\n              dschema (m/deref schema)]\n          (cond->> (generator dschema (assoc-in options [::rec-gen ref-id] scalar-ref-gen))\n            (realized? scalar-ref-gen) (gen/recursive-gen\n                                        #(generator dschema (assoc-in options [::rec-gen ref-id] %))))))))\n\n(defn -=>-gen [schema options]\n  (let [output-generator (generator (:output (m/-function-info schema)) options)]\n    (gen/return (m/-instrument {:schema schema} (fn [& _] (generate output-generator options))))))\n\n(defn -function-gen [schema options]\n  (gen/return (m/-instrument {:schema schema, :gen #(generate % options)} nil options)))\n\n(defn -regex-generator [schema options]\n  (if (m/-regex-op? schema)\n    (generator schema options)\n    (let [g (generator schema options)]\n      (cond-> g\n        (-not-unreachable g) gen/tuple))))\n\n(defn- entry->schema [e] (if (vector? e) (get e 2) e))\n\n(defn -cat-gen [schema options]\n  (let [gs (->> (m/children schema options)\n                (map #(-regex-generator (entry->schema %) options)))]\n    (if (some -unreachable-gen? gs)\n      (-never-gen options)\n      (->> gs\n           (apply gen/tuple)\n           (gen/fmap #(apply concat %))))))\n\n(defn -alt-gen [schema options]\n  (let [gs (->> (m/children schema options)\n                (keep #(-regex-generator (entry->schema %) options)))]\n    (if (every? -unreachable-gen? gs)\n      (-never-gen options)\n      (gen-one-of (into [] (keep -not-unreachable) gs)))))\n\n(defn -?-gen [schema options]\n  (let [child (m/-get schema 0 nil)]\n    (if-some [g (-not-unreachable (generator child options))]\n      (if (m/-regex-op? child)\n        (gen/one-of [g (gen/return ())])\n        (gen/vector g 0 1))\n      (gen/return ()))))\n\n(defn -*-gen [schema options]\n  (let [child (m/-get schema 0 nil)\n        mode (::-*-gen-mode options :*)\n        options (dissoc options ::-*-gen-mode)]\n    (if-some [g (-not-unreachable (generator child options))]\n      (cond->> (case mode\n                 :* (gen/vector g)\n                 :+ (gen-vector-min g 1 options))\n        (m/-regex-op? child)\n        (gen/fmap #(apply concat %)))\n      (case mode\n        :* (gen/return ())\n        :+ (-never-gen options)))))\n\n(defn -+-gen [schema options]\n  (-*-gen schema (assoc options ::-*-gen-mode :+)))\n\n(defn -repeat-gen [schema options]\n  (let [child (m/-get schema 0 nil)]\n    (if-some [g (-not-unreachable (-coll-gen schema identity options))]\n      (cond->> g\n        (m/-regex-op? child)\n        (gen/fmap #(apply concat %)))\n      (gen/return ()))))\n\n(defn -qualified-ident-gen [schema mk-value-with-ns value-with-ns-gen-size pred gen]\n  (if-let [namespace-unparsed (:namespace (m/properties schema))]\n    (gen/fmap (fn [k] (mk-value-with-ns (name namespace-unparsed) (name k))) value-with-ns-gen-size)\n    (gen/such-that pred gen {:ex-fn #(m/-exception ::qualified-ident-gen-failure (assoc % :schema schema))})))\n\n(defn -qualified-keyword-gen [schema]\n  (-qualified-ident-gen schema keyword gen/keyword qualified-keyword? gen/keyword-ns))\n\n(defn -qualified-symbol-gen [schema]\n  (-qualified-ident-gen schema symbol gen/symbol qualified-symbol? gen/symbol-ns))\n\n(defn- gen-elements [es]\n  (if (= 1 (count es))\n    (gen/return (first es))\n    (gen/elements es)))\n\n(defmulti -schema-generator (fn [schema options] (m/type schema options)) :default ::default)\n\n(defmethod -schema-generator ::default [schema options] (ga/gen-for-pred (m/validator schema options)))\n\n(defmethod -schema-generator :> [schema options] (-double-gen {:min (-> schema (m/children options) first inc)}))\n(defmethod -schema-generator :>= [schema options] (-double-gen {:min (-> schema (m/children options) first)}))\n(defmethod -schema-generator :< [schema options] (-double-gen {:max (-> schema (m/children options) first dec)}))\n(defmethod -schema-generator :<= [schema options] (-double-gen {:max (-> schema (m/children options) first)}))\n(defmethod -schema-generator := [schema options] (gen/return (first (m/children schema options))))\n(defmethod -schema-generator :not= [schema options] (gen/such-that #(not= % (-> schema (m/children options) first)) gen/any-printable\n                                                                   {:max-tries 100\n                                                                    :ex-fn #(m/-exception ::not=-generator-failure (assoc % :schema schema))}))\n(defmethod -schema-generator 'pos? [_ _] (gen/one-of [(-double-gen {:min 0.00001}) (gen/fmap inc gen/nat)]))\n(defmethod -schema-generator 'neg? [_ _] (gen/one-of [(-double-gen {:max -0.0001}) (gen/fmap (comp dec -) gen/nat)]))\n\n(defmethod -schema-generator :not [schema options] (gen/such-that (m/validator schema options) (ga/gen-for-pred any?)\n                                                                  {:max-tries 100\n                                                                   :ex-fn #(m/-exception ::not-generator-failure (assoc % :schema schema))}))\n(defmethod -schema-generator :and [schema options] (-and-gen schema options))\n(defmethod -schema-generator :or [schema options] (-or-gen schema options))\n(defmethod -schema-generator :orn [schema options] (-or-gen (m/into-schema :or (m/properties schema) (map last (m/children schema)) (m/options schema)) options))\n(defmethod -schema-generator ::m/val [schema options] (generator (first (m/children schema)) options))\n(defmethod -schema-generator :map [schema options] (-map-gen schema options))\n(defmethod -schema-generator :map-of [schema options] (-map-of-gen schema options))\n(defmethod -schema-generator :multi [schema options] (-multi-gen schema options))\n(defmethod -schema-generator :vector [schema options] (-coll-gen schema identity options))\n(defmethod -schema-generator :sequential [schema options] (-coll-gen schema identity options))\n(defmethod -schema-generator :set [schema options] (-coll-distinct-gen schema set options))\n(defmethod -schema-generator :enum [schema options] (gen-elements (m/children schema options)))\n(defmethod -schema-generator :seqable [schema options] (-seqable-gen schema options))\n(defmethod -schema-generator :every [schema options] (-seqable-gen schema options)) ;;infinite seqs?\n\n(defmethod -schema-generator :maybe [schema options]\n  (let [g (-> schema (m/children options) first (generator options) -not-unreachable)]\n    (gen-one-of (cond-> [nil-gen]\n                  g (conj g)))))\n\n(defmethod -schema-generator :tuple [schema options]\n  (let [gs (map #(generator % options) (m/children schema options))]\n    (if (not-any? -unreachable-gen? gs)\n      (apply gen/tuple gs)\n      (-never-gen options))))\n#?(:clj (defmethod -schema-generator :re [schema options] (-re-gen schema options)))\n(defmethod -schema-generator :any [_ _] (ga/gen-for-pred any?))\n(defmethod -schema-generator :some [_ _] gen/any-printable)\n(defmethod -schema-generator :nil [_ _] nil-gen)\n(defmethod -schema-generator :string [schema options] (-string-gen schema options))\n(defmethod -schema-generator :int [schema options] (gen/large-integer* (-min-max schema options)))\n(defmethod -schema-generator :double [schema options]\n  (gen/double* (merge (let [props (m/properties schema options)]\n                        {:infinite? (get props :gen/infinite? false)\n                         :NaN? (get props :gen/NaN? false)})\n                      (-> (-min-max schema options)\n                          (update :min #(some-> % double))\n                          (update :max #(some-> % double))))))\n(defmethod -schema-generator :float [schema options]\n  (let [max-float #?(:clj Float/MAX_VALUE :cljs (.-MAX_VALUE js/Number))\n        min-float (- max-float)\n        props (m/properties schema options)\n        min-max-props (-min-max schema options)\n        infinite? #?(:clj false :cljs (get props :gen/infinite? false))]\n    (->> (merge {:infinite? infinite?\n                 :NaN? (get props :gen/NaN? false)}\n                (-> min-max-props\n                    (update :min #(or (some-> % float)\n                                      #?(:clj min-float :cljs nil)))\n                    (update :max #(or (some-> % float)\n                                      #?(:clj max-float :cljs nil)))))\n         (gen/double*)\n         (gen/fmap float))))\n(defmethod -schema-generator :boolean [_ _] gen/boolean)\n(defmethod -schema-generator :keyword [_ _] gen/keyword)\n(defmethod -schema-generator :symbol [_ _] gen/symbol)\n(defmethod -schema-generator :qualified-keyword [schema _] (-qualified-keyword-gen schema))\n(defmethod -schema-generator :qualified-symbol [schema _] (-qualified-symbol-gen schema))\n(defmethod -schema-generator :uuid [_ _] gen/uuid)\n\n(defmethod -schema-generator :=> [schema options] (-=>-gen schema options))\n(defmethod -schema-generator :-> [schema options] (-=>-gen schema options))\n(defmethod -schema-generator :function [schema options] (-function-gen schema options))\n(defmethod -schema-generator 'ifn? [_ _] gen/keyword)\n(defmethod -schema-generator :ref [schema options] (-ref-gen schema options))\n(defmethod -schema-generator :schema [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator ::m/schema [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :merge [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :union [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :select-keys [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :cat [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :catn [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :alt [schema options] (-alt-gen schema options))\n(defmethod -schema-generator :altn [schema options] (-alt-gen schema options))\n\n(defmethod -schema-generator :? [schema options] (-?-gen schema options))\n(defmethod -schema-generator :* [schema options] (-*-gen schema options))\n(defmethod -schema-generator :+ [schema options] (-+-gen schema options))\n(defmethod -schema-generator :repeat [schema options] (-repeat-gen schema options))\n\n;;\n;; Creating a generator by different means, centralized under [[-create]]\n;;\n\n(defn- -create-from-return [props]\n  (when (contains? props :gen/return)\n    (gen/return (:gen/return props))))\n\n(defn- -create-from-elements [props]\n  (some-> (:gen/elements props) gen-elements))\n\n(extend-protocol Generator\n  #?(:clj Object, :cljs default)\n  (-generator [schema options]\n    (-schema-generator schema (assoc options ::original-generator-schema schema))))\n\n(defn- -create-from-gen\n  [props schema options]\n  (or (:gen/gen props)\n      (when-not (:gen/elements props)\n        (-generator schema options))))\n\n(defn- -create-from-schema [props options]\n  (some-> (:gen/schema props) (generator options)))\n\n(defn- -create-from-fmap [props schema options]\n  (when-some [fmap (:gen/fmap props)]\n    (gen/fmap (m/eval fmap (or options (m/options schema)))\n              (or (-create-from-return props)\n                  (-create-from-elements props)\n                  (-create-from-schema props options)\n                  (-create-from-gen props schema options)\n                  nil-gen))))\n\n(defn- -create [schema options]\n  (let [props (-merge (m/type-properties schema)\n                      (m/properties schema))]\n    (or (-create-from-fmap props schema options)\n        (-create-from-return props)\n        (-create-from-elements props)\n        (-create-from-schema props options)\n        (-create-from-gen props schema options)\n        (m/-fail! ::no-generator {:options options\n                                  :schema schema}))))\n\n;;\n;; public api\n;;\n\n(defn generator\n  ([?schema]\n   (generator ?schema nil))\n  ([?schema options]\n   (if (::rec-gen options)\n     ;; disable cache while calculating recursive schemas. caches don't distinguish options.\n     (-create (m/schema ?schema options) options)\n     (m/-cached (m/schema ?schema options) :generator #(-create % options)))))\n\n(defn generate\n  ([?gen-or-schema]\n   (generate ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 30} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (rose/root (gen/call-gen gen (-random seed) size)))))\n\n(defn sample\n  ([?gen-or-schema]\n   (sample ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 10} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (->> (gen/make-size-range-seq size)\n          (map #(rose/root (gen/call-gen gen %1 %2))\n               (gen/lazy-random-states (-random seed)))\n          (take size)))))\n\n;;\n;; functions\n;;\n\n(defn function-checker\n  ([?schema] (function-checker ?schema nil))\n  ([?schema {::keys [=>iterations] :or {=>iterations 100} :as options}]\n   (let [schema (m/schema ?schema options)\n         -try (fn [f] (try [(f) true] (catch #?(:clj Exception, :cljs js/Error) e [e false])))\n         check (fn [schema]\n                 (let [{:keys [input output guard]} (m/-function-info schema)\n                       input-generator (generator input options)\n                       valid-output? (m/validator output options)\n                       valid-guard? (if guard (m/validator guard options) (constantly true))\n                       validate (fn [f args] (as-> (apply f args) $ (and (valid-output? $) (valid-guard? [args $]))))]\n                   (fn [f]\n                     (let [{:keys [result shrunk]} (->> (prop/for-all* [input-generator] #(validate f %))\n                                                        (check/quick-check =>iterations))\n                           smallest (-> shrunk :smallest first)]\n                       (when-not (true? result)\n                         (let [explain-input (m/explain input smallest)\n                               [result success] (when-not explain-input (-try (fn [] (apply f smallest))))\n                               explain-output (when (and success (not explain-input)) (m/explain output result))\n                               explain-guard (when (and success guard (not explain-output)) (m/explain guard [smallest result]))]\n                           (cond-> (assoc shrunk ::m/result result)\n                             explain-input (assoc ::m/explain-input explain-input)\n                             explain-output (assoc ::m/explain-output explain-output)\n                             explain-guard (assoc ::m/explain-guard explain-guard)\n                             (ex-message result) (-> (update :result ex-message) (dissoc :result-data)))))))))]\n     (if (m/-function-info schema)\n       (check schema)\n       (if (m/-function-schema? schema)\n         (let [checkers (map #(function-checker % options) (m/-function-schema-arities schema))]\n           (fn [x] (->> checkers (keep #(% x)) (seq))))\n         (m/-fail! ::invalid-function-schema {:type (m/-type schema)}))))))\n\n(defn check\n  ([?schema f] (check ?schema f nil))\n  ([?schema f options]\n   (let [schema (m/schema ?schema options)]\n     (m/explain (m/-update-options schema #(assoc % ::m/function-checker function-checker)) f))))\n"],"x_google_ignoreList":[0]}