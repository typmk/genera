{"version":3,"sources":["observatory/cache.cljc"],"mappings":";AAiBA;;;;;;;;;;;;;;;kCAAA,kDAAAA,pFAAMI,4EAcHC;AAdH,AAAA,IAAAJ,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;WAAA,AAAAE,4CAAAF,eAAA,lEAcmBK;gBAdnB,AAAAH,4CAAAF,eAAA,vEAcwBM;AAdxB,AAeE,IAAMC,cAAY,oDAAA,nDAAK,AAACC,UAAU,CAAG,AAACC,SAASH,aAAW,SAAA,TAACG;IACrDC,aAAW,+CAAA,9CAAK,AAACF,UAAU,CAAG,AAACC,SAASJ,QAAM,SAAA,TAACI;IAC/CE,cAAY,wBAAA,vBAAK,CAAA,OAAkBJ;IACnCK,aAAW,uBAAA,tBAAK,CAAA,OAAkBF;AAHxC,AAAA,kDAAA,gFAAA,sGAAA,9HAIW,CAASN,UAAQO,2EACd,CAAS,CAAiBP,WAAQG,eAAaK,gEACrD,CAAiBR,WAAQ,CAAGG,cAAYG;;AAElD;;;iCAAA,jCAAMG,0EAEHT,QAAQE;AAFX,AAGE,IAAMC,cAAY,oDAAA,nDAAK,AAACC,UAAU,CAAG,AAACC,SAASH,aAAW,SAAA,TAACG;AAA3D,AACE,QAASL,UAAQ,GAAS,wBAAA,vBAAK,CAAA,OAAkBG;;AAMrD;;;mCAAA,nCAAMO,8EAEHC;AAFH,AAAA,kDAAA,8DAAA,oDAAA,1DAGUA;;AAGV;;;mCAAA,nCAAMC,8EAEHD,MAAME;AAFT,AAAA,kDAAA,8DAAA,iMAAA,vMAGUF,2DACD,AAACG,6CAAKJ,iCAAe,AAACK,8CAAMF,gFACvB,AAACG,cAAI,AAACD,8CAAMF;;AAE1B;;;;;;;;;;+BAAA,uCAAAI,tEAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAArB,4BAAAqB;aAAAA,TAS2DK;YAT3D,AAAAzB,4CAAAoB,eAAA,nEASWE;WATX,AAAAtB,4CAAAoB,eAAA,lEASiBG;cATjB,AAAAvB,4CAAAoB,eAAA,rEASsBI;gBATtB,AAAAxB,4CAAAoB,eAAA,4DAAA,nIAS8BhB;oBAT9B,AAAAJ,4CAAAoB,eAAA,3EASwCL;AATxC,AAWE,IAAMW,aAAW,WAAA,VAAGF;IACdG,QAAM,AAACC,eAAKF,WAAWtB;IACvBD,OAAK,AAACyB,eAAKD,MAAMZ;AAFvB,AAAA,kDAAA,6DAAA,0DAAA,2SAAA,3WAGUO,2DACDC,6DACE,4DAAA,2GAAA,vKAACM,qDAAMJ,2DAAatB,mHAAgBC,oEACtC,6CAAA,WAAA0B,xDAACd;AAAD,AAAO,wCAAAc,jCAAChB,kDAAiBC;wDANlC,sDAAA,2CAAA,sDAAA,IAAA,0DAAA,IAAA,gEAAA,IAAA,wDAAA,IAAA,yDAAA,vcAMiD,AAACE,8CAAMd;;AAW1D;;;;8BAAA,9BAAM4B,oEAGHC,UAAUC;AAHb,AAIE,IAAMC,WAAS,kBAAA,WAAAC,7BAACC;AAAD,AAAU,uDAAAD,hDAACE,iEAAOJ;GAAWD;AAA5C,AACE,OAACM,6CAAKJ,SAASD;;AAEnB;;;+BAAA,/BAAMM,sEAEHP;AAFH,AAGE,OAACQ,gBAAMR;;AAMT;;;;qCAAA,rCAAMS,kFAGHC,UAAUC;AAHb,AAIE,4FACK,AAACC,oDAAY,WAAKC,EAAEC,tIAIpB,AAACG,+CAAOC,/DACRV;AALa,AACE,oBAAM,iBAAAO,oBAAK,AAAA,kFAAOD;AAAZ,AAAA,oBAAAC;AACK,OAACC,6CAAE,AAAA,kFAAM,AAAA,kFAAOF,MAAMH;;AAD3BI;;;AAAN,AAAA,0FAEGF,EAAE,AAAA,kFAAOC;;AAFZ;;GAFf,AAAA,mFAAOJ;;AAQd;;;mCAAA,nCAAMS,8EAEHT;AAFH,AAGE,4FACK,AAACE,oDAAY,WAAKC,EAAEC,tIACpB,AAACG,+CAAOC,/DACRV;AAFa,AAAY,GAAM,2FAAA,1FAAM,AAAA,kFAAOM;AAAnB,AAAyBD;;AAAzB;;GADzB,AAAA,mFAAOH;;AAKd;;;+BAAA,/BAAMU,sEAEHV,UAAUT,UAAUoB,KAAKC;AAF5B,yEAGMZ,nBACA,6BAAA,mFAAA,+DAAA,/KAACa,qKAAgBtB,sEACP,0DAAA,+HAAA,zLAACJ,qDAAMwB,wEACaC,gIACC,6HAAA,5HAAK,iDAAA,oEAAA,rHAACtD,4CAAIqD,3kBACzC,uqBAAA,hqBAACG,guBAAkBzB,4BAAUE;;AAEnC;;;;qCAAA,rCAAMwB,kFAGHf,UAAUgB,SAASJ;AAHtB,AAIE,IAAMK,aAAW,AAACpB,6BAAW,AAAA,8FAAYG;IACnCkB,UAAQ,yDAAA,mFAAA,gEAAA,5MAACC,+CAAOnB,kJAAiBiB;IACjCG,UAAQ,AAACV,6BAAWV,UAAUiB,WAAWD,SAASJ;AAFxD,AAAA,0FAGGQ,QAAQF;;AAMb,AAAA;;;;;;;;;;;;;;;;;;2BAAA,mCAAAG,9DAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,gEAAA,mCAAAG,nGAAMD,2EAiBHW,MAAM9E,QAAQoD;AAjBjB,AAAA,IAAAiB,aAAAD;IAAAE,aAAA,AAAAC,4CAAAF,WAAA,IAAA;IAAAC,iBAAA,AAAAzE,4BAAAyE;mBAAA,AAAAxE,4CAAAwE,eAAA,wDAAA,lIAiBsCS;WAjBtC,AAAAjF,4CAAAwE,eAAA,lEAiB6CU;AAjB7C,AAkBE,IAAAC,aAA4BH;IAA5BG,iBAAA,AAAApF,4BAAAoF;aAAA,AAAAnF,4CAAAmF,eAAA,pEAAc1D;WAAd,AAAAzB,4CAAAmF,eAAA,lEAAqBhF;IAArBiF,aAC8B,AAACnF,gCAAcC,QAAQuB;IADrD2D,iBAAA,AAAArF,4BAAAqF;gBAAA,AAAApF,4CAAAoF,eAAA,vEACcE;UADd,AAAAtF,4CAAAoF,eAAA,jEACwBzC;IAClBD,YAAU,AAAC1C,4CAAIG,KAAKmF;IAF1BD,aAGgC,AAAC5C,mCAAiBC,UAAUC;gBAH5D,AAAA8B,4CAAAY,WAAA,IAAA,vEAGOpD;oBAHP,AAAAwC,4CAAAY,WAAA,IAAA,3EAGiBE;AAHjB,AAKE,oBAAIA;AAEF,IAAMC,eAAa,iBAAAC,WAAQF;IAARE,eAAA,8MAAAA,5LACER,cAAO,8CAAAQ,SAAA,wDAAA,/GAAC5D;AADV,AAAA,oBAEEqD;AAAK,qDAAAO,aAAA,3DAAC5D,gHAAYqD;;AAFpBO;;;IAGb3B,UAAQ,AAACV,6BAAWV,UAAUT,UAAUuD,aAAalC;IACrDoC,mIAAcV,nBACA,yBAAA,mFAAA,5GAACzB,gKAAgB+B,kBAAWxB,pOAC5B,6OAAA,mFAAA,sDAAA,tXAAC6B,obAAyBC,teAC1B,qfAAA,mFAAA,xkBAACD,8nBAAkB,gCAAA,yDAAA,vEAAIV,wIAAwBW;AAPnE,AAAA,kDAAA,kEAAA,yDAAA,2CAAA,qDAAA,KAAA,mJAAA,wEAAA,yEAAA,2DAAA,KAAA,5gBAQUF,+NAES,AAAA,qFAAQV,qEACJM,yEACArD,mJAEK,iBAAA4D,WAAM,AAAA,qFAAQb;IAAda,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAE,MAAA,CAAA,mEAAAF;;;;;AAM5B,eAAA,2CAAA,wDAAA,9GAAMnC,0GAAef,yDACC,iBAAAsD,mBAAIf;AAAJ,AAAA,oBAAAe;AAAAA;;AAAS,OAAC/E,cAAI,iJAAA,jJAACgF,+CAAO,AAAA,0FAAYzE;;KADxD,uNAAA,6EAAA,oEAAA,hTAEuB,gCAAA,8DAAA,5EAAIwD,gNACE3B;IAEvB6C,YAAU,AAAChD,iCAAeT;IALhCsD,aAMwB,6BAAA,wJAAA,nKAAIG,8FACD,AAAC/C,6BAAWV,UAAUyD,UAAUzC,SAASJ,wBAC1C,AAACG,mCAAiBf,UAAUgB,SAASJ;cAR/D,AAAAmB,4CAAAuB,WAAA,IAAA,rEAMOlC;cANP,AAAAW,4CAAAuB,WAAA,IAAA,rEAMepC;IAGT8B,+JAAcV,nBACA,yBAAA,mFAAA,5GAACzB,gKAAgB+B,kBAAWxB,pOAC5B,6OAAA,mFAAA,sDAAA,tXAAC6B,wbAA2BC,1eAC5B,yfAAA,mFAAA,5kBAACD,koBAAkB,gCAAA,yDAAA,vEAAIV,wIAAwBW,xzBAC/C,iBAAAQ;AAAA,AAAA,oBAAQxC;AAAQ,yDAAAwC,SAAA,mFAAA,sDAAA,pMAACT,4QAA8BC;;AAA/CQ;;;AAbpB,AAAA,kDAAA,kEAAA,yDAAA,2CAAA,qDAAA,MAAA,mJAAA,wEAAA,pYAcUV,gOAES,AAAA,qFAAQV,qEACJM,yEACA,iBAAAW,mBAAIE;AAAJ,AAAA,oBAAAF;AAAAA;;AAAc,OAAC1D,6BAAW,AAAA,8FAAYG;;KAlB7D,69BAAA,l6BAmBqB,2BAAA,AAAA,2CAAA,wbAAA,iJAAA,6QAAA,14BAAMkB,8GACM,CAAgB,AAAA,kFAAMA,YACN,CAAG,oIAAA,nIAAK,AAACtD,UAAU,CAAG,AAACC,SAAS,AAAA,kFAAOkB,WAAS,SAAA,TAAClB,yBAC9C,4IAAA,3IAAK,AAACD,UAAU,CAAG,AAACC,SAAS,AAAA,0FAAYkB,WAAS,SAAA,TAAClB,8EACzE,AAAA,mFAAOqD,mEACL,6CAAA,7CAACZ,2GAAY,AAAA,sFAAQY,iGACzB,iBAAAyC,WAAM,AAAA,qFAAQrB;IAAdqB,eAAA,EAAA,CAAAA,oBAAAP,oBAAA,AAAAO,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAN,MAAA,CAAA,mEAAAM;;;;;;;AAtElC,CAAA,mDAAA,nDAAMhC;;AAAN;AAAA,CAAA,6CAAA,WAAAK,xDAAML;AAAN,AAAA,IAAAM,WAAA,AAAAnC,gBAAAkC;IAAAA,eAAA,AAAAE,eAAAF;IAAAG,WAAA,AAAArC,gBAAAkC;IAAAA,eAAA,AAAAE,eAAAF;IAAAI,WAAA,AAAAtC,gBAAAkC;IAAAA,eAAA,AAAAE,eAAAF;AAAA,AAAA,IAAAK,qBAAA;AAAA,AAAA,OAAAA,wDAAAJ,SAAAE,SAAAC,SAAAJ;;;AAAA,AA+EA;;;;;;;;;yCAAA,zCAAM4B,0FAQH7E;AARH,AAAA,kDAAA,gbAAA,mbAAA,6aAAA,9tCASQ,2GAAA,6QAAA,tWAAM,AAAA,gFAAMA,SACV,AAACJ,6BAAW,sIAAA,uDAAA,7LAACQ,8CAAM,AAAA,gFAAMJ,2KAC3B,4GAAA,8QAAA,xWAAM,AAAA,iFAAMA,SACV,AAACJ,6BAAW,uIAAA,uDAAA,9LAACQ,8CAAM,AAAA,iFAAMJ,yKAC5B,0GAAA,4QAAA,pWAAM,AAAA,+EAAKA,SACT,AAACJ,6BAAW,qIAAA,uDAAA,5LAACQ,8CAAM,AAAA,+EAAKJ,yKAC1B,0GAAA,4QAAA,pWAAM,AAAA,+EAAKA,SACT,AAACJ,6BAAW,qIAAA,uDAAA,5LAACQ,8CAAM,AAAA,+EAAKJ;;AAEjC,AAAA;;;;;;;;;;;;qCAAA,6CAAAsC,lFAAMwC;AAAN,AAAA,IAAAvC,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAuC,wEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAApC;;;AAAA,AAAA,CAAA,0EAAA,uCAAAqC,jHAAMD,qFAWHQ,UAAU7G,QAAQoD;AAXrB,AAAA,IAAAmD,aAAAD;IAAAE,aAAA,AAAAjC,4CAAAgC,WAAA,IAAA;IAAAC,iBAAA,AAAA3G,4BAAA2G;WAAAA,PAWmEO;mBAXnE,AAAAjH,4CAAA0G,eAAA,1EAW0CzB;yBAX1C,AAAAjF,4CAAA0G,eAAA,hFAWiDM;AAXjD,AAYE,IAAME,WAAS,kBAAIF,oBAAa,AAAA,iFAAMD,WAAW,AAAA,gFAAMA;IACjDI,SAAO,iBAAAC,WAAA;IAAAA,eAAA,oXAAAA,lWACEF,UAAS,6CAAAE,SAAA,mFAAA,zIAAC9E,0LAAU4E,SAAS,sCAAA,mDAAA,vEAAIF;IADnCI,eAAA,+bAAAA,7aAEE,AAAA,+EAAKL,YAAW,6CAAAK,aAAA,mFAAA,2IAAA,xRAAC9E,8LAAU,AAAA,+EAAKyE;AAFlC,AAAA,oBAGE,AAAA,+EAAKA;AAAW,oDAAAK,aAAA,mFAAA,2IAAA,xRAAC9E,8LAAU,AAAA,+EAAKyE;;AAHlCK;;;AADb,AAME,IAAOC,YAAUF;IACVG,oBAAkBP;cADzB,VAEOQ;eAFP,XAGOC;;AAHP,AAIE,oBAAI,iBAAAvB,mBAAI,AAACwB,uBAAOJ;AAAZ,AAAA,GAAApB;AAAAA;;AAAuBuB;;;AAEzB,IAAME,gBAAc,CAAG,gEAAA,hEAACC,+CAAOC,qBAAI,4CAAA,5CAACC,qHAAoBN,YACjC,4BAAA,IAAA,dAAIC;AAD3B,AAAA,kDAAA,kFAAA,oEAAA,oFAAA,1KAEcF,8EACFC,8EACMG,gFACF,iBAAAzB,mBAAIuB;AAAJ,AAAA,oBAAAvB;AAAAA;;AAAA;;;;AAGhB,IAAA6B,aAAwB,AAACtF,gBAAM6E;YAA/B,AAAA5C,4CAAAqD,WAAA,IAAA,nEAAOxG;YAAP,AAAAmD,4CAAAqD,WAAA,IAAA,nEAAa9C;UAAb,AAAAP,4CAAAqD,WAAA,IAAA,jEAAmBE;IAAnBD,aAC6B,AAACG,8DAAOlD,MAAM9E,QAAQoD,4DAAU2D;IAD7Dc,iBAAA,AAAAhI,4BAAAgI;gBAAA,AAAA/H,4CAAA+H,eAAA,vEACc/C;aADd,AAAAhF,4CAAA+H,eAAA,pEACoBE;IACdE,gBAAc,AAACtG,8CAAMyF,kBAAkBU,IAAIhD;IAC3CoD,cAAY,AAAC9F,6CAAKiF,QAAQU;AAHhC,AAIE,oBAAI,AAAA,mFAAOA;AAET,eAAA;eAAUE;eAAcC;eAAY9G;;;;;;;AAEpC,eAAO,AAAC+G,eAAKhB;eAAWc;eAAcC;eAAtC;;;;;;;;;;;;AAxCZ,CAAA,6DAAA,7DAAM7B;;AAAN;AAAA,CAAA,uDAAA,WAAAI,lEAAMJ;AAAN,AAAA,IAAAK,WAAA,AAAApE,gBAAAmE;IAAAA,eAAA,AAAA/B,eAAA+B;IAAAE,WAAA,AAAArE,gBAAAmE;IAAAA,eAAA,AAAA/B,eAAA+B;IAAAG,WAAA,AAAAtE,gBAAAmE;IAAAA,eAAA,AAAA/B,eAAA+B;AAAA,AAAA,IAAA5B,qBAAA;AAAA,AAAA,OAAAA,wDAAA6B,SAAAC,SAAAC,SAAAH;;;AAAA,AA8CA;;;;;;;oCAAA,pCAAM2B,gFAMHvB,UAAUwB;AANb,AAOE,OAACC,mDACA,WAAAC,SAAAC;AAAA,AAAA,IAAAC,aAAAF;IAAAE,iBAAA,AAAA5I,4BAAA4I;oBAAA,AAAA3I,4CAAA2I,eAAA,3EAAa5B;IAAb6B,aAAAF;IAAAE,iBAAA,AAAA7I,4BAAA6I;kBAAAA,dAAwDC;cAAxD,AAAA7I,4CAAA4I,eAAA,rEAAiC1I;gBAAjC,AAAAF,4CAAA4I,eAAA,vEAAyCtF;AAAzC,AACE,IAAM2E,SAAO,AAACa,wEAAiB/B,cAAU7G,QAAQoD,4DAAUuF;AAA3D,AACE,4DAAA,rDAAChH,8CAAMoG,gEAAeY;GAH3B,2CAAA,0EAAA,4DAAA,iCAAA,sEAAA,IAAA,kEAAA,nPAIa9B,gQACZwB;;AAEH;;;qCAAA,rCAAMQ,kFAEHC;AAFH,AAGE,IAAMzB,UAAQ,AAACc,eAAKW;AAApB,AAAA,kDAAA,mGAAA,zBACmB,AAACC,gBAAM1B,oEACd,AAAC0B,gBAAM,+CAAA,WAAAC,1DAACjG;AAAD,AAAS,oDAAA,7CAACD,8FAAM,AAAA,gGAAAkG;aAFnC,VAEqD3B,qEACzC,AAAC0B,gBAAM,+CAAA,WAAAE,1DAAClG;AAAD,AAAS,oDAAA,7CAACD,8FAAM,AAAA,gGAAAmG;aAHnC,VAGqD5B,sEACzC,AAAC0B,gBAAM,+CAAA,WAAAG,1DAACnG;AAAD,AAAS,oDAAA,7CAACD,8FAAM,AAAA,gGAAAoG;aAJnC,VAIqD7B,8EACpC,AAAC0B,gBAAM,+CAAA,WAAAI,1DAACpG;AAAD,AAAS,oDAAA,7CAACD,iGAAO,AAAA,gGAAAqG;aALzC,sQAAA,hRAK2D9B,gFAC1C,gEAAA,hEAACI,+CAAOC,qBAAI,4CAAA,5CAACC,kHAAmBN,4EACjC,CAAG,gEAAA,hEAACI,+CAAOC,qBAAM,4CAAA,5CAACC,kHAAmBN,YAClC,iBAAA+B,kBAAA;IAAAC,kBAAO,AAACN,gBAAM1B;AAAd,AAAA,SAAA+B,kBAAAC,mBAAAD,kBAAAC;;;AAMrB","names":["p__12153","map__12154","cljs.core/--destructure-map","cljs.core.get","observatory.cache/address-parts","address","sets","line-size","offset-bits","Math/ceil","Math/log","index-bits","offset-mask","index-mask","observatory.cache/line-address","observatory.cache/make-empty-way","index","observatory.cache/make-empty-set","associativity","cljs.core.mapv","cljs.core.range","cljs.core/vec","p__12158","map__12159","observatory.cache/make-cache","level","type","size-kb","config","size-bytes","lines","cljs.core/quot","cljs.core.assoc","p1__12157#","observatory.cache/touch-way","lru-order","way-index","filtered","p1__12161#","cljs.core/filterv","cljs.core.not_EQ_","cljs.core.conj","observatory.cache/lru-victim","cljs.core/first","observatory.cache/find-line-in-set","cache-set","tag","cljs.core.map_indexed","i","way","and__5000__auto__","cljs.core._EQ_","cljs.core.filter","cljs.core/some?","observatory.cache/find-empty-way","observatory.cache/update-way","line","timestamp","cljs.core/assoc-in","cljs.core.update","observatory.cache/evict-and-insert","new-line","victim-way","evicted","cljs.core.get_in","new-set","var_args","args__5732__auto__","len__5726__auto__","i__5727__auto__","argseq__5733__auto__","cljs.core/IndexedSeq","observatory.cache/access","p__12168","vec__12169","map__12172","cljs.core.nth","seq12162","G__12163","cljs.core/next","G__12164","G__12165","self__5711__auto__","cache","write?","data","map__12173","map__12174","vec__12175","set-index","existing-line","updated-line","G__12178","new-cache","cljs.core.update_in","cljs.core/inc","G__12181","cljs.core/Keyword","js/Error","vec__12198","or__5002__auto__","cljs.core.repeat","empty-way","G__12201","G__12209","observatory.cache/make-cache-hierarchy","observatory.cache/hierarchy-access","p__12226","vec__12227","map__12230","seq12217","G__12218","G__12219","G__12220","hierarchy","instruction?","opts","l1-cache","levels","G__12231","remaining","current-hierarchy","results","found-at","cljs.core/empty?","total-latency","cljs.core.reduce","cljs.core/+","cljs.core.map","vec__12240","map__12243","key","result","observatory.cache.access","new-hierarchy","new-results","cljs.core/rest","observatory.cache/replay-accesses","accesses","cljs.core.reductions","p__12250","p__12251","map__12252","map__12253","access-info","observatory.cache.hierarchy_access","observatory.cache/summarize-replay","replay-results","cljs.core/count","p1__12254#","p1__12255#","p1__12256#","p1__12257#","x__5087__auto__","y__5088__auto__"],"sourcesContent":["(ns observatory.cache\n  \"Pure functional cache simulator.\n\n   Models set-associative caches with LRU replacement.\n   All functions are pure - take state, return new state.\n\n   Design:\n   - Cache state is a plain map\n   - Access returns [new-state result]\n   - Can step through access-by-access\n   - Can replay any sequence of accesses\"\n  (:require [observatory.schema :as schema]))\n\n;; =============================================================================\n;; Address Decomposition\n;; =============================================================================\n\n(defn address-parts\n  \"Decompose address into tag, set index, and offset.\n\n   For a cache with S sets and B byte lines:\n   - Offset bits: log2(B) - identifies byte within line\n   - Index bits: log2(S) - identifies which set\n   - Tag bits: remaining high bits - identifies which line\n\n   Example for 32KB, 8-way, 64B lines:\n   - 32KB / 8 ways = 4KB per way\n   - 4KB / 64B = 64 sets\n   - Offset: 6 bits (64 bytes)\n   - Index: 6 bits (64 sets)\n   - Tag: 52 bits\"\n  [address {:keys [sets line-size]}]\n  (let [offset-bits (int (Math/ceil (/ (Math/log line-size) (Math/log 2))))\n        index-bits (int (Math/ceil (/ (Math/log sets) (Math/log 2))))\n        offset-mask (dec (bit-shift-left 1 offset-bits))\n        index-mask (dec (bit-shift-left 1 index-bits))]\n    {:offset (bit-and address offset-mask)\n     :set-index (bit-and (bit-shift-right address offset-bits) index-mask)\n     :tag (bit-shift-right address (+ offset-bits index-bits))}))\n\n(defn line-address\n  \"Get the cache-line-aligned address (clear offset bits)\"\n  [address line-size]\n  (let [offset-bits (int (Math/ceil (/ (Math/log line-size) (Math/log 2))))]\n    (bit-and address (bit-not (dec (bit-shift-left 1 offset-bits))))))\n\n;; =============================================================================\n;; Cache Construction\n;; =============================================================================\n\n(defn make-empty-way\n  \"Create an empty cache way\"\n  [index]\n  {:index index\n   :line nil})\n\n(defn make-empty-set\n  \"Create an empty cache set with N ways\"\n  [index associativity]\n  {:index index\n   :ways (mapv make-empty-way (range associativity))\n   :lru-order (vec (range associativity))})  ; All ways in LRU order\n\n(defn make-cache\n  \"Create a new empty cache from config.\n\n   Config should have:\n   - :level (:l1, :l2, :l3)\n   - :type (:data, :instruction, :unified)\n   - :size-kb\n   - :line-size (default 64)\n   - :associativity\"\n  [{:keys [level type size-kb line-size associativity] :as config\n    :or {line-size 64}}]\n  (let [size-bytes (* size-kb 1024)\n        lines (quot size-bytes line-size)\n        sets (quot lines associativity)]\n    {:level level\n     :type type\n     :config (assoc config :sets sets :line-size line-size)\n     :sets (mapv #(make-empty-set % associativity) (range sets))\n     :stats {:hits 0\n             :misses 0\n             :evictions 0\n             :reads 0\n             :writes 0}}))\n\n;; =============================================================================\n;; LRU Management (Pure Functions)\n;; =============================================================================\n\n(defn touch-way\n  \"Move a way to MRU position (end of LRU order).\n   Returns updated lru-order vector.\"\n  [lru-order way-index]\n  (let [filtered (filterv #(not= % way-index) lru-order)]\n    (conj filtered way-index)))\n\n(defn lru-victim\n  \"Get the LRU way index (first in order)\"\n  [lru-order]\n  (first lru-order))\n\n;; =============================================================================\n;; Cache Operations (Pure Functions)\n;; =============================================================================\n\n(defn find-line-in-set\n  \"Find a cache line by tag in a set.\n   Returns [way-index line] or nil.\"\n  [cache-set tag]\n  (->> (:ways cache-set)\n       (map-indexed (fn [i way]\n                      (when (and (:line way)\n                                 (= (:tag (:line way)) tag))\n                        [i (:line way)])))\n       (filter some?)\n       first))\n\n(defn find-empty-way\n  \"Find an empty way in a set. Returns way-index or nil.\"\n  [cache-set]\n  (->> (:ways cache-set)\n       (map-indexed (fn [i way] (when (nil? (:line way)) i)))\n       (filter some?)\n       first))\n\n(defn update-way\n  \"Update a specific way in a set with a new line\"\n  [cache-set way-index line timestamp]\n  (-> cache-set\n      (assoc-in [:ways way-index :line]\n                (assoc line\n                       :last-access timestamp\n                       :access-count (inc (get line :access-count 0))))\n      (update :lru-order touch-way way-index)))\n\n(defn evict-and-insert\n  \"Evict LRU line and insert new one.\n   Returns [new-set evicted-line]\"\n  [cache-set new-line timestamp]\n  (let [victim-way (lru-victim (:lru-order cache-set))\n        evicted (get-in cache-set [:ways victim-way :line])\n        new-set (update-way cache-set victim-way new-line timestamp)]\n    [new-set evicted]))\n\n;; =============================================================================\n;; Main Access Function\n;; =============================================================================\n\n(defn access\n  \"Perform a cache access. Pure function.\n\n   Arguments:\n   - cache: current cache state\n   - address: memory address being accessed\n   - timestamp: current timestamp (for LRU tracking)\n   - opts: {:write? false, :data nil}\n\n   Returns:\n   {:cache new-cache-state\n    :result {:hit? bool\n             :level :l1/:l2/:l3\n             :set-index int\n             :way-index int (or nil for miss)\n             :evicted nil or {:address :data :dirty?}\n             :latency-cycles int}}\"\n  [cache address timestamp & [{:keys [write? data] :or {write? false}}]]\n  (let [{:keys [config sets]} cache\n        {:keys [set-index tag]} (address-parts address config)\n        cache-set (get sets set-index)\n        [way-index existing-line] (find-line-in-set cache-set tag)]\n\n    (if existing-line\n      ;; === HIT ===\n      (let [updated-line (cond-> existing-line\n                           write? (assoc :state :modified)\n                           data (assoc :data data))\n            new-set (update-way cache-set way-index updated-line timestamp)\n            new-cache (-> cache\n                          (assoc-in [:sets set-index] new-set)\n                          (update-in [:stats :hits] inc)\n                          (update-in [:stats (if write? :writes :reads)] inc))]\n        {:cache new-cache\n         :result {:hit? true\n                  :level (:level cache)\n                  :set-index set-index\n                  :way-index way-index\n                  :evicted nil\n                  :latency-cycles (case (:level cache)\n                                    :l1 4\n                                    :l2 12\n                                    :l3 36)}})\n\n      ;; === MISS ===\n      (let [new-line {:tag tag\n                      :data (or data (vec (repeat (:line-size config) 0)))\n                      :state (if write? :modified :exclusive)\n                      :last-access timestamp\n                      :access-count 1}\n            empty-way (find-empty-way cache-set)\n            [new-set evicted] (if empty-way\n                                [(update-way cache-set empty-way new-line timestamp) nil]\n                                (evict-and-insert cache-set new-line timestamp))\n            new-cache (-> cache\n                          (assoc-in [:sets set-index] new-set)\n                          (update-in [:stats :misses] inc)\n                          (update-in [:stats (if write? :writes :reads)] inc)\n                          (cond-> evicted (update-in [:stats :evictions] inc)))]\n        {:cache new-cache\n         :result {:hit? false\n                  :level (:level cache)\n                  :set-index set-index\n                  :way-index (or empty-way (lru-victim (:lru-order cache-set)))\n                  :evicted (when evicted\n                             {:address (bit-shift-left (:tag evicted)\n                                                       (+ (int (Math/ceil (/ (Math/log (:sets config)) (Math/log 2))))\n                                                          (int (Math/ceil (/ (Math/log (:line-size config)) (Math/log 2))))))\n                              :data (:data evicted)\n                              :dirty? (= :modified (:state evicted))})\n                  :latency-cycles (case (:level cache)\n                                    :l1 4\n                                    :l2 12\n                                    :l3 36)}}))))\n\n;; =============================================================================\n;; Cache Hierarchy\n;; =============================================================================\n\n(defn make-cache-hierarchy\n  \"Create a multi-level cache hierarchy.\n\n   Example config:\n   {:l1d {:size-kb 32 :associativity 8 :type :data}\n    :l1i {:size-kb 32 :associativity 8 :type :instruction}\n    :l2  {:size-kb 256 :associativity 4 :type :unified}\n    :l3  {:size-kb 8192 :associativity 16 :type :unified}}\"\n  [config]\n  {:l1d (when (:l1d config)\n          (make-cache (assoc (:l1d config) :level :l1)))\n   :l1i (when (:l1i config)\n          (make-cache (assoc (:l1i config) :level :l1)))\n   :l2 (when (:l2 config)\n         (make-cache (assoc (:l2 config) :level :l2)))\n   :l3 (when (:l3 config)\n         (make-cache (assoc (:l3 config) :level :l3)))})\n\n(defn hierarchy-access\n  \"Access through cache hierarchy.\n\n   Checks L1 -> L2 -> L3 -> RAM.\n   On miss, fills all levels.\n\n   Returns:\n   {:hierarchy new-hierarchy\n    :results [{:level :l1 :hit? true/false ...} ...]\n    :total-latency int\n    :final-level :l1/:l2/:l3/:ram}\"\n  [hierarchy address timestamp & [{:keys [write? instruction?] :as opts}]]\n  (let [l1-cache (if instruction? (:l1i hierarchy) (:l1d hierarchy))\n        levels (cond-> []\n                 l1-cache (conj [:l1 l1-cache (if instruction? :l1i :l1d)])\n                 (:l2 hierarchy) (conj [:l2 (:l2 hierarchy) :l2])\n                 (:l3 hierarchy) (conj [:l3 (:l3 hierarchy) :l3]))]\n\n    (loop [remaining levels\n           current-hierarchy hierarchy\n           results []\n           found-at nil]\n      (if (or (empty? remaining) found-at)\n        ;; Done - either found or checked all levels\n        (let [total-latency (+ (reduce + 0 (map :latency-cycles results))\n                               (if found-at 0 100))] ; 100 cycles for RAM\n          {:hierarchy current-hierarchy\n           :results results\n           :total-latency total-latency\n           :final-level (or found-at :ram)})\n\n        ;; Check next level\n        (let [[level cache key] (first remaining)\n              {:keys [cache result]} (access cache address timestamp opts)\n              new-hierarchy (assoc current-hierarchy key cache)\n              new-results (conj results result)]\n          (if (:hit? result)\n            ;; Hit - we're done\n            (recur [] new-hierarchy new-results level)\n            ;; Miss - continue to next level\n            (recur (rest remaining) new-hierarchy new-results nil)))))))\n\n;; =============================================================================\n;; Trace Replay\n;; =============================================================================\n\n(defn replay-accesses\n  \"Replay a sequence of memory accesses through cache hierarchy.\n\n   accesses: [{:address 0x... :timestamp 0 :write? false} ...]\n\n   Returns sequence of access results with running state.\"\n  [hierarchy accesses]\n  (reductions\n   (fn [{:keys [hierarchy]} {:keys [address timestamp] :as access-info}]\n     (let [result (hierarchy-access hierarchy address timestamp access-info)]\n       (assoc result :access access-info)))\n   {:hierarchy hierarchy :results [] :total-latency 0 :final-level nil}\n   accesses))\n\n(defn summarize-replay\n  \"Summarize results of replay-accesses\"\n  [replay-results]\n  (let [results (rest replay-results)] ; Skip initial state\n    {:total-accesses (count results)\n     :l1-hits (count (filter #(= :l1 (:final-level %)) results))\n     :l2-hits (count (filter #(= :l2 (:final-level %)) results))\n     :l3-hits (count (filter #(= :l3 (:final-level %)) results))\n     :ram-accesses (count (filter #(= :ram (:final-level %)) results))\n     :total-cycles (reduce + 0 (map :total-latency results))\n     :avg-latency (/ (reduce + 0.0 (map :total-latency results))\n                     (max 1 (count results)))}))\n\n;; =============================================================================\n;; REPL Exploration\n;; =============================================================================\n\n(comment\n  ;; Create a simple L1 cache\n  (def l1 (make-cache {:level :l1\n                       :type :data\n                       :size-kb 32\n                       :associativity 8}))\n\n  ;; Check structure\n  (:config l1)\n  (count (:sets l1))  ; Should be 64 sets for 32KB/8-way\n\n  ;; Do an access\n  (def result1 (access l1 0x7ff612340000 0))\n  (:result result1)  ; Should be miss\n\n  ;; Same address again\n  (def result2 (access (:cache result1) 0x7ff612340000 1))\n  (:result result2)  ; Should be hit!\n\n  ;; Different address, same set (test LRU)\n  (def addr-parts (address-parts 0x7ff612340000 (:config l1)))\n\n  ;; Create full hierarchy\n  (def hier (make-cache-hierarchy\n             {:l1d {:size-kb 32 :associativity 8 :type :data}\n              :l2 {:size-kb 256 :associativity 4 :type :unified}\n              :l3 {:size-kb 8192 :associativity 16 :type :unified}}))\n\n  ;; Access through hierarchy\n  (def h-result (hierarchy-access hier 0x7ff612340000 0))\n  (:final-level h-result)  ; :ram (first access)\n  (:total-latency h-result)\n\n  ;; Replay a sequence\n  (def accesses [{:address 0x1000 :timestamp 0}\n                 {:address 0x2000 :timestamp 1}\n                 {:address 0x1000 :timestamp 2}  ; Should hit L1\n                 {:address 0x1040 :timestamp 3}  ; Same line as 0x1000!\n                 {:address 0x3000 :timestamp 4}])\n\n  (def replay (replay-accesses hier accesses))\n  (summarize-replay replay)\n  )\n"]}