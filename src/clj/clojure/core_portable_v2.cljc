;; =============================================================================
;; PORTABLE CLOJURE CORE - Auto-generated via AST transformation
;; =============================================================================

(ns ^{:doc "The core Clojure language.", :author "Rich Hickey"} clojure.core)

(def unquote)

(def unquote-splicing)

(def ^{:arglists (quote ([& items])), :doc "Creates a new list containing the items.", :added "1.0"} list t/list-creator)

(def ^{:arglists (quote ([x seq])), :doc "Returns a new seq where x is the first element and seq is\r\n    the rest.", :added "1.0", :static true} cons (fn* ^{:static true} cons [x seq] (t/cons x seq)))

(def ^{:macro true, :added "1.0"} let (fn* let [&form &env & decl] (cons (quote let*) decl)))

(def ^{:macro true, :added "1.0"} loop (fn* loop [&form &env & decl] (cons (quote loop*) decl)))

(def ^{:macro true, :added "1.0"} fn (fn* fn [&form &env & decl] (.withMeta (cons (quote fn*) decl) (.meta &form))))

(def ^{:arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\r\n    argument. If coll is nil, returns nil.", :added "1.0", :static true} first (fn ^{:static true} first [coll] (clojure.core/let [s__206__auto__ (p/-seq coll)] (clojure.core/when s__206__auto__ (p/-first s__206__auto__)))))

(def ^{:arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\r\n  argument.  If there are no more items, returns nil.", :added "1.0", :static true} next (fn ^{:static true} next [x] (p/-next x)))

(def ^{:arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\r\n  argument.", :added "1.0", :static true} rest (fn ^{:static true} rest [x] (p/-rest x)))

(def ^{:arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\r\n    'added'. (conj nil item) returns (item).\r\n    (conj coll) returns coll. (conj) returns [].\r\n    The 'addition' may happen at different 'places' depending\r\n    on the concrete type.", :added "1.0", :static true} conj (fn ^{:static true} conj ([] []) ([coll] coll) ([coll x] (p/-conj coll x)) ([coll x & xs] (if xs (recur (p/-conj coll x) (first xs) (next xs)) (p/-conj coll x)))))

(def ^{:doc "Same as (first (next x))", :arglists (quote ([x])), :added "1.0", :static true} second (fn ^{:static true} second [x] (first (next x))))

(def ^{:doc "Same as (first (first x))", :arglists (quote ([x])), :added "1.0", :static true} ffirst (fn ^{:static true} ffirst [x] (first (first x))))

(def ^{:doc "Same as (next (first x))", :arglists (quote ([x])), :added "1.0", :static true} nfirst (fn ^{:static true} nfirst [x] (next (first x))))

(def ^{:doc "Same as (first (next x))", :arglists (quote ([x])), :added "1.0", :static true} fnext (fn ^{:static true} fnext [x] (first (next x))))

(def ^{:doc "Same as (next (next x))", :arglists (quote ([x])), :added "1.0", :static true} nnext (fn ^{:static true} nnext [x] (next (next x))))

(def ^{:arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\r\n    empty, returns nil.  (seq nil) returns nil. seq also works on\r\n    Strings, native Java arrays (of reference types) and any objects\r\n    that implement Iterable. Note that seqs cache values, thus seq\r\n    should not be used on any Iterable whose iterator repeatedly\r\n    returns the same mutable object.", :added "1.0", :static true} seq (fn ^{:static true} seq [coll] (p/-seq coll)))

(def ^{:arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the class\r\n    c. Returns true or false", :added "1.0"} instance? (fn instance? [c x] (. c (isInstance x))))

(def ^{:arglists (quote ([x])), :doc "Return true if x implements ISeq", :added "1.0", :static true} seq? (fn ^{:static true} seq? [x] ([x] ^{:line 225, :column 45} (satisfies? p/ISeq x) x)))

(def ^{:arglists (quote ([x])), :doc "Return true if x is a Character", :added "1.0", :static true} char? (fn ^{:static true} char? [x] ([x] ^{:line 261, :column 45} (t/char? x) x)))

(def ^{:arglists (quote ([x])), :doc "Return true if x is a String", :added "1.0", :static true} string? (fn ^{:static true} string? [x] ([x] ^{:line 260, :column 45} (t/string? x) x)))

(def ^{:arglists (quote ([x])), :doc "Return true if x implements IPersistentMap", :added "1.0", :static true} map? (fn ^{:static true} map? [x] ([x] ^{:line 226, :column 45} (satisfies? p/IMap x) x)))

(def ^{:arglists (quote ([x])), :doc "Return true if x implements IPersistentVector", :added "1.0", :static true} vector? (fn ^{:static true} vector? [x] ([x] ^{:line 227, :column 45} (satisfies? p/IIndexed x) x)))

(def ^{:arglists (quote ([map key val] [map key val & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\r\n    same (hashed/sorted) type, that contains the mapping of key(s) to\r\n    val(s). When applied to a vector, returns a new vector that\r\n    contains val at index. Note - index must be <= (count vector).", :added "1.0", :static true} assoc (fn ^{:static true} assoc ([map key val] (p/-assoc map key val)) ([map key val & kvs] (let [ret (p/-assoc map key val)] (if kvs (if (next kvs) (recur ret (first kvs) (second kvs) (nnext kvs)) (throw (clojure.core/ex-info "assoc expects even number of arguments after map/vector, found odd number" {}))) ret)))))

(def ^{:arglists (quote ([obj])), :doc "Returns the metadata of obj, returns nil if there is no metadata.", :added "1.0", :static true} meta (fn ^{:static true} meta [x] (if ([x] ^{:line 232, :column 45} (satisfies? p/IMeta x) x) (. x (meta)))))

(def ^{:arglists (quote ([obj m])), :doc "Returns an object of the same type and value as obj, with\r\n    map m as its metadata.", :added "1.0", :static true} with-meta (fn ^{:static true} with-meta [x m] (. x (withMeta m))))

(def ^{:private true, :dynamic true} assert-valid-fdecl (fn [fdecl]))

(def ^{:private true} sigs (fn [fdecl] (assert-valid-fdecl fdecl) (let [asig (fn [fdecl] (let [arglist (first fdecl) arglist (if (= (quote &form) (first arglist)) (t/subvec arglist 2 (p/-count arglist)) arglist) body (next fdecl)] (if (map? (first body)) (if (next body) (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body))) arglist) arglist))) resolve-tag (fn [argvec] (let [m (meta argvec) tag (:tag m)] (if ([x] ^{:line 244, :column 45} (t/symbol? x) tag) (if (p/-equiv (.indexOf (.getName tag) ".") -1) (if (= nil (t/maybe-special-tag tag)) (let [c (t/maybe-class tag false)] (if c (with-meta argvec (assoc m :tag (t/symbol (.getName c)))) argvec)) argvec) argvec) argvec)))] (if (seq? (first fdecl)) (loop [ret [] fdecls fdecl] (if fdecls (recur (conj ret (resolve-tag (asig (first fdecls)))) (next fdecls)) (seq ret))) (list (resolve-tag (asig fdecl)))))))

(def ^{:arglists (quote ([coll])), :doc "Return the last item in coll, in linear time", :added "1.0", :static true} last (fn ^{:static true} last [s] (if (next s) (recur (next s)) (first s))))

(def ^{:arglists (quote ([coll])), :doc "Return a seq of all but the last item in coll, in linear time", :added "1.0", :static true} butlast (fn ^{:static true} butlast [s] (loop [ret [] s s] (if (next s) (recur (conj ret (first s)) (next s)) (seq ret)))))

(def ^{:doc "Same as (def name (fn [params* ] exprs*)) or (def\r\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\r\n    to the var metadata. prepost-map defines a map with optional keys\r\n    :pre and :post that contain collections of pre or post conditions.", :arglists (quote ([name doc-string? attr-map? [params*] prepost-map? body] [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])), :added "1.0"} defn (fn defn [&form &env name & fdecl] (if ([x] ^{:line 244, :column 45} (t/symbol? x) name) nil (throw (clojure.core/ex-info "First argument to defn must be a symbol" {}))) (let [m (if (string? (first fdecl)) {:doc (first fdecl)} {}) fdecl (if (string? (first fdecl)) (next fdecl) fdecl) m (if (map? (first fdecl)) (conj m (first fdecl)) m) fdecl (if (map? (first fdecl)) (next fdecl) fdecl) fdecl (if (vector? (first fdecl)) (list fdecl) fdecl) m (if (map? (last fdecl)) (conj m (last fdecl)) m) fdecl (if (map? (last fdecl)) (butlast fdecl) fdecl) m (conj {:arglists (list (quote quote) (sigs fdecl))} m) m (let [inline (:inline m) ifn (first inline) iname (second inline)] (if (if (p/-equiv (quote fn) ifn) (if ([x] ^{:line 244, :column 45} (t/symbol? x) iname) false true)) (assoc m :inline (cons ifn (cons (t/symbol (.concat (.getName name) "__inliner")) (next inline)))) m)) m (conj (if (meta name) (meta name) {}) m)] (list (quote def) (with-meta name m) (with-meta (cons (quote clojure.core/fn) fdecl) {:rettag (:tag m)})))))

(. (var defn) (setMacro))

(defn to-array "Returns an array of Objects containing the contents of coll, which\r\n  can be any Collection.  Maps to java.util.Collection.toArray()." {:added "1.0", :static true} [coll] (h/-to-array (h/host) coll))

(defn cast "Throws a ClassCastException if x is not a c, else returns x." {:added "1.0", :static true} [c x] (. c (cast x)))

(defn vector "Creates a new vector containing the args." {:added "1.0", :static true} ([] []) ([a] [a]) ([a b] [a b]) ([a b c] [a b c]) ([a b c d] [a b c d]) ([a b c d e] [a b c d e]) ([a b c d e f] [a b c d e f]) ([a b c d e f & args] (t/vec (cons a (cons b (cons c (cons d (cons e (cons f args)))))))))

(defn vec "Creates a new vector containing the contents of coll. Java arrays\r\n  will be aliased and should not be modified." {:added "1.0", :static true} ([coll] (if (vector? coll) (if ([x] ^{:line 233, :column 45} (satisfies? p/IWithMeta x) coll) (with-meta coll nil) (t/vec coll)) (t/vec coll))))

(defn hash-map "keyval => key val\r\n  Returns a new hash map with supplied mappings.  If any keys are\r\n  equal, they are handled as if by repeated uses of assoc." {:added "1.0", :static true} ([] {}) ([& keyvals] (t/hash-map keyvals)))

(defn hash-set "Returns a new hash set with supplied keys.  Any equal keys are\r\n  handled as if by repeated uses of conj." {:added "1.0", :static true} ([] #{}) ([& keys] (t/hash-set keys)))

(defn sorted-map "keyval => key val\r\n  Returns a new sorted map with supplied mappings.  If any keys are\r\n  equal, they are handled as if by repeated uses of assoc." {:added "1.0", :static true} ([& keyvals] (t/sorted-map keyvals)))

(defn sorted-map-by "keyval => key val\r\n  Returns a new sorted map with supplied mappings, using the supplied\r\n  comparator.  If any keys are equal, they are handled as if by\r\n  repeated uses of assoc." {:added "1.0", :static true} ([comparator & keyvals] (t/sorted-map comparator keyvals)))

(defn sorted-set "Returns a new sorted set with supplied keys.  Any equal keys are\r\n  handled as if by repeated uses of conj." {:added "1.0", :static true} ([& keys] (t/sorted-set keys)))

(defn sorted-set-by "Returns a new sorted set with supplied keys, using the supplied\r\n  comparator.  Any equal keys are handled as if by repeated uses of\r\n  conj." {:added "1.1", :static true} ([comparator & keys] (t/sorted-set comparator keys)))

(defn nil? "Returns true if x is nil, false otherwise." {:added "1.0", :static true} [x] (^{:line 78, :column 35} (fn [a b] ^{:line 78, :column 45} (h/-identical? ^{:line 78, :column 60} (h/host) a b)) x nil))

(def ^{:doc "Like defn, but the resulting function name is declared as a\r\n  macro and will be used as a macro by the compiler when it is\r\n  called.", :arglists (quote ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ([params*] body) + attr-map?])), :added "1.0"} defmacro (fn [&form &env name & args] (let [prefix (loop [p (list name) args args] (let [f (first args)] (if (string? f) (recur (cons f p) (next args)) (if (map? f) (recur (cons f p) (next args)) p)))) fdecl (loop [fd args] (if (string? (first fd)) (recur (next fd)) (if (map? (first fd)) (recur (next fd)) fd))) fdecl (if (vector? (first fdecl)) (list fdecl) fdecl) add-implicit-args (fn [fd] (let [args (first fd)] (cons (vec (cons (quote &form) (cons (quote &env) args))) (next fd)))) add-args (fn [acc ds] (if (nil? ds) acc (let [d (first ds)] (if (map? d) (conj acc d) (recur (conj acc (add-implicit-args d)) (next ds)))))) fdecl (seq (add-args [] fdecl)) decl (loop [p prefix d fdecl] (if p (recur (next p) (cons (first p) d)) d))] (list (quote do) (cons (quote clojure.core/defn) decl) (list (quote .) (list (quote var) name) (quote (setMacro))) (list (quote var) name)))))

(. (var defmacro) (setMacro))

(defmacro when "Evaluates test. If logical true, evaluates body in an implicit do." {:added "1.0"} [test & body] (list (quote if) test (cons (quote do) body)))

(defmacro when-not "Evaluates test. If logical false, evaluates body in an implicit do." {:added "1.0"} [test & body] (list (quote if) test nil (cons (quote do) body)))

(defn false? "Returns true if x is the value false, false otherwise." {:added "1.0", :static true} [x] (^{:line 78, :column 35} (fn [a b] ^{:line 78, :column 45} (h/-identical? ^{:line 78, :column 60} (h/host) a b)) x false))

(defn true? "Returns true if x is the value true, false otherwise." {:added "1.0", :static true} [x] (^{:line 78, :column 35} (fn [a b] ^{:line 78, :column 45} (h/-identical? ^{:line 78, :column 60} (h/host) a b)) x true))

(defn boolean? "Return true if x is a Boolean" {:added "1.9"} [x] ([x] ^{:line 263, :column 45} (or ^{:line 263, :column 49} (true? x) ^{:line 263, :column 59} (false? x)) x))

(defn not "Returns true if x is logical false, false otherwise." {:added "1.0", :static true} [x] (if x false true))

(defn some? "Returns true if x is not nil, false otherwise." {:added "1.6", :static true} [x] (not (nil? x)))

(defn any? "Returns true given any argument." {:added "1.9"} [x] true)

(defn str "With no args, returns the empty string. With one arg x, returns\r\n  x.toString().  (str nil) returns the empty string. With more than\r\n  one arg, returns the concatenation of the str values of the args." {:added "1.0", :static true} ([] "") ([x] (if (nil? x) "" (. x (toString)))) ([x & ys] ((fn [sb more] (if more (recur (. sb (append (str (first more)))) (next more)) (str sb))) (new StringBuilder (str x)) ys)))

(defn symbol? "Return true if x is a Symbol" {:added "1.0", :static true} [x] ([x] ^{:line 244, :column 45} (t/symbol? x) x))

(defn keyword? "Return true if x is a Keyword" {:added "1.0", :static true} [x] ([x] ^{:line 245, :column 45} (t/keyword? x) x))

(defmacro cond "Takes a set of test/expr pairs. It evaluates each test one at a\r\n  time.  If a test returns logical true, cond evaluates and returns\r\n  the value of the corresponding expr and doesn't evaluate any of the\r\n  other tests or exprs. (cond) returns nil." {:added "1.0"} [& clauses] (when clauses (list (quote if) (first clauses) (if (next clauses) (second clauses) (throw (clojure.core/ex-info "cond requires an even number of forms" {}))) (cons (quote clojure.core/cond) (next (next clauses))))))

(defn symbol "Returns a Symbol with the given namespace and name. Arity-1 works\r\n  on strings, keywords, and vars." {:added "1.0", :static true} ([name] (cond (symbol? name) name ([x] ^{:line 260, :column 45} (t/string? x) name) (t/symbol name) ([x] ^{:line 247, :column 45} (t/var? x) name) (.toSymbol name) ([x] ^{:line 245, :column 45} (t/keyword? x) name) (.sym name) :else (throw (clojure.core/ex-info "no conversion to symbol" {})))) ([ns name] (t/symbol ns name)))

(defn gensym "Returns a new symbol with a unique name. If a prefix string is\r\n  supplied, the name is prefix# where # is some unique number. If\r\n  prefix is not supplied, the prefix is 'G__'." {:added "1.0", :static true} ([] (gensym "G__")) ([prefix-string] (t/symbol (str prefix-string (str (t/next-id))))))

(defn keyword "Returns a Keyword with the given namespace and name.  Do not use :\r\n  in the keyword strings, it will be added automatically." {:added "1.0", :static true} ([name] (cond (keyword? name) name (symbol? name) (t/keyword name) (string? name) (t/keyword name))) ([ns name] (t/keyword ns name)))

(defn find-keyword "Returns a Keyword with the given namespace and name if one already\r\n  exists.  This function will not intern a new keyword. If the keyword\r\n  has not already been interned, it will return nil.  Do not use :\r\n  in the keyword strings, it will be added automatically." {:added "1.3", :static true} ([name] (cond (keyword? name) name (symbol? name) (t/find-keyword name) (string? name) (t/find-keyword name))) ([ns name] (t/find-keyword ns name)))

(defn spread {:private true, :static true} [arglist] (cond (nil? arglist) nil (nil? (next arglist)) (seq (first arglist)) :else (cons (first arglist) (spread (next arglist)))))

(defn list* "Creates a new seq containing the items prepended to the rest, the\r\n  last of which will be treated as a sequence." {:added "1.0", :static true} ([args] (seq args)) ([a args] (cons a args)) ([a b args] (cons a (cons b args))) ([a b c args] (cons a (cons b (cons c args)))) ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))

(defn apply "Applies fn f to the argument list formed by prepending intervening arguments to args." {:added "1.0", :static true} ([^p/IFn f args] (. f (applyTo (seq args)))) ([^p/IFn f x args] (. f (applyTo (list* x args)))) ([^p/IFn f x y args] (. f (applyTo (list* x y args)))) ([^p/IFn f x y z args] (. f (applyTo (list* x y z args)))) ([^p/IFn f a b c d & args] (. f (applyTo (cons a (cons b (cons c (cons d (spread args)))))))))

(defn vary-meta "Returns an object of the same type and value as obj, with\r\n  (apply f (meta obj) args) as its metadata." {:added "1.0", :static true} [obj f & args] (with-meta obj (apply f (meta obj) args)))

(defmacro lazy-seq "Takes a body of expressions that returns an ISeq or nil, and yields\r\n  a Seqable object that will invoke the body only the first time seq\r\n  is called, and will cache the result and return it on all subsequent\r\n  seq calls. See also - realized?" {:added "1.0"} [& body] (list (quote new) (quote t/LazySeq) (list* (quote ^{:once true} fn*) [] body)))

(defn ^{:static true} chunk-buffer [capacity] (t/chunk-buffer capacity))

(defn ^{:static true} chunk-append [b x] (.add b x))

(defn ^{:static true} chunk [b] (.chunk b))

(defn ^{:static true} chunk-first [s] (.chunkedFirst s))

(defn ^{:static true} chunk-rest [s] (.chunkedMore s))

(defn ^{:static true} chunk-next [s] (.chunkedNext s))

(defn ^{:static true} chunk-cons [chunk rest] (if (^{:line 61, :column 41} (fn [x] ^{:line 61, :column 49} (h/-zero? ^{:line 61, :column 59} (h/host) x)) (p/-count chunk)) rest (t/chunk-cons chunk rest)))

(defn ^{:static true} chunked-seq? [s] ([x] ^{:line 243, :column 45} (t/chunked-seq? x) s))

(defn concat "Returns a lazy seq representing the concatenation of the elements in the supplied colls." {:added "1.0", :static true} ([] (lazy-seq nil)) ([x] (lazy-seq x)) ([x y] (lazy-seq (let [s (seq x)] (if s (if (chunked-seq? s) (chunk-cons (chunk-first s) (concat (chunk-rest s) y)) (cons (first s) (concat (rest s) y))) y)))) ([x y & zs] (let [cat (fn cat [xys zs] (lazy-seq (let [xys (seq xys)] (if xys (if (chunked-seq? xys) (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs)) (cons (first xys) (cat (rest xys) zs))) (when zs (cat (first zs) (next zs)))))))] (cat (concat x y) zs))))

(defmacro delay "Takes a body of expressions and yields a Delay object that will\r\n  invoke the body only the first time it is forced (with force or deref/@), and\r\n  will cache the result and return it on all subsequent force\r\n  calls. See also - realized?" {:added "1.0"} [& body] (list (quote new) (quote t/Delay) (list* (clojure.core/with-meta (quote ^{:once true} fn*) (clojure.core/apply clojure.core/array-map (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list :once) (clojure.core/list true)))))) [] body)))

(defn delay? "returns true if x is a Delay created with delay" {:added "1.0", :static true} [x] ([x] ^{:line 246, :column 45} (t/delay? x) x))

(defn force "If x is a Delay, returns the (possibly cached) value of its expression, else returns x" {:added "1.0", :static true} [x] (t/force x))

(defmacro if-not "Evaluates test. If logical false, evaluates and returns then expr, \r\n  otherwise else expr, if supplied, else nil." {:added "1.0"} ([test then] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/if-not)) (clojure.core/list test) (clojure.core/list then) (clojure.core/list nil))))) ([test then else] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/not)) (clojure.core/list test))))) (clojure.core/list then) (clojure.core/list else))))))

(defn identical? "Tests if 2 arguments are the same object" {:added "1.0"} ([x y] (^{:line 78, :column 35} (fn [a b] ^{:line 78, :column 45} (h/-identical? ^{:line 78, :column 60} (h/host) a b)) x y)))

(defn = "Equality. Returns true if x equals y, false if not. Same as\r\n  Java x.equals(y) except it also works for nil, and compares\r\n  numbers and collections in a type-independent manner.  Clojure's immutable data\r\n  structures define equals() (and thus =) as a value, not an identity,\r\n  comparison." {:added "1.0"} ([x] true) ([x y] (p/-equiv x y)) ([x y & more] (if (p/-equiv x y) (if (next more) (recur y (first more) (next more)) (p/-equiv y (first more))) false)))

(defn not= "Same as (not (= obj1 obj2))" {:added "1.0", :static true} ([x] false) ([x y] (not (= x y))) ([x y & more] (not (apply = x y more))))

(defn compare "Comparator. Returns a negative number, zero, or a positive number\r\n  when x is logically 'less than', 'equal to', or 'greater than'\r\n  y. Same as Java x.compareTo(y) except it also works for nil, and\r\n  compares numbers and collections in a type-independent manner. x\r\n  must implement Comparable" {:added "1.0"} [x y] (p/-compare x y))

(defmacro and "Evaluates exprs one at a time, from left to right. If a form\r\n  returns logical false (nil or false), and returns that value and\r\n  doesn't evaluate any of the other expressions, otherwise it returns\r\n  the value of the last expr. (and) returns true." {:added "1.0"} ([] true) ([x] x) ([x & next] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote and__459__auto__)) (clojure.core/list x)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (quote and__459__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/and)) next)))) (clojure.core/list (quote and__459__auto__)))))))))))

(defmacro or "Evaluates exprs one at a time, from left to right. If a form\r\n  returns a logical true value, or returns that value and doesn't\r\n  evaluate any of the other expressions, otherwise it returns the\r\n  value of the last expression. (or) returns nil." {:added "1.0"} ([] nil) ([x] x) ([x & next] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote or__460__auto__)) (clojure.core/list x)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (quote or__460__auto__)) (clojure.core/list (quote or__460__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/or)) next)))))))))))))

(defn zero? "Returns true if num is zero, else false" {:added "1.0"} [num] (h/-zero? (h/host) num))

(defn count "Returns the number of items in the collection. (count nil) returns\r\n  0.  Also works on strings, arrays, and Java Collections and Maps" {:added "1.0"} [coll] (p/-count coll))

(defn int "Coerce to int" {:added "1.0"} [x] (clojure.core/int x))

(defn nth "Returns the value at the index. get returns nil if index out of\r\n  bounds, nth throws an exception unless not-found is supplied.  nth\r\n  also works for strings, Java arrays, regex Matchers and Lists, and,\r\n  in O(n) time, for sequences." {:added "1.0"} ([coll index] (p/-nth coll index)) ([coll index not-found] (p/-nth coll index not-found)))

(defn < "Returns non-nil if nums are in monotonically increasing order,\r\n  otherwise false." {:added "1.0"} ([x] true) ([x y] (h/-lt (h/host) x y)) ([x y & more] (if (< x y) (if (next more) (recur y (first more) (next more)) (< y (first more))) false)))

(defn inc' "Returns a number one greater than num. Supports arbitrary precision.\r\n  See also: inc" {:added "1.0"} [x] (h/-inc (h/host) x))

(defn inc "Returns a number one greater than num. Does not auto-promote\r\n  longs, will throw on overflow. See also: inc'" {:added "1.2"} [x] (h/-inc (h/host) x))

(defn ^{:static true, :private true} reduce1 ([f coll] (let [s (seq coll)] (if s (reduce1 f (first s) (next s)) (f)))) ([f val coll] (let [s (seq coll)] (if s (if (chunked-seq? s) (recur f (.reduce (chunk-first s) f val) (chunk-next s)) (recur f (f val (first s)) (next s))) val))))

(defn reverse "Returns a seq of the items in coll in reverse order. Not lazy." {:added "1.0", :static true} [coll] (reduce1 conj () coll))

(defn ^{:private true} nary-inline ([op] (nary-inline op op)) ([op unchecked-op] (fn ([x] (let [op (if *unchecked-math* unchecked-op op)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list op) (clojure.core/list x)))))))))) ([x y] (let [op (if *unchecked-math* unchecked-op op)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list op) (clojure.core/list x) (clojure.core/list y)))))))))) ([x y & more] (let [op (if *unchecked-math* unchecked-op op)] (reduce1 (fn [a b] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list op) (clojure.core/list a) (clojure.core/list b))))))))) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list op) (clojure.core/list x) (clojure.core/list y)))))))) more))))))

(defn ^{:private true} >1? [n] (^{:line 58, :column 41} (fn [x y] ^{:line 58, :column 51} (h/-gt ^{:line 58, :column 58} (h/host) x y)) n 1))

(defn ^{:private true} >0? [n] (^{:line 58, :column 41} (fn [x y] ^{:line 58, :column 51} (h/-gt ^{:line 58, :column 58} (h/host) x y)) n 0))

(defn +' "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\r\n  See also: +" {:added "1.0"} ([] 0) ([x] (cast Number x)) ([x y] (h/-add (h/host) x y)) ([x y & more] (reduce1 +' (+' x y) more)))

(defn + "Returns the sum of nums. (+) returns 0. Does not auto-promote\r\n  longs, will throw on overflow. See also: +'" {:added "1.2"} ([] 0) ([x] (cast Number x)) ([x y] (h/-add (h/host) x y)) ([x y & more] (reduce1 + (+ x y) more)))

(defn *' "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\r\n  See also: *" {:added "1.0"} ([] 1) ([x] (cast Number x)) ([x y] (h/-multiply (h/host) x y)) ([x y & more] (reduce1 *' (*' x y) more)))

(defn * "Returns the product of nums. (*) returns 1. Does not auto-promote\r\n  longs, will throw on overflow. See also: *'" {:added "1.2"} ([] 1) ([x] (cast Number x)) ([x y] (h/-multiply (h/host) x y)) ([x y & more] (reduce1 * (* x y) more)))

(defn / "If no denominators are supplied, returns 1/numerator,\r\n  else returns numerator divided by all of the denominators." {:added "1.0"} ([x] (/ 1 x)) ([x y] (h/-divide (h/host) x y)) ([x y & more] (reduce1 / (/ x y) more)))

(defn -' "If no ys are supplied, returns the negation of x, else subtracts\r\n  the ys from x and returns the result. Supports arbitrary precision.\r\n  See also: -" {:added "1.0"} ([x] (h/-negate (h/host) x)) ([x y] (h/-subtract (h/host) x y)) ([x y & more] (reduce1 -' (-' x y) more)))

(defn - "If no ys are supplied, returns the negation of x, else subtracts\r\n  the ys from x and returns the result. Does not auto-promote\r\n  longs, will throw on overflow. See also: -'" {:added "1.2"} ([x] (h/-negate (h/host) x)) ([x y] (h/-subtract (h/host) x y)) ([x y & more] (reduce1 - (- x y) more)))

(defn <= "Returns non-nil if nums are in monotonically non-decreasing order,\r\n  otherwise false." {:added "1.0"} ([x] true) ([x y] (h/-lte (h/host) x y)) ([x y & more] (if (<= x y) (if (next more) (recur y (first more) (next more)) (<= y (first more))) false)))

(defn > "Returns non-nil if nums are in monotonically decreasing order,\r\n  otherwise false." {:added "1.0"} ([x] true) ([x y] (h/-gt (h/host) x y)) ([x y & more] (if (> x y) (if (next more) (recur y (first more) (next more)) (> y (first more))) false)))

(defn >= "Returns non-nil if nums are in monotonically non-increasing order,\r\n  otherwise false." {:added "1.0"} ([x] true) ([x y] (h/-gte (h/host) x y)) ([x y & more] (if (>= x y) (if (next more) (recur y (first more) (next more)) (>= y (first more))) false)))

(defn == "Returns non-nil if nums all have the equivalent\r\n  value (type-independent), otherwise false" {:added "1.0"} ([x] true) ([x y] (h/-num-equiv (h/host) x y)) ([x y & more] (if (== x y) (if (next more) (recur y (first more) (next more)) (== y (first more))) false)))

(defn max "Returns the greatest of the nums." {:added "1.0"} ([x] x) ([x y] (if (h/-gt (h/host) x y) x y)) ([x y & more] (reduce1 max (max x y) more)))

(defn min "Returns the least of the nums." {:added "1.0"} ([x] x) ([x y] (if (h/-lt (h/host) x y) x y)) ([x y & more] (reduce1 min (min x y) more)))

(defn abs {:doc "Returns the absolute value of a.\r\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\r\n  If a is a double and zero => +0.0\r\n  If a is a double and ##Inf or ##-Inf => ##Inf\r\n  If a is a double and ##NaN => ##NaN", :added "1.11"} [a] (abs a))

(defn dec' "Returns a number one less than num. Supports arbitrary precision.\r\n  See also: dec" {:added "1.0"} [x] (h/-dec (h/host) x))

(defn dec "Returns a number one less than num. Does not auto-promote\r\n  longs, will throw on overflow. See also: dec'" {:added "1.2"} [x] (h/-dec (h/host) x))

(defn unchecked-inc-int "Returns a number one greater than x, an int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-inc-int x))

(defn unchecked-inc "Returns a number one greater than x, a long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-inc x))

(defn unchecked-dec-int "Returns a number one less than x, an int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-dec-int x))

(defn unchecked-dec "Returns a number one less than x, a long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-dec x))

(defn unchecked-negate-int "Returns the negation of x, an int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-negate-int x))

(defn unchecked-negate "Returns the negation of x, a long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x] (clojure.core/unchecked-subtract x))

(defn unchecked-add-int "Returns the sum of x and y, both int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-add-int x y))

(defn unchecked-add "Returns the sum of x and y, both long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-add x y))

(defn unchecked-subtract-int "Returns the difference of x and y, both int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-subtract-int x y))

(defn unchecked-subtract "Returns the difference of x and y, both long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-subtract x y))

(defn unchecked-multiply-int "Returns the product of x and y, both int.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-multiply-int x y))

(defn unchecked-multiply "Returns the product of x and y, both long.\r\n  Note - uses a primitive operator subject to overflow." {:added "1.0"} [x y] (clojure.core/unchecked-multiply x y))

(defn unchecked-divide-int "Returns the division of x by y, both int.\r\n  Note - uses a primitive operator subject to truncation." {:added "1.0"} [x y] (clojure.core/unchecked-divide-int x y))

(defn unchecked-remainder-int "Returns the remainder of division of x by y, both int.\r\n  Note - uses a primitive operator subject to truncation." {:added "1.0"} [x y] (clojure.core/unchecked-remainder-int x y))

(defn pos? "Returns true if num is greater than zero, else false" {:added "1.0"} [num] (h/-pos? (h/host) num))

(defn neg? "Returns true if num is less than zero, else false" {:added "1.0"} [num] (h/-neg? (h/host) num))

(defn quot "quot[ient] of dividing numerator by denominator." {:added "1.0", :static true} [num div] (clojure.core/quot num div))

(defn rem "remainder of dividing numerator by denominator." {:added "1.0", :static true} [num div] (clojure.core/rem num div))

(defn rationalize "returns the rational value of num" {:added "1.0", :static true} [num] (t/rationalize num))

(defn bit-not "Bitwise complement" {:added "1.0"} [x] (h/-bit-not (h/host) x))

(defn bit-and "Bitwise and" {:added "1.0"} ([x y] (h/-bit-and (h/host) x y)) ([x y & more] (reduce1 bit-and (bit-and x y) more)))

(defn bit-or "Bitwise or" {:added "1.0"} ([x y] (h/-bit-or (h/host) x y)) ([x y & more] (reduce1 bit-or (bit-or x y) more)))

(defn bit-xor "Bitwise exclusive or" {:added "1.0"} ([x y] (h/-bit-xor (h/host) x y)) ([x y & more] (reduce1 bit-xor (bit-xor x y) more)))

(defn bit-and-not "Bitwise and with complement" {:added "1.0", :static true} ([x y] (clojure.core/bit-and-not x y)) ([x y & more] (reduce1 bit-and-not (bit-and-not x y) more)))

(defn bit-clear "Clear bit at index n" {:added "1.0", :static true} [x n] (clojure.core/bit-clear x n))

(defn bit-set "Set bit at index n" {:added "1.0", :static true} [x n] (clojure.core/bit-set x n))

(defn bit-flip "Flip bit at index n" {:added "1.0", :static true} [x n] (clojure.core/bit-flip x n))

(defn bit-test "Test bit at index n" {:added "1.0", :static true} [x n] (clojure.core/bit-test x n))

(defn bit-shift-left "Bitwise shift left" {:added "1.0"} [x n] (h/-bit-shift-left (h/host) x n))

(defn bit-shift-right "Bitwise shift right" {:added "1.0"} [x n] (h/-bit-shift-right (h/host) x n))

(defn unsigned-bit-shift-right "Bitwise shift right, without sign-extension." {:added "1.6"} [x n] (h/-unsigned-bit-shift-right (h/host) x n))

(defn integer? "Returns true if n is an integer" {:added "1.0", :static true} [n] (or ([x] ^{:line 264, :column 45} (t/int? x) n) ([x] ^{:line 265, :column 45} (t/long? x) n) ([x] ^{:line 249, :column 45} (t/bigint? x) n) ([x] ^{:line 269, :column 45} (t/biginteger? x) n) (instance? Short n) (instance? Byte n)))

(defn even? "Returns true if n is even, throws an exception if n is not an integer" {:added "1.0", :static true} [n] (if (integer? n) (zero? (bit-and (unchecked-long n) 1)) (throw (clojure.core/ex-info (str "Argument must be an integer: " n) {}))))

(defn odd? "Returns true if n is odd, throws an exception if n is not an integer" {:added "1.0", :static true} [n] (not (even? n)))

(defn int? "Return true if x is a fixed precision integer" {:added "1.9"} [x] (or ([x] ^{:line 265, :column 45} (t/long? x) x) ([x] ^{:line 264, :column 45} (t/int? x) x) (instance? Short x) (instance? Byte x)))

(defn pos-int? "Return true if x is a positive fixed precision integer" {:added "1.9"} [x] (and (int? x) (pos? x)))

(defn neg-int? "Return true if x is a negative fixed precision integer" {:added "1.9"} [x] (and (int? x) (neg? x)))

(defn nat-int? "Return true if x is a non-negative fixed precision integer" {:added "1.9"} [x] (and (int? x) (not (neg? x))))

(defn double? "Return true if x is a Double" {:added "1.9"} [x] ([x] ^{:line 266, :column 45} (t/double? x) x))

(defn complement "Takes a fn f and returns a fn that takes the same arguments as f,\r\n  has the same effects, if any, and returns the opposite truth value." {:added "1.0", :static true} [f] (fn ([] (not (f))) ([x] (not (f x))) ([x y] (not (f x y))) ([x y & zs] (not (apply f x y zs)))))

(defn constantly "Returns a function that takes any number of arguments and returns x." {:added "1.0", :static true} [x] (fn [& args] x))

(defn identity "Returns its argument." {:added "1.0", :static true} [x] x)

(defn peek "For a list or queue, same as first, for a vector, same as, but much\r\n  more efficient than, last. If the collection is empty, returns nil." {:added "1.0", :static true} [coll] (p/-peek coll))

(defn pop "For a list or queue, returns a new list/queue without the first\r\n  item, for a vector, returns a new vector without the last item. If\r\n  the collection is empty, throws an exception.  Note - not the same\r\n  as next/butlast." {:added "1.0", :static true} [coll] (p/-pop coll))

(defn map-entry? "Return true if x is a map entry" {:added "1.8"} [x] (instance? java.util.Map$Entry x))

(defn contains? "Returns true if key is present in the given collection, otherwise\r\n  returns false.  Note that for numerically indexed collections like\r\n  vectors and Java arrays, this tests if the numeric key is within the\r\n  range of indexes. 'contains?' operates constant or logarithmic time;\r\n  it will not perform a linear search for a value.  See also 'some'." {:added "1.0", :static true} [coll key] (p/-contains-key? coll key))

(defn get "Returns the value mapped to key, not-found or nil if key not present\r\n  in associative collection, set, string, array, or ILookup instance." {:added "1.0"} ([map key] (p/-lookup map key)) ([map key not-found] (p/-lookup map key not-found)))

(defn dissoc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\r\n  that does not contain a mapping for key(s)." {:added "1.0", :static true} ([map] map) ([map key] (p/-dissoc map key)) ([map key & ks] (let [ret (dissoc map key)] (if ks (recur ret (first ks) (next ks)) ret))))

(defn disj "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\r\n  does not contain key(s)." {:added "1.0", :static true} ([set] set) ([set key] (when set (. set (disjoin key)))) ([set key & ks] (when set (let [ret (disj set key)] (if ks (recur ret (first ks) (next ks)) ret)))))

(defn find "Returns the map entry for key, or nil if key not present." {:added "1.0", :static true} [map key] (t/find map key))

(defn select-keys "Returns a map containing only those entries in map whose key is in keys" {:added "1.0", :static true} [map keyseq] (loop [ret {} keys (seq keyseq)] (if keys (let [entry (t/find map (first keys))] (recur (if entry (conj ret entry) ret) (next keys))) (with-meta ret (meta map)))))

(defn keys "Returns a sequence of the map's keys, in the same order as (seq map)." {:added "1.0", :static true} [map] (t/keys map))

(defn vals "Returns a sequence of the map's values, in the same order as (seq map)." {:added "1.0", :static true} [map] (t/vals map))

(defn key "Returns the key of the map entry." {:added "1.0", :static true} [e] (. e (getKey)))

(defn val "Returns the value in the map entry." {:added "1.0", :static true} [e] (. e (getValue)))

(defn rseq "Returns, in constant time, a seq of the items in rev (which\r\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil" {:added "1.0", :static true} [rev] (. rev (rseq)))

(defn name "Returns the name String of a string, symbol or keyword." {:added "1.0", :static true} [x] (if (string? x) x (. x (getName))))

(defn namespace "Returns the namespace String of a symbol or keyword, or nil if not present." {:added "1.0", :static true} [x] (. x (getNamespace)))

(defn boolean "Coerce to boolean" {:added "1.0"} [x] (boolean x))

(defn ident? "Return true if x is a symbol or keyword" {:added "1.9"} [x] (or (keyword? x) (symbol? x)))

(defn simple-ident? "Return true if x is a symbol or keyword without a namespace" {:added "1.9"} [x] (and (ident? x) (nil? (namespace x))))

(defn qualified-ident? "Return true if x is a symbol or keyword with a namespace" {:added "1.9"} [x] (boolean (and (ident? x) (namespace x) true)))

(defn simple-symbol? "Return true if x is a symbol without a namespace" {:added "1.9"} [x] (and (symbol? x) (nil? (namespace x))))

(defn qualified-symbol? "Return true if x is a symbol with a namespace" {:added "1.9"} [x] (boolean (and (symbol? x) (namespace x) true)))

(defn simple-keyword? "Return true if x is a keyword without a namespace" {:added "1.9"} [x] (and (keyword? x) (nil? (namespace x))))

(defn qualified-keyword? "Return true if x is a keyword with a namespace" {:added "1.9"} [x] (boolean (and (keyword? x) (namespace x) true)))

(defmacro locking "Executes exprs in an implicit do, while holding the monitor of x.\r\n  Will release the monitor of x in all circumstances." {:added "1.0"} [x & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote lockee__461__auto__)) (clojure.core/list x)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote locklocal__462__auto__)) (clojure.core/list (quote lockee__461__auto__))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote monitor-enter)) (clojure.core/list (quote locklocal__462__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote finally)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote monitor-exit)) (clojure.core/list (quote locklocal__462__auto__))))))))))))))))))))))))))

(defmacro .. "form => fieldName-symbol or (instanceMethodName-symbol args*)\r\n\r\n  Expands into a member access (.) of the first member on the first\r\n  argument, followed by the next member on the result, etc. For\r\n  instance:\r\n\r\n  (.. System (getProperties) (get \"os.name\"))\r\n\r\n  expands to:\r\n\r\n  (. (. System (getProperties)) (get \"os.name\"))\r\n\r\n  but is easier to write, read, and understand." {:added "1.0"} ([x form] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list x) (clojure.core/list form))))) ([x form & more] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/..)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list x) (clojure.core/list form))))) more)))))

(defmacro -> "Threads the expr through the forms. Inserts x as the\r\n  second item in the first form, making a list of it if it is not a\r\n  list already. If there are more forms, inserts the first form as the\r\n  second item in second form, etc." {:added "1.0"} [x & forms] (loop [x x forms forms] (if forms (let [form (first forms) threaded (if (seq? form) (with-meta (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (first form)) (clojure.core/list x) (next form)))) (meta form)) (list form x))] (recur threaded (next forms))) x)))

(defmacro ->> "Threads the expr through the forms. Inserts x as the\r\n  last item in the first form, making a list of it if it is not a\r\n  list already. If there are more forms, inserts the first form as the\r\n  last item in second form, etc." {:added "1.1"} [x & forms] (loop [x x forms forms] (if forms (let [form (first forms) threaded (if (seq? form) (with-meta (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (first form)) (next form) (clojure.core/list x)))) (meta form)) (list form x))] (recur threaded (next forms))) x)))

(def map)

(defn ^{:private true} check-valid-options "Throws an exception if the given option map contains keys not listed\r\n  as valid, else returns nil." [options & valid-keys] (when (seq (apply disj (apply hash-set (keys options)) valid-keys)) (throw (clojure.core/ex-info (apply str "Only these options are valid: " (first valid-keys) (map (fn* [%1] (str ", " %1)) (rest valid-keys))) {}))))

(def global-hierarchy)

(defmacro defmulti "Creates a new multimethod with the associated dispatch function.\r\n  The docstring and attr-map are optional.\r\n\r\n  Options are key-value pairs and may be one of:\r\n\r\n  :default\r\n\r\n  The default dispatch value, defaults to :default\r\n\r\n  :hierarchy\r\n\r\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\r\n\r\n  Hierarchies are type-like relationships that do not depend upon type\r\n  inheritance. By default Clojure's multimethods dispatch off of a\r\n  global hierarchy map.  However, a hierarchy relationship can be\r\n  created with the derive function used to augment the root ancestor\r\n  created with make-hierarchy.\r\n\r\n  Multimethods expect the value of the hierarchy option to be supplied as\r\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\r\n  or the var special form)." {:arglists (quote ([name docstring? attr-map? dispatch-fn & options])), :added "1.0"} [mm-name & options] (let [docstring (if (string? (first options)) (first options) nil) options (if (string? (first options)) (next options) options) m (if (map? (first options)) (first options) {}) options (if (map? (first options)) (next options) options) dispatch-fn (first options) options (next options) m (if docstring (assoc m :doc docstring) m) m (if (meta mm-name) (conj (meta mm-name) m) m) mm-name (with-meta mm-name m)] (when (= (count options) 1) (throw (Exception. "The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"))) (let [options (apply hash-map options) default (get options :default :default) hierarchy (get options :hierarchy (var global-hierarchy))] (check-valid-options options :default :hierarchy) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote v__463__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote def)) (clojure.core/list mm-name)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-not)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/and)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .hasRoot)) (clojure.core/list (quote v__463__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/instance?)) (clojure.core/list (quote t/MultiFn)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/deref)) (clojure.core/list (quote v__463__auto__)))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote def)) (clojure.core/list mm-name) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote new)) (clojure.core/list (quote t/MultiFn)) (clojure.core/list (name mm-name)) (clojure.core/list dispatch-fn) (clojure.core/list default) (clojure.core/list hierarchy)))))))))))))))))))

(defmacro defmethod "Creates and installs a new method of multimethod associated with dispatch-value. " {:added "1.0"} [multifn dispatch-val & fn-tail] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (with-meta multifn {:tag (quote t/MultiFn)})) (clojure.core/list (quote portabilize-core-v2/addMethod)) (clojure.core/list dispatch-val) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) fn-tail))))))))

(defn remove-all-methods "Removes all of the methods of multimethod." {:added "1.2", :static true} [multifn] (.reset multifn))

(defn remove-method "Removes the method of multimethod associated with dispatch-value." {:added "1.0", :static true} [multifn dispatch-val] (. multifn removeMethod dispatch-val))

(defn prefer-method "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \r\n   when there is a conflict" {:added "1.0", :static true} [multifn dispatch-val-x dispatch-val-y] (. multifn preferMethod dispatch-val-x dispatch-val-y))

(defn methods "Given a multimethod, returns a map of dispatch values -> dispatch fns" {:added "1.0", :static true} [multifn] (.getMethodTable multifn))

(defn get-method "Given a multimethod and a dispatch value, returns the dispatch fn\r\n  that would apply to that value, or nil if none apply and no default" {:added "1.0", :static true} [multifn dispatch-val] (.getMethod multifn dispatch-val))

(defn prefers "Given a multimethod, returns a map of preferred value -> set of other values" {:added "1.0", :static true} [multifn] (.getPreferTable multifn))

(defmacro ^{:private true} assert-args [& pairs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-not)) (clojure.core/list (first pairs)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote ex-info)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list (quote &form)))))) (clojure.core/list " requires ") (clojure.core/list (second pairs)) (clojure.core/list " in ") (clojure.core/list (quote *ns*)) (clojure.core/list ":") (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list :line) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/meta)) (clojure.core/list (quote &form)))))))))))))))))))))))))) (clojure.core/list (let [more (nnext pairs)] (when more (list* (quote portabilize-core-v2/assert-args) more))))))))

(defmacro if-let "bindings => binding-form test\r\n\r\n  If test is true, evaluates then with binding-form bound to the value of \r\n  test, if not, yields else" {:added "1.0"} ([bindings then] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/if-let)) (clojure.core/list bindings) (clojure.core/list then) (clojure.core/list nil))))) ([bindings then else & oldform] (assert-args (vector? bindings) "a vector for its binding" (nil? oldform) "1 or 2 forms after binding vector" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [form (bindings 0) tst (bindings 1)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote temp__464__auto__)) (clojure.core/list tst)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (quote temp__464__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list form) (clojure.core/list (quote temp__464__auto__))))))) (clojure.core/list then))))) (clojure.core/list else)))))))))))

(defmacro when-let "bindings => binding-form test\r\n\r\n  When test is true, evaluates body with binding-form bound to the value of test" {:added "1.0"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [form (bindings 0) tst (bindings 1)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote temp__465__auto__)) (clojure.core/list tst)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list (quote temp__465__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list form) (clojure.core/list (quote temp__465__auto__))))))) body)))))))))))))

(defmacro if-some "bindings => binding-form test\r\n\r\n   If test is not nil, evaluates then with binding-form bound to the\r\n   value of test, if not, yields else" {:added "1.6"} ([bindings then] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/if-some)) (clojure.core/list bindings) (clojure.core/list then) (clojure.core/list nil))))) ([bindings then else & oldform] (assert-args (vector? bindings) "a vector for its binding" (nil? oldform) "1 or 2 forms after binding vector" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [form (bindings 0) tst (bindings 1)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote temp__466__auto__)) (clojure.core/list tst)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/nil?)) (clojure.core/list (quote temp__466__auto__)))))) (clojure.core/list else) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list form) (clojure.core/list (quote temp__466__auto__))))))) (clojure.core/list then)))))))))))))))

(defmacro when-some "bindings => binding-form test\r\n\r\n   When test is not nil, evaluates body with binding-form bound to the\r\n   value of test" {:added "1.6"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [form (bindings 0) tst (bindings 1)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote temp__467__auto__)) (clojure.core/list tst)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/nil?)) (clojure.core/list (quote temp__467__auto__)))))) (clojure.core/list nil) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list form) (clojure.core/list (quote temp__467__auto__))))))) body)))))))))))))

(defn push-thread-bindings "WARNING: This is a low-level function. Prefer high-level macros like\r\n  binding where ever possible.\r\n\r\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\r\n  the current thread. Each call *MUST* be accompanied by a matching call to\r\n  pop-thread-bindings wrapped in a try-finally!\r\n  \r\n      (push-thread-bindings bindings)\r\n      (try\r\n        ...\r\n        (finally\r\n          (pop-thread-bindings)))" {:added "1.1", :static true} [bindings] (t/push-thread-bindings bindings))

(defn pop-thread-bindings "Pop one set of bindings pushed with push-binding before. It is an error to\r\n  pop bindings without pushing before." {:added "1.1", :static true} [] (t/pop-thread-bindings))

(defn get-thread-bindings "Get a map with the Var/value pairs which is currently in effect for the\r\n  current thread." {:added "1.1", :static true} [] (t/get-thread-bindings))

(defmacro binding "binding => var-symbol init-expr\r\n\r\n  Creates new bindings for the (already-existing) vars, with the\r\n  supplied initial values, executes the exprs in an implicit do, then\r\n  re-establishes the bindings that existed before.  The new bindings\r\n  are made in parallel (unlike let); all init-exprs are evaluated\r\n  before the vars are bound to their new values." {:added "1.0"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (even? (count bindings)) "an even number of forms in binding vector") (let [var-ize (fn [var-vals] (loop [ret [] vvs (seq var-vals)] (if vvs (recur (conj (conj ret (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list (first vvs)))))) (second vvs)) (next (next vvs))) (seq ret))))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/push-thread-bindings)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/hash-map)) (var-ize bindings))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote finally)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/pop-thread-bindings)))))))))))))))))))

(defn with-bindings* "Takes a map of Var/value pairs. Installs for the given Vars the associated\r\n  values as thread-local bindings. Then calls f with the supplied arguments.\r\n  Pops the installed bindings after f returned. Returns whatever f returns." {:added "1.1", :static true} [binding-map f & args] (push-thread-bindings binding-map) (try (apply f args) (finally (pop-thread-bindings))))

(defmacro with-bindings "Takes a map of Var/value pairs. Installs for the given Vars the associated\r\n  values as thread-local bindings. Then executes body. Pops the installed\r\n  bindings after body was evaluated. Returns the value of body." {:added "1.1"} [binding-map & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/with-bindings*)) (clojure.core/list binding-map) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) body))))))))

(defn bound-fn* "Returns a function, which will install the same bindings in effect as in\r\n  the thread at the time bound-fn* was called and then call f with any given\r\n  arguments. This may be used to define a helper function which runs on a\r\n  different thread, but needs the same bindings in place." {:added "1.1", :static true} [f] (let [bindings (get-thread-bindings)] (fn [& args] (apply with-bindings* bindings f args))))

(defmacro bound-fn "Returns a function defined by the given fntail, which will install the\r\n  same bindings in effect as in the thread at the time bound-fn was called.\r\n  This may be used to define a helper function which runs on a different\r\n  thread, but needs the same bindings in place." {:added "1.1"} [& fntail] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/bound-fn*)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) fntail))))))))

(defn find-var "Returns the global var named by the namespace-qualified symbol, or\r\n  nil if no var with that name." {:added "1.0", :static true} [sym] (t/find-var sym))

(defn binding-conveyor-fn {:private true, :added "1.3"} [f] (let [frame (t/clone-thread-binding-frame)] (fn ([] (t/reset-thread-binding-frame frame) (f)) ([x] (t/reset-thread-binding-frame frame) (f x)) ([x y] (t/reset-thread-binding-frame frame) (f x y)) ([x y z] (t/reset-thread-binding-frame frame) (f x y z)) ([x y z & args] (t/reset-thread-binding-frame frame) (apply f x y z args)))))

(defn ^{:private true} setup-reference [r options] (let [opts (apply hash-map options)] (when (:meta opts) (.resetMeta r (:meta opts))) (when (:validator opts) (.setValidator r (:validator opts))) r))

(defn agent "Creates and returns an agent with an initial value of state and\r\n  zero or more options (in any order):\r\n\r\n  :meta metadata-map\r\n\r\n  :validator validate-fn\r\n\r\n  :error-handler handler-fn\r\n\r\n  :error-mode mode-keyword\r\n\r\n  If metadata-map is supplied, it will become the metadata on the\r\n  agent. validate-fn must be nil or a side-effect-free fn of one\r\n  argument, which will be passed the intended new state on any state\r\n  change. If the new state is unacceptable, the validate-fn should\r\n  return false or throw an exception.  handler-fn is called if an\r\n  action throws an exception or if validate-fn rejects a new state --\r\n  see set-error-handler! for details.  The mode-keyword may be either\r\n  :continue (the default if an error-handler is given) or :fail (the\r\n  default if no error-handler is given) -- see set-error-mode! for\r\n  details." {:added "1.0", :static true} ([state & options] (let [a (t/agent state) opts (apply hash-map options)] (setup-reference a options) (when (:error-handler opts) (.setErrorHandler a (:error-handler opts))) (.setErrorMode a (or (:error-mode opts) (if (:error-handler opts) :continue :fail))) a)))

(defn set-agent-send-executor! "Sets the ExecutorService to be used by send" {:added "1.5"} [executor] (set! t/pooled-executor executor))

(defn set-agent-send-off-executor! "Sets the ExecutorService to be used by send-off" {:added "1.5"} [executor] (set! t/solo-executor executor))

(defn send-via "Dispatch an action to an agent. Returns the agent immediately.\r\n  Subsequently, in a thread supplied by executor, the state of the agent\r\n  will be set to the value of:\r\n\r\n  (apply action-fn state-of-agent args)" {:added "1.5"} [executor a f & args] (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args executor))

(defn send "Dispatch an action to an agent. Returns the agent immediately.\r\n  Subsequently, in a thread from a thread pool, the state of the agent\r\n  will be set to the value of:\r\n\r\n  (apply action-fn state-of-agent args)" {:added "1.0", :static true} [a f & args] (apply send-via t/pooled-executor a f args))

(defn send-off "Dispatch a potentially blocking action to an agent. Returns the\r\n  agent immediately. Subsequently, in a separate thread, the state of\r\n  the agent will be set to the value of:\r\n\r\n  (apply action-fn state-of-agent args)" {:added "1.0", :static true} [a f & args] (apply send-via t/solo-executor a f args))

(defn release-pending-sends "Normally, actions sent directly or indirectly during another action\r\n  are held until the action completes (changes the agent's\r\n  state). This function can be used to dispatch any pending sent\r\n  actions immediately. This has no impact on actions sent during a\r\n  transaction, which are still held until commit. If no action is\r\n  occurring, does nothing. Returns the number of actions dispatched." {:added "1.0", :static true} [] (t/release-pending-sends))

(defn add-watch "Adds a watch function to an agent/atom/var/ref reference. The watch\r\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\r\n  new-state. Whenever the reference's state might have been changed,\r\n  any registered watches will have their functions called. The watch fn\r\n  will be called synchronously, on the agent's thread if an agent,\r\n  before any pending sends if agent or ref. Note that an atom's or\r\n  ref's state may have changed again prior to the fn call, so use\r\n  old/new-state rather than derefing the reference. Note also that watch\r\n  fns may be called from multiple threads simultaneously. Var watchers\r\n  are triggered only by root binding changes, not thread-local\r\n  set!s. Keys must be unique per reference, and can be used to remove\r\n  the watch with remove-watch, but are otherwise considered opaque by\r\n  the watch mechanism." {:added "1.0", :static true} [reference key fn] (.addWatch reference key fn))

(defn remove-watch "Removes a watch (set by add-watch) from a reference" {:added "1.0", :static true} [reference key] (.removeWatch reference key))

(defn agent-error "Returns the exception thrown during an asynchronous action of the\r\n  agent if the agent is failed.  Returns nil if the agent is not\r\n  failed." {:added "1.2", :static true} [a] (.getError a))

(defn restart-agent "When an agent is failed, changes the agent state to new-state and\r\n  then un-fails the agent so that sends are allowed again.  If\r\n  a :clear-actions true option is given, any actions queued on the\r\n  agent that were being held while it was failed will be discarded,\r\n  otherwise those held actions will proceed.  The new-state must pass\r\n  the validator if any, or restart will throw an exception and the\r\n  agent will remain failed with its old state and error.  Watchers, if\r\n  any, will NOT be notified of the new state.  Throws an exception if\r\n  the agent is not failed." {:added "1.2", :static true} [a new-state & options] (let [opts (apply hash-map options)] (.restart a new-state (if (:clear-actions opts) true false))))

(defn set-error-handler! "Sets the error-handler of agent a to handler-fn.  If an action\r\n  being run by the agent throws an exception or doesn't pass the\r\n  validator fn, handler-fn will be called with two arguments: the\r\n  agent and the exception." {:added "1.2", :static true} [a handler-fn] (.setErrorHandler a handler-fn))

(defn error-handler "Returns the error-handler of agent a, or nil if there is none.\r\n  See set-error-handler!" {:added "1.2", :static true} [a] (.getErrorHandler a))

(defn set-error-mode! "Sets the error-mode of agent a to mode-keyword, which must be\r\n  either :fail or :continue.  If an action being run by the agent\r\n  throws an exception or doesn't pass the validator fn, an\r\n  error-handler may be called (see set-error-handler!), after which,\r\n  if the mode is :continue, the agent will continue as if neither the\r\n  action that caused the error nor the error itself ever happened.\r\n  \r\n  If the mode is :fail, the agent will become failed and will stop\r\n  accepting new 'send' and 'send-off' actions, and any previously\r\n  queued actions will be held until a 'restart-agent'.  Deref will\r\n  still work, returning the state of the agent before the error." {:added "1.2", :static true} [a mode-keyword] (.setErrorMode a mode-keyword))

(defn error-mode "Returns the error-mode of agent a.  See set-error-mode!" {:added "1.2", :static true} [a] (.getErrorMode a))

(defn agent-errors "DEPRECATED: Use 'agent-error' instead.\r\n  Returns a sequence of the exceptions thrown during asynchronous\r\n  actions of the agent." {:added "1.0", :deprecated "1.2"} [a] (when-let [e (agent-error a)] (list e)))

(defn clear-agent-errors "DEPRECATED: Use 'restart-agent' instead.\r\n  Clears any exceptions thrown during asynchronous actions of the\r\n  agent, allowing subsequent actions to occur." {:added "1.0", :deprecated "1.2"} [a] (restart-agent a (.deref a)))

(defn shutdown-agents "Initiates a shutdown of the thread pools that back the agent\r\n  system. Running actions will complete, but no new actions will be\r\n  accepted" {:added "1.0", :static true} [] (t/shutdown-agents))

(defn ref "Creates and returns a Ref with an initial value of x and zero or\r\n  more options (in any order):\r\n\r\n  :meta metadata-map\r\n\r\n  :validator validate-fn\r\n\r\n  :min-history (default 0)\r\n  :max-history (default 10)\r\n\r\n  If metadata-map is supplied, it will become the metadata on the\r\n  ref. validate-fn must be nil or a side-effect-free fn of one\r\n  argument, which will be passed the intended new state on any state\r\n  change. If the new state is unacceptable, the validate-fn should\r\n  return false or throw an exception. validate-fn will be called on\r\n  transaction commit, when all refs have their final values.\r\n\r\n  Normally refs accumulate history dynamically as needed to deal with\r\n  read demands. If you know in advance you will need history you can\r\n  set :min-history to ensure it will be available when first needed (instead\r\n  of after a read fault). History is limited, and the limit can be set\r\n  with :max-history." {:added "1.0", :static true} ([x] (t/ref x)) ([x & options] (let [r (setup-reference (ref x) options) opts (apply hash-map options)] (when (:max-history opts) (.setMaxHistory r (:max-history opts))) (when (:min-history opts) (.setMinHistory r (:min-history opts))) r)))

(defn ^{:private true} deref-future ([fut] (.get fut)) ([fut timeout-ms timeout-val] (try (.get fut timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS) (catch java.util.concurrent.TimeoutException e timeout-val))))

(defn deref "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\r\n  returns the in-transaction-value of ref, else returns the\r\n  most-recently-committed value of ref. When applied to a var, agent\r\n  or atom, returns its current state. When applied to a delay, forces\r\n  it if not already forced. When applied to a future, will block if\r\n  computation not complete. When applied to a promise, will block\r\n  until a value is delivered.  The variant taking a timeout can be\r\n  used for blocking references (futures and promises), and will return\r\n  timeout-val if the timeout (in milliseconds) is reached before a\r\n  value is available. See also - realized?." {:added "1.0", :static true} ([ref] (if (instance? p/IDeref ref) (.deref ^p/IDeref ref) (deref-future ref))) ([ref timeout-ms timeout-val] (if (instance? p/IBlockingDeref ref) (.deref ^p/IBlockingDeref ref timeout-ms timeout-val) (deref-future ref timeout-ms timeout-val))))

(defn atom "Creates and returns an Atom with an initial value of x and zero or\r\n  more options (in any order):\r\n\r\n  :meta metadata-map\r\n\r\n  :validator validate-fn\r\n\r\n  If metadata-map is supplied, it will become the metadata on the\r\n  atom. validate-fn must be nil or a side-effect-free fn of one\r\n  argument, which will be passed the intended new state on any state\r\n  change. If the new state is unacceptable, the validate-fn should\r\n  return false or throw an exception." {:added "1.0", :static true} ([x] (t/atom x)) ([x & options] (setup-reference (atom x) options)))

(defn swap! "Atomically swaps the value of atom to be:\r\n  (apply f current-value-of-atom args). Note that f may be called\r\n  multiple times, and thus should be free of side effects.  Returns\r\n  the value that was swapped in." {:added "1.0", :static true} ([atom f] (.swap atom f)) ([atom f x] (.swap atom f x)) ([atom f x y] (.swap atom f x y)) ([atom f x y & args] (.swap atom f x y args)))

(defn swap-vals! "Atomically swaps the value of atom to be:\r\n  (apply f current-value-of-atom args). Note that f may be called\r\n  multiple times, and thus should be free of side effects.\r\n  Returns [old new], the value of the atom before and after the swap." {:added "1.9"} ([atom f] (.swapVals atom f)) ([atom f x] (.swapVals atom f x)) ([atom f x y] (.swapVals atom f x y)) ([atom f x y & args] (.swapVals atom f x y args)))

(defn compare-and-set! "Atomically sets the value of atom to newval if and only if the\r\n  current value of the atom is identical to oldval. Returns true if\r\n  set happened, else false" {:added "1.0", :static true} [atom oldval newval] (.compareAndSet atom oldval newval))

(defn reset! "Sets the value of atom to newval without regard for the\r\n  current value. Returns newval." {:added "1.0", :static true} [atom newval] (.reset atom newval))

(defn reset-vals! "Sets the value of atom to newval. Returns [old new], the value of the\r\n   atom before and after the reset." {:added "1.9"} [atom newval] (.resetVals atom newval))

(defn set-validator! "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\r\n  side-effect-free fn of one argument, which will be passed the intended\r\n  new state on any state change. If the new state is unacceptable, the\r\n  validator-fn should return false or throw an exception. If the current state (root\r\n  value if var) is not acceptable to the new validator, an exception\r\n  will be thrown and the validator will not be changed." {:added "1.0", :static true} [iref validator-fn] (. iref (setValidator validator-fn)))

(defn get-validator "Gets the validator-fn for a var/ref/agent/atom." {:added "1.0", :static true} [iref] (. iref (getValidator)))

(defn alter-meta! "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\r\n\r\n  (apply f its-current-meta args)\r\n\r\n  f must be free of side-effects" {:added "1.0", :static true} [iref f & args] (.alterMeta iref f args))

(defn reset-meta! "Atomically resets the metadata for a namespace/var/ref/agent/atom" {:added "1.0", :static true} [iref metadata-map] (.resetMeta iref metadata-map))

(defn commute "Must be called in a transaction. Sets the in-transaction-value of\r\n  ref to:\r\n\r\n  (apply fun in-transaction-value-of-ref args)\r\n\r\n  and returns the in-transaction-value of ref.\r\n\r\n  At the commit point of the transaction, sets the value of ref to be:\r\n\r\n  (apply fun most-recently-committed-value-of-ref args)\r\n\r\n  Thus fun should be commutative, or, failing that, you must accept\r\n  last-one-in-wins behavior.  commute allows for more concurrency than\r\n  ref-set." {:added "1.0", :static true} [ref fun & args] (. ref (commute fun args)))

(defn alter "Must be called in a transaction. Sets the in-transaction-value of\r\n  ref to:\r\n\r\n  (apply fun in-transaction-value-of-ref args)\r\n\r\n  and returns the in-transaction-value of ref." {:added "1.0", :static true} [ref fun & args] (. ref (alter fun args)))

(defn ref-set "Must be called in a transaction. Sets the value of ref.\r\n  Returns val." {:added "1.0", :static true} [ref val] (. ref (set val)))

(defn ref-history-count "Returns the history count of a ref" {:added "1.1", :static true} [ref] (.getHistoryCount ref))

(defn ref-min-history "Gets the min-history of a ref, or sets it and returns the ref" {:added "1.1", :static true} ([ref] (.getMinHistory ref)) ([ref n] (.setMinHistory ref n)))

(defn ref-max-history "Gets the max-history of a ref, or sets it and returns the ref" {:added "1.1", :static true} ([ref] (.getMaxHistory ref)) ([ref n] (.setMaxHistory ref n)))

(defn ensure "Must be called in a transaction. Protects the ref from modification\r\n  by other transactions.  Returns the in-transaction-value of\r\n  ref. Allows for more concurrency than (ref-set ref @ref)" {:added "1.0", :static true} [ref] (. ref (touch)) (. ref (deref)))

(defmacro sync "transaction-flags => TBD, pass nil for now\r\n\r\n  Runs the exprs (in an implicit do) in a transaction that encompasses\r\n  exprs and any nested calls.  Starts a transaction if none is already\r\n  running on this thread. Any uncaught exception will abort the\r\n  transaction and flow out of sync. The exprs may be run more than\r\n  once, but any effects on Refs will be atomic." {:added "1.0"} [flags-ignored-for-now & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.stm)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/runInTransaction)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) body))))))))))))

(defmacro io! "If an io! block occurs in a transaction, throws an\r\n  IllegalStateException, else runs body in an implicit do. If the\r\n  first expression in body is a literal string, will use that as the\r\n  exception message." {:added "1.0"} [& body] (let [message (when (string? (first body)) (first body)) body (if message (next body) body)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote t/in-transaction?)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote new)) (clojure.core/list (quote ex-info)) (clojure.core/list (or message "I/O in transaction")))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) body)))))))))

(defn volatile! "Creates and returns a Volatile with an initial value of val." {:added "1.7"} [val] (t/volatile val))

(defn vreset! "Sets the value of volatile to newval without regard for the\r\n   current value. Returns newval." {:added "1.7"} [vol newval] (.reset vol newval))

(defmacro vswap! "Non-atomically swaps the value of the volatile as if:\r\n   (apply f current-value-of-vol args). Returns the value that\r\n   was swapped in." {:added "1.7"} [vol f & args] (let [v (with-meta vol {:tag (quote t/Volatile)})] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .reset)) (clojure.core/list v) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list f) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .deref)) (clojure.core/list v))))) args)))))))))

(defn volatile? "Returns true if x is a volatile." {:added "1.7"} [x] ([x] ^{:line 251, :column 45} (t/volatile? x) x))

(defn comp "Takes a set of functions and returns a fn that is the composition\r\n  of those fns.  The returned fn takes a variable number of args,\r\n  applies the rightmost of fns to the args, the next\r\n  fn (right-to-left) to the result, etc." {:added "1.0", :static true} ([] identity) ([f] f) ([f g] (fn ([] (f (g))) ([x] (f (g x))) ([x y] (f (g x y))) ([x y z] (f (g x y z))) ([x y z & args] (f (apply g x y z args))))) ([f g & fs] (reduce1 comp (list* f g fs))))

(defn juxt "Takes a set of functions and returns a fn that is the juxtaposition\r\n  of those fns.  The returned fn takes a variable number of args, and\r\n  returns a vector containing the result of applying each fn to the\r\n  args (left-to-right).\r\n  ((juxt a b c) x) => [(a x) (b x) (c x)]" {:added "1.1", :static true} ([f] (fn ([] [(f)]) ([x] [(f x)]) ([x y] [(f x y)]) ([x y z] [(f x y z)]) ([x y z & args] [(apply f x y z args)]))) ([f g] (fn ([] [(f) (g)]) ([x] [(f x) (g x)]) ([x y] [(f x y) (g x y)]) ([x y z] [(f x y z) (g x y z)]) ([x y z & args] [(apply f x y z args) (apply g x y z args)]))) ([f g h] (fn ([] [(f) (g) (h)]) ([x] [(f x) (g x) (h x)]) ([x y] [(f x y) (g x y) (h x y)]) ([x y z] [(f x y z) (g x y z) (h x y z)]) ([x y z & args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)]))) ([f g h & fs] (let [fs (list* f g h fs)] (fn ([] (reduce1 (fn* [%1 %2] (conj %1 (%2))) [] fs)) ([x] (reduce1 (fn* [%1 %2] (conj %1 (%2 x))) [] fs)) ([x y] (reduce1 (fn* [%1 %2] (conj %1 (%2 x y))) [] fs)) ([x y z] (reduce1 (fn* [%1 %2] (conj %1 (%2 x y z))) [] fs)) ([x y z & args] (reduce1 (fn* [%1 %2] (conj %1 (apply %2 x y z args))) [] fs))))))

(defn partial "Takes a function f and fewer than the normal arguments to f, and\r\n  returns a fn that takes a variable number of additional args. When\r\n  called, the returned function calls f with args + additional args." {:added "1.0", :static true} ([f] f) ([f arg1] (fn ([] (f arg1)) ([x] (f arg1 x)) ([x y] (f arg1 x y)) ([x y z] (f arg1 x y z)) ([x y z & args] (apply f arg1 x y z args)))) ([f arg1 arg2] (fn ([] (f arg1 arg2)) ([x] (f arg1 arg2 x)) ([x y] (f arg1 arg2 x y)) ([x y z] (f arg1 arg2 x y z)) ([x y z & args] (apply f arg1 arg2 x y z args)))) ([f arg1 arg2 arg3] (fn ([] (f arg1 arg2 arg3)) ([x] (f arg1 arg2 arg3 x)) ([x y] (f arg1 arg2 arg3 x y)) ([x y z] (f arg1 arg2 arg3 x y z)) ([x y z & args] (apply f arg1 arg2 arg3 x y z args)))) ([f arg1 arg2 arg3 & more] (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))

(defn sequence "Coerces coll to a (possibly empty) sequence, if it is not already\r\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\r\n  transducer is supplied, returns a lazy sequence of applications of\r\n  the transform to the items in coll(s), i.e. to the set of first\r\n  items of each coll, followed by the set of second\r\n  items in each coll, until any one of the colls is exhausted.  Any\r\n  remaining items in other colls are ignored. The transform should accept\r\n  number-of-colls arguments" {:added "1.0", :static true} ([coll] (if (seq? coll) coll (or (seq coll) ()))) ([xform coll] (or (t/chunk-iterator-seq (t/transformer-iterator xform (t/iterator coll))) ())) ([xform coll & colls] (or (t/chunk-iterator-seq (t/transformer-iterator-multi xform (map (fn* [%1] (t/iterator %1)) (cons coll colls)))) ())))

(defn every? "Returns true if (pred x) is logical true for every x in coll, else\r\n  false." {:added "1.0", :static true} [pred coll] (cond (nil? (seq coll)) true (pred (first coll)) (recur pred (next coll)) :else false))

(def ^{:doc "Returns false if (pred x) is logical true for every x in\r\n  coll, else true.", :arglists (quote ([pred coll])), :added "1.0"} not-every? (comp not every?))

(defn some "Returns the first logical true value of (pred x) for any x in coll,\r\n  else nil.  One common idiom is to use a set as pred, for example\r\n  this will return :fred if :fred is in the sequence, otherwise nil:\r\n  (some #{:fred} coll)" {:added "1.0", :static true} [pred coll] (when-let [s (seq coll)] (or (pred (first s)) (recur pred (next s)))))

(def ^{:doc "Returns false if (pred x) is logical true for any x in coll,\r\n  else true.", :arglists (quote ([pred coll])), :added "1.0"} not-any? (comp not some))

(defmacro dotimes "bindings => name n\r\n\r\n  Repeatedly executes body (presumably for side-effects) with name\r\n  bound to integers from 0 through n-1." {:added "1.0"} [bindings & body] (let [i (first bindings) n (second bindings)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote n__468__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote long)) (clojure.core/list n)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list i) (clojure.core/list 0)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list i) (clojure.core/list (quote n__468__auto__)))))) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list i))))))))))))))))))))))

(defn map "Returns a lazy sequence consisting of the result of applying f to\r\n  the set of first items of each coll, followed by applying f to the\r\n  set of second items in each coll, until any one of the colls is\r\n  exhausted.  Any remaining items in other colls are ignored. Function\r\n  f should accept number-of-colls arguments. Returns a transducer when\r\n  no collection is provided." {:added "1.0", :static true} ([f] (fn [rf] (fn ([] (rf)) ([result] (rf result)) ([result input] (rf result (f input))) ([result input & inputs] (rf result (apply f input inputs)))))) ([f coll] (lazy-seq (when-let [s (seq coll)] (if (chunked-seq? s) (let [c (chunk-first s) size (int (count c)) b (chunk-buffer size)] (dotimes [i size] (chunk-append b (f (.nth c i)))) (chunk-cons (chunk b) (map f (chunk-rest s)))) (cons (f (first s)) (map f (rest s))))))) ([f c1 c2] (lazy-seq (let [s1 (seq c1) s2 (seq c2)] (when (and s1 s2) (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2))))))) ([f c1 c2 c3] (lazy-seq (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)] (when (and s1 s2 s3) (cons (f (first s1) (first s2) (first s3)) (map f (rest s1) (rest s2) (rest s3))))))) ([f c1 c2 c3 & colls] (let [step (fn step [cs] (lazy-seq (let [ss (map seq cs)] (when (every? identity ss) (cons (map first ss) (step (map rest ss)))))))] (map (fn* [%1] (apply f %1)) (step (conj colls c3 c2 c1))))))

(defmacro declare "defs the supplied var names with no bindings, useful for making forward declarations." {:added "1.0"} [& names] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (map (fn* [%1] (list (quote def) (vary-meta %1 assoc :declared true))) names)))))

(declare cat)

(defn mapcat "Returns the result of applying concat to the result of applying map\r\n  to f and colls.  Thus function f should return a collection. Returns\r\n  a transducer when no collections are provided" {:added "1.0", :static true} ([f] (comp (map f) cat)) ([f & colls] (apply concat (apply map f colls))))

(defn filter "Returns a lazy sequence of the items in coll for which\r\n  (pred item) returns logical true. pred must be free of side-effects.\r\n  Returns a transducer when no collection is provided." {:added "1.0", :static true} ([pred] (fn [rf] (fn ([] (rf)) ([result] (rf result)) ([result input] (if (pred input) (rf result input) result))))) ([pred coll] (lazy-seq (when-let [s (seq coll)] (if (chunked-seq? s) (let [c (chunk-first s) size (count c) b (chunk-buffer size)] (dotimes [i size] (let [v (.nth c i)] (when (pred v) (chunk-append b v)))) (chunk-cons (chunk b) (filter pred (chunk-rest s)))) (let [f (first s) r (rest s)] (if (pred f) (cons f (filter pred r)) (filter pred r))))))))

(defn remove "Returns a lazy sequence of the items in coll for which\r\n  (pred item) returns logical false. pred must be free of side-effects.\r\n  Returns a transducer when no collection is provided." {:added "1.0", :static true} ([pred] (filter (complement pred))) ([pred coll] (filter (complement pred) coll)))

(defn reduced "Wraps x in a way such that a reduce will terminate with the value x" {:added "1.5"} [x] (t/reduced x))

(defn reduced? "Returns true if x is the result of a call to reduced" {:added "1.5"} ([x] (reduced? x)))

(defn ensure-reduced "If x is already reduced?, returns it, else returns (reduced x)" {:added "1.7"} [x] (if (reduced? x) x (reduced x)))

(defn unreduced "If x is reduced?, returns (deref x), else returns x" {:added "1.7"} [x] (if (reduced? x) (deref x) x))

(defn take "Returns a lazy sequence of the first n items in coll, or all items if\r\n  there are fewer than n.  Returns a stateful transducer when\r\n  no collection is provided." {:added "1.0", :static true} ([n] (fn [rf] (let [nv (volatile! n)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [n (clojure.core/deref nv) nn (vswap! nv dec) result (if (pos? n) (rf result input) result)] (if (not (pos? nn)) (ensure-reduced result) result))))))) ([n coll] (lazy-seq (when (pos? n) (when-let [s (seq coll)] (cons (first s) (take (dec n) (rest s))))))))

(defn take-while "Returns a lazy sequence of successive items from coll while\r\n  (pred item) returns logical true. pred must be free of side-effects.\r\n  Returns a transducer when no collection is provided." {:added "1.0", :static true} ([pred] (fn [rf] (fn ([] (rf)) ([result] (rf result)) ([result input] (if (pred input) (rf result input) (reduced result)))))) ([pred coll] (lazy-seq (when-let [s (seq coll)] (when (pred (first s)) (cons (first s) (take-while pred (rest s))))))))

(defn drop "Returns a laziness-preserving sequence of all but the first n items in coll.\r\n  Returns a stateful transducer when no collection is provided." {:added "1.0", :static true} ([n] (fn [rf] (let [nv (volatile! n)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [n (clojure.core/deref nv)] (vswap! nv dec) (if (pos? n) result (rf result input)))))))) ([n coll] (if ([x] ^{:line 254, :column 45} (satisfies? p/IDrop x) coll) (or (if (pos? n) (.drop coll (if (int? n) n (Math/ceil n))) (seq coll)) ()) (let [step (fn [n coll] (let [s (seq coll)] (if (and (pos? n) s) (recur (dec n) (rest s)) s)))] (lazy-seq (step n coll))))))

(defn drop-last "Return a lazy sequence of all but the last n (default 1) items in coll" {:added "1.0", :static true} ([coll] (drop-last 1 coll)) ([n coll] (map (fn [x _] x) coll (drop n coll))))

(defn take-last "Returns a seq of the last n items in coll.  Depending on the type\r\n  of coll may be no better than linear time.  For vectors, see also subvec." {:added "1.1", :static true} [n coll] (loop [s (seq coll) lead (seq (drop n coll))] (if lead (recur (next s) (next lead)) s)))

(defn drop-while "Returns a lazy sequence of the items in coll starting from the\r\n  first item for which (pred item) returns logical false.  Returns a\r\n  stateful transducer when no collection is provided." {:added "1.0", :static true} ([pred] (fn [rf] (let [dv (volatile! true)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [drop? (clojure.core/deref dv)] (if (and drop? (pred input)) result (do (vreset! dv nil) (rf result input))))))))) ([pred coll] (let [step (fn [pred coll] (let [s (seq coll)] (if (and s (pred (first s))) (recur pred (rest s)) s)))] (lazy-seq (step pred coll)))))

(defn cycle "Returns a lazy (infinite!) sequence of repetitions of the items in coll." {:added "1.0", :static true} [coll] (t/cycle (seq coll)))

(defn split-at "Returns a vector of [(take n coll) (drop n coll)]" {:added "1.0", :static true} [n coll] [(take n coll) (drop n coll)])

(defn split-with "Returns a vector of [(take-while pred coll) (drop-while pred coll)]" {:added "1.0", :static true} [pred coll] [(take-while pred coll) (drop-while pred coll)])

(defn repeat "Returns a lazy (infinite!, or length n if supplied) sequence of xs." {:added "1.0", :static true} ([x] (t/repeat x)) ([n x] (t/repeat n x)))

(defn replicate "DEPRECATED: Use 'repeat' instead.\r\n   Returns a lazy seq of n xs." {:added "1.0", :deprecated "1.3"} [n x] (take n (repeat x)))

(defn iterate "Returns a lazy (infinite!) sequence of x, (f x), (f (f x)) etc.\r\n  f must be free of side-effects" {:added "1.0", :static true} [f x] (t/iterate f x))

(defn range "Returns a lazy seq of nums from start (inclusive) to end\r\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\r\n  infinity. When step is equal to 0, returns an infinite sequence of\r\n  start. When start is equal to end, returns empty list." {:added "1.0", :static true} ([] (iterate inc' 0)) ([end] (if (int? end) (t/range end) (t/range end))) ([start end] (if (and (int? start) (int? end)) (t/range start end) (t/range start end))) ([start end step] (if (and (int? start) (int? end) (int? step)) (t/range start end step) (t/range start end step))))

(defn merge "Returns a map that consists of the rest of the maps conj-ed onto\r\n  the first.  If a key occurs in more than one map, the mapping from\r\n  the latter (left-to-right) will be the mapping in the result." {:added "1.0", :static true} [& maps] (when (some identity maps) (reduce1 (fn* [%1 %2] (conj (or %1 {}) %2)) maps)))

(defn merge-with "Returns a map that consists of the rest of the maps conj-ed onto\r\n  the first.  If a key occurs in more than one map, the mapping(s)\r\n  from the latter (left-to-right) will be combined with the mapping in\r\n  the result by calling (f val-in-result val-in-latter)." {:added "1.0", :static true} [f & maps] (when (some identity maps) (let [merge-entry (fn [m e] (let [k (key e) v (val e)] (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v)))) merge2 (fn [m1 m2] (reduce1 merge-entry (or m1 {}) (seq m2)))] (reduce1 merge2 maps))))

(defn line-seq "Returns the lines of text from rdr as a lazy sequence of strings.\r\n  rdr must implement java.io.BufferedReader." {:added "1.0", :static true} [^java.io.BufferedReader rdr] (when-let [line (.readLine rdr)] (cons line (lazy-seq (line-seq rdr)))))

(defn comparator "Returns an implementation of java.util.Comparator based upon pred." {:added "1.0", :static true} [pred] (fn [x y] (cond (pred x y) -1 (pred y x) 1 :else 0)))

(defn sort "Returns a sorted sequence of the items in coll. If no comparator is\r\n  supplied, uses compare.  comparator must implement\r\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\r\n  not be reordered.  If coll is a Java array, it will be modified.  To\r\n  avoid this, sort a copy of the array." {:added "1.0", :static true} ([coll] (sort compare coll)) ([comp coll] (if (seq coll) (let [a (to-array coll)] (. java.util.Arrays (sort a comp)) (with-meta (seq a) (meta coll))) ())))

(defn sort-by "Returns a sorted sequence of the items in coll, where the sort\r\n  order is determined by comparing (keyfn item).  If no comparator is\r\n  supplied, uses compare.  comparator must implement\r\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\r\n  not be reordered.  If coll is a Java array, it will be modified.  To\r\n  avoid this, sort a copy of the array." {:added "1.0", :static true} ([keyfn coll] (sort-by keyfn compare coll)) ([keyfn comp coll] (sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)))

(defn dorun "When lazy sequences are produced via functions that have side\r\n  effects, any effects other than those needed to produce the first\r\n  element in the seq do not occur until the seq is consumed. dorun can\r\n  be used to force any effects. Walks through the successive nexts of\r\n  the seq, does not retain the head and returns nil." {:added "1.0", :static true} ([coll] (when-let [s (seq coll)] (recur (next s)))) ([n coll] (when (and (seq coll) (pos? n)) (recur (dec n) (next coll)))))

(defn doall "When lazy sequences are produced via functions that have side\r\n  effects, any effects other than those needed to produce the first\r\n  element in the seq do not occur until the seq is consumed. doall can\r\n  be used to force any effects. Walks through the successive nexts of\r\n  the seq, retains the head and returns it, thus causing the entire\r\n  seq to reside in memory at one time." {:added "1.0", :static true} ([coll] (dorun coll) coll) ([n coll] (dorun n coll) coll))

(defn nthnext "Returns the nth next of coll, (seq coll) when n is 0." {:added "1.0", :static true} [coll n] (if ([x] ^{:line 254, :column 45} (satisfies? p/IDrop x) coll) (if (pos? n) (.drop coll (if (int? n) n (Math/ceil n))) (seq coll)) (loop [n n xs (seq coll)] (if (and xs (pos? n)) (recur (dec n) (next xs)) xs))))

(defn nthrest "Returns the nth rest of coll, coll when n is 0." {:added "1.3", :static true} [coll n] (if (pos? n) (or (if ([x] ^{:line 254, :column 45} (satisfies? p/IDrop x) coll) (.drop coll (if (int? n) n (Math/ceil n))) (loop [n n xs coll] (if-let [xs (and (pos? n) (seq xs))] (recur (dec n) (rest xs)) (seq xs)))) ()) coll))

(defn partition "Returns a lazy sequence of lists of n items each, at offsets step\r\n  apart. If step is not supplied, defaults to n, i.e. the partitions\r\n  do not overlap. If a pad collection is supplied, use its elements as\r\n  necessary to complete last partition upto n items. In case there are\r\n  not enough padding elements, return a partition with less than n items." {:added "1.0", :static true} ([n coll] (partition n n coll)) ([n step coll] (lazy-seq (when-let [s (seq coll)] (let [p (doall (take n s))] (when (= n (count p)) (cons p (partition n step (nthrest s step)))))))) ([n step pad coll] (lazy-seq (when-let [s (seq coll)] (let [p (doall (take n s))] (if (= n (count p)) (cons p (partition n step pad (nthrest s step))) (list (take n (concat p pad)))))))))

(defn eval "Evaluates the form data structure (not text!) and returns the result." {:added "1.0", :static true} [form] (t/eval form))

(defmacro doseq "Repeatedly executes body (presumably for side-effects) with\r\n  bindings and filtering as provided by \"for\".  Does not retain\r\n  the head of the sequence. Returns nil." {:added "1.0"} [seq-exprs & body] (assert-args (vector? seq-exprs) "a vector for its binding" (even? (count seq-exprs)) "an even number of forms in binding vector") (let [step (fn step [recform exprs] (if-not exprs [true (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) body)))] (let [k (first exprs) v (second exprs)] (if (keyword? k) (let [steppair (step recform (nnext exprs)) needrec (steppair 0) subform (steppair 1)] (cond (= k :let) [needrec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list v) (clojure.core/list subform))))] (= k :while) [false (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list v) (clojure.core/list subform) (when needrec [recform]))))] (= k :when) [false (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list v) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list subform) (when needrec [recform]))))) (clojure.core/list recform))))])) (let [seq- (gensym "seq_") chunk- (with-meta (gensym "chunk_") {:tag (quote p/IChunk)}) count- (gensym "count_") i- (gensym "i_") recform (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/next)) (clojure.core/list seq-))))) (clojure.core/list nil) (clojure.core/list 0) (clojure.core/list 0)))) steppair (step recform (nnext exprs)) needrec (steppair 0) subform (steppair 1) recform-chunk (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list seq-) (clojure.core/list chunk-) (clojure.core/list count-) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list i-)))))))) steppair-chunk (step recform-chunk (nnext exprs)) subform-chunk (steppair-chunk 1)] [true (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list seq-) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list v))))) (clojure.core/list chunk-) (clojure.core/list nil) (clojure.core/list count-) (clojure.core/list 0) (clojure.core/list i-) (clojure.core/list 0)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list i-) (clojure.core/list count-))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list k) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .nth)) (clojure.core/list chunk-) (clojure.core/list i-)))))))))) (clojure.core/list subform-chunk) (when needrec [recform-chunk]))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list seq-) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list seq-)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunked-seq?)) (clojure.core/list seq-))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote c__469__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-first)) (clojure.core/list seq-)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-rest)) (clojure.core/list seq-))))) (clojure.core/list (quote c__469__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/int)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/count)) (clojure.core/list (quote c__469__auto__)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/int)) (clojure.core/list 0))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list k) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list seq-)))))))))) (clojure.core/list subform) (when needrec [recform]))))))))))))))))))))])))))] (nth (step nil (seq seq-exprs)) 1)))

(defn await "Blocks the current thread (indefinitely!) until all actions\r\n  dispatched thus far, from this thread or agent, to the agent(s) have\r\n  occurred.  Will block on failed agents.  Will never return if\r\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called." {:added "1.0", :static true} [& agents] (io! "await in transaction" (when *agent* (throw (clojure.core/ex-info "Can't await in agent action" {}))) (let [latch (new java.util.concurrent.CountDownLatch (count agents)) count-down (fn [agent] (. latch (countDown)) agent)] (doseq [agent agents] (send agent count-down)) (. latch (await)))))

(defn ^{:static true} await1 [a] (when (pos? (.getQueueCount a)) (await a)) a)

(defn await-for "Blocks the current thread until all actions dispatched thus\r\n  far (from this thread or agent) to the agents have occurred, or the\r\n  timeout (in milliseconds) has elapsed. Returns logical false if\r\n  returning due to timeout, logical true otherwise." {:added "1.0", :static true} [timeout-ms & agents] (io! "await-for in transaction" (when *agent* (throw (clojure.core/ex-info "Can't await in agent action" {}))) (let [latch (new java.util.concurrent.CountDownLatch (count agents)) count-down (fn [agent] (. latch (countDown)) agent)] (doseq [agent agents] (send agent count-down)) (. latch (await timeout-ms (. java.util.concurrent.TimeUnit MILLISECONDS))))))

(defmacro dotimes "bindings => name n\r\n\r\n  Repeatedly executes body (presumably for side-effects) with name\r\n  bound to integers from 0 through n-1." {:added "1.0"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [i (first bindings) n (second bindings)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote n__470__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/long)) (clojure.core/list n)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list i) (clojure.core/list 0)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list i) (clojure.core/list (quote n__470__auto__)))))) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list i))))))))))))))))))))))

(defn transient "Returns a new, transient version of the collection, in constant time.\r\n\r\n  Transients support a parallel set of 'changing' operations, with similar names\r\n  followed by ! - assoc!, conj! etc. These do the same things as their persistent\r\n  counterparts except the return values are themselves transient.\r\n\r\n  Note in particular that transients are not designed to be bashed in-place. You\r\n  must capture and use the return value in the next call. In this way, they support\r\n  the same code structure as the functional persistent code they replace." {:added "1.1", :static true} [coll] (.asTransient coll))

(defn persistent! "Returns a new, persistent version of the transient collection, in\r\n  constant time. The transient collection cannot be used after this\r\n  call, any such use will throw an exception." {:added "1.1", :static true} [coll] (.persistent coll))

(defn conj! "Adds x to the transient collection, and return coll. The 'addition'\r\n  may happen at different 'places' depending on the concrete type." {:added "1.1", :static true} ([] (transient [])) ([coll] coll) ([coll x] (.conj coll x)))

(defn assoc! "When applied to a transient map, adds mapping of key(s) to\r\n  val(s). When applied to a transient vector, sets the val at index.\r\n  Note - index must be <= (count vector). Returns coll." {:added "1.1", :static true} ([coll key val] (.assoc coll key val)) ([coll key val & kvs] (let [ret (.assoc coll key val)] (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))

(defn dissoc! "Returns a transient map that doesn't contain a mapping for key(s)." {:added "1.1", :static true} ([map key] (.without map key)) ([map key & ks] (let [ret (.without map key)] (if ks (recur ret (first ks) (next ks)) ret))))

(defn pop! "Removes the last item from a transient vector. If\r\n  the collection is empty, throws an exception. Returns coll" {:added "1.1", :static true} [coll] (.pop coll))

(defn disj! "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\r\n  does not contain key(s)." {:added "1.1", :static true} ([set] set) ([set key] (. set (disjoin key))) ([set key & ks] (let [ret (. set (disjoin key))] (if ks (recur ret (first ks) (next ks)) ret))))

(defn ^{:private true} into1 "Returns a new coll consisting of to-coll with all of the items of\r\n  from-coll conjoined." {:added "1.0", :static true} [to from] (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) to) (persistent! (reduce1 conj! (transient to) from)) (reduce1 conj to from)))

(defmacro import "import-list => (package-symbol class-name-symbols*)\r\n\r\n  For each name in class-name-symbols, adds a mapping from name to the\r\n  class named by package.name to the current namespace. Use :import in the ns\r\n  macro in preference to calling this directly." {:added "1.0"} [& import-symbols-or-lists] (let [specs (map (fn* [%1] (if (and (seq? %1) (= (quote quote) (first %1))) (second %1) %1)) import-symbols-or-lists)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (map (fn* [%1] (list (quote clojure.core/import*) %1)) (reduce1 (fn [v spec] (if (symbol? spec) (conj v (name spec)) (let [p (first spec) cs (rest spec)] (into1 v (map (fn* [%1] (str p "." %1)) cs))))) [] specs)))))))

(defn into-array "Returns an array with components set to the values in aseq. The array's\r\n  component type is type if provided, or the type of the first value in\r\n  aseq if present, or Object. All values in aseq must be compatible with\r\n  the component type. Class objects for the primitive types can be obtained\r\n  using, e.g., Integer/TYPE." {:added "1.0", :static true} ([aseq] (t/seq-to-array (seq aseq))) ([type aseq] (t/seq-to-array type (seq aseq))))

(defn ^{:private true} array [& items] (into-array items))

(defn class "Returns the Class of x" {:added "1.0", :static true} [x] (if (nil? x) x (. x (getClass))))

(defn type "Returns the :type metadata of x, or its Class if none" {:added "1.0", :static true} [x] (or (get (meta x) :type) (class x)))

(defn num "Coerce to Number" {:added "1.0"} [x] (t/num x))

(defn long "Coerce to long" {:added "1.0"} [x] (long x))

(defn float "Coerce to float" {:added "1.0"} [x] (float x))

(defn double "Coerce to double" {:added "1.0"} [x] (double x))

(defn short "Coerce to short" {:added "1.0"} [x] (short x))

(defn byte "Coerce to byte" {:added "1.0"} [x] (byte x))

(defn char "Coerce to char" {:added "1.1"} [x] (clojure.core/char x))

(defn unchecked-byte "Coerce to byte. Subject to rounding or truncation." {:added "1.3"} [x] (unchecked-byte x))

(defn unchecked-short "Coerce to short. Subject to rounding or truncation." {:added "1.3"} [x] (unchecked-short x))

(defn unchecked-char "Coerce to char. Subject to rounding or truncation." {:added "1.3"} [x] (clojure.core/unchecked-char x))

(defn unchecked-int "Coerce to int. Subject to rounding or truncation." {:added "1.3"} [x] (unchecked-int x))

(defn unchecked-long "Coerce to long. Subject to rounding or truncation." {:added "1.3"} [x] (unchecked-long x))

(defn unchecked-float "Coerce to float. Subject to rounding." {:added "1.3"} [x] (unchecked-float x))

(defn unchecked-double "Coerce to double. Subject to rounding." {:added "1.3"} [x] (unchecked-double x))

(defn number? "Returns true if x is a Number" {:added "1.0", :static true} [x] ([x] ^{:line 262, :column 45} (t/number? x) x))

(defn mod "Modulus of num and div. Truncates toward negative infinity." {:added "1.0", :static true} [num div] (let [m (rem num div)] (if (or (zero? m) (= (pos? num) (pos? div))) m (+ m div))))

(defn ratio? "Returns true if n is a Ratio" {:added "1.0", :static true} [n] ([x] ^{:line 248, :column 45} (t/ratio? x) n))

(defn numerator "Returns the numerator part of a Ratio." {:added "1.2", :static true} [r] (.numerator r))

(defn denominator "Returns the denominator part of a Ratio." {:added "1.2", :static true} [r] (.denominator r))

(defn decimal? "Returns true if n is a BigDecimal" {:added "1.0", :static true} [n] ([x] ^{:line 268, :column 45} (t/bigdec? x) n))

(defn float? "Returns true if n is a floating point number" {:added "1.0", :static true} [n] (or ([x] ^{:line 266, :column 45} (t/double? x) n) ([x] ^{:line 267, :column 45} (t/float? x) n)))

(defn rational? "Returns true if n is a rational number" {:added "1.0", :static true} [n] (or (integer? n) (ratio? n) (decimal? n)))

(defn bigint "Coerce to BigInt" {:static true, :added "1.3"} [x] (cond ([x] ^{:line 249, :column 45} (t/bigint? x) x) x ([x] ^{:line 269, :column 45} (t/biginteger? x) x) (t/bigint-from-biginteger x) (decimal? x) (bigint (.toBigInteger x)) (float? x) (bigint (. BigDecimal valueOf (double x))) (ratio? x) (bigint (.bigIntegerValue x)) (number? x) (t/bigint (long x)) :else (bigint (BigInteger. x))))

(defn biginteger "Coerce to BigInteger" {:added "1.0", :static true} [x] (cond ([x] ^{:line 269, :column 45} (t/biginteger? x) x) x ([x] ^{:line 249, :column 45} (t/bigint? x) x) (.toBigInteger x) (decimal? x) (.toBigInteger x) (float? x) (.toBigInteger (. BigDecimal valueOf (double x))) (ratio? x) (.bigIntegerValue x) (number? x) (BigInteger/valueOf (long x)) :else (BigInteger. x)))

(defn bigdec "Coerce to BigDecimal" {:added "1.0", :static true} [x] (cond (decimal? x) x (float? x) (. BigDecimal valueOf (double x)) (ratio? x) (/ (BigDecimal. (.numerator x)) (.denominator x)) ([x] ^{:line 249, :column 45} (t/bigint? x) x) (.toBigDecimal x) ([x] ^{:line 269, :column 45} (t/biginteger? x) x) (BigDecimal. x) (number? x) (BigDecimal/valueOf (long x)) :else (BigDecimal. x)))

(def ^{:private true, :dynamic true} print-initialized false)

(defmulti print-method (fn [x writer] (let [t (get (meta x) :type)] (if (keyword? t) t (class x)))))

(defmulti print-dup (fn [x writer] (class x)))

(defn pr-on {:private true, :static true} [x w] (if *print-dup* (print-dup x w) (print-method x w)) nil)

(defn pr "Prints the object(s) to the output stream that is the current value\r\n  of *out*.  Prints the object(s), separated by spaces if there is\r\n  more than one.  By default, pr and prn print in a way that objects\r\n  can be read by the reader" {:dynamic true, :added "1.0"} ([] nil) ([x] (pr-on x *out*)) ([x & more] (pr x) (. *out* (append \space)) (if-let [nmore (next more)] (recur (first more) nmore) (apply pr more))))

(def ^{:private true} system-newline (System/getProperty "line.separator"))

(defn newline "Writes a platform-specific newline to *out*" {:added "1.0", :static true} [] (. *out* (append system-newline)) nil)

(defn flush "Flushes the output stream that is the current value of\r\n  *out*" {:added "1.0", :static true} [] (. *out* (flush)) nil)

(defn prn "Same as pr followed by (newline). Observes *flush-on-newline*" {:added "1.0", :static true} [& more] (apply pr more) (newline) (when *flush-on-newline* (flush)))

(defn print "Prints the object(s) to the output stream that is the current value\r\n  of *out*.  print and println produce output for human consumption." {:added "1.0", :static true} [& more] (binding [*print-readably* nil] (apply pr more)))

(defn println "Same as print followed by (newline)" {:added "1.0", :static true} [& more] (binding [*print-readably* nil] (apply prn more)))

(defn read "Reads the next object from stream, which must be an instance of\r\n  java.io.PushbackReader or some derivee.  stream defaults to the\r\n  current value of *in*.\r\n\r\n  Opts is a persistent map with valid keys:\r\n    :read-cond - :allow to process reader conditionals, or\r\n                 :preserve to keep all branches\r\n    :features - persistent set of feature keywords for reader conditionals\r\n    :eof - on eof, return value unless :eofthrow, then throw.\r\n           if not specified, will throw\r\n\r\n  Note that read can execute code (controlled by *read-eval*),\r\n  and as such should be used only with trusted sources.\r\n\r\n  For data structure interop use clojure.edn/read" {:added "1.0", :static true} ([] (read *in*)) ([stream] (read stream true nil)) ([stream eof-error? eof-value] (read stream eof-error? eof-value false)) ([stream eof-error? eof-value recursive?] (t/read-clojure stream (boolean eof-error?) eof-value recursive?)) ([opts stream] (t/read-clojure stream opts)))

(defn read+string "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\r\n  Returns a vector containing the object read and the (whitespace-trimmed) string read." {:added "1.10"} ([] (read+string *in*)) ([stream] (read+string stream true nil)) ([stream eof-error? eof-value] (read+string stream eof-error? eof-value false)) ([stream eof-error? eof-value recursive?] (try (.captureString stream) (let [o (read stream eof-error? eof-value recursive?) s (.trim (.getString stream))] [o s]) (catch Throwable ex (.getString stream) (throw ex)))) ([opts stream] (try (.captureString stream) (let [o (read opts stream) s (.trim (.getString stream))] [o s]) (catch Throwable ex (.getString stream) (throw ex)))))

(defn read-line "Reads the next line from stream that is the current value of *in* ." {:added "1.0", :static true} [] (if ([x] ^{:line 259, :column 55} (t/line-numbering-reader? x) *in*) (.readLine *in*) (.readLine ^java.io.BufferedReader *in*)))

(defn read-string "Reads one object from the string s. Optionally include reader\r\n  options, as specified in read.\r\n\r\n  Note that read-string can execute code (controlled by *read-eval*),\r\n  and as such should be used only with trusted sources.\r\n\r\n  For data structure interop use clojure.edn/read-string" {:added "1.0", :static true} ([s] (t/read-string s)) ([opts s] (t/read-string s opts)))

(defn subvec "Returns a persistent vector of the items in vector from\r\n  start (inclusive) to end (exclusive).  If end is not supplied,\r\n  defaults to (count vector). This operation is O(1) and very fast, as\r\n  the resulting vector shares structure with the original and no\r\n  trimming is done." {:added "1.0", :static true} ([v start] (subvec v start (count v))) ([v start end] (t/subvec v start end)))

(defmacro with-open "bindings => [name init ...]\r\n\r\n  Evaluates body in a try expression with names bound to the values\r\n  of the inits, and a finally clause that calls (.close name) on each\r\n  name in reverse order." {:added "1.0"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (even? (count bindings)) "an even number of forms in binding vector") (cond (= (count bindings) 0) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) body))) (symbol? (bindings 0)) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (subvec bindings 0 2)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/with-open)) (clojure.core/list (subvec bindings 2)) body)))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote finally)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (bindings 0)) (clojure.core/list (quote close))))))))))))))))) :else (throw (clojure.core/ex-info "with-open only allows Symbols in bindings" {}))))

(defmacro doto "Evaluates x then calls all of the methods and functions with the\r\n  value of x supplied at the front of the given arguments.  The forms\r\n  are evaluated in order.  Returns x.\r\n\r\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))" {:added "1.0"} [x & forms] (let [gx (gensym)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gx) (clojure.core/list x)))))) (map (fn [f] (with-meta (if (seq? f) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (first f)) (clojure.core/list gx) (next f)))) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list f) (clojure.core/list gx))))) (meta f))) forms) (clojure.core/list gx))))))

(defmacro memfn "Expands into code that creates a fn that expects to be passed an\r\n  object and any args and calls the named instance method on the\r\n  object passing the args. Use when you want to treat a Java method as\r\n  a first-class fn. name may be type-hinted with the method receiver's\r\n  type in order to avoid reflective calls." {:added "1.0"} [name & args] (let [t (with-meta (gensym "target") (meta name))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list t) args))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list t) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list name) args)))))))))))))

(defmacro time "Evaluates expr and prints the time it took.  Returns the value of\r\n expr." {:added "1.0"} [expr] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote start__471__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/System)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/nanoTime)))))))))) (clojure.core/list (quote ret__472__auto__)) (clojure.core/list expr)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/prn)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list "Elapsed time: ") (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core//)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/double)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/-)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/System)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/nanoTime)))))))))) (clojure.core/list (quote start__471__auto__)))))))))) (clojure.core/list 1000000.0))))) (clojure.core/list " msecs"))))))))) (clojure.core/list (quote ret__472__auto__))))))

^{:line 796, :column 10} (comment "JVM imports removed")

(defn alength "Returns the length of the Java array. Works on arrays of all\r\n  types." {:added "1.0"} [array] (h/-alength (h/host) array))

(defn aclone "Returns a clone of the Java array. Works on arrays of known\r\n  types." {:added "1.0"} [array] (h/-aclone (h/host) array))

(defn aget "Returns the value at the index/indices. Works on Java arrays of all\r\n  types." {:added "1.0"} ([array idx] (t/prep-ret (.getComponentType (class array)) (h/-aget (h/host) array idx))) ([array idx & idxs] (apply aget (aget array idx) idxs)))

(defn aset "Sets the value at the index/indices. Works on Java arrays of\r\n  reference types. Returns val." {:added "1.0"} ([array idx val] (. Array (set array idx val)) val) ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))

(defmacro ^{:private true} def-aset [name method coerce] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/defn)) (clojure.core/list name) (clojure.core/list (clojure.core/apply clojure.core/array-map (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list :arglists) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote array)) (clojure.core/list (quote idx)) (clojure.core/list (quote val))))))) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote array)) (clojure.core/list (quote idx)) (clojure.core/list (quote idx2)) (clojure.core/list (quote &)) (clojure.core/list (quote idxv)))))))))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote array__473__auto__)) (clojure.core/list (quote idx__474__auto__)) (clojure.core/list (quote val__475__auto__))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote portabilize-core-v2/Array)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list method) (clojure.core/list (quote array__473__auto__)) (clojure.core/list (quote idx__474__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list coerce) (clojure.core/list (quote val__475__auto__)))))))))))))) (clojure.core/list (quote val__475__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote array__473__auto__)) (clojure.core/list (quote idx__474__auto__)) (clojure.core/list (quote idx2__476__auto__)) (clojure.core/list (quote &)) (clojure.core/list (quote idxv__477__auto__))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/apply)) (clojure.core/list name) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/aget)) (clojure.core/list (quote array__473__auto__)) (clojure.core/list (quote idx__474__auto__)))))) (clojure.core/list (quote idx2__476__auto__)) (clojure.core/list (quote idxv__477__auto__))))))))))))))

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of int. Returns val.", :added "1.0"} aset-int setInt int)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of long. Returns val.", :added "1.0"} aset-long setLong long)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", :added "1.0"} aset-boolean setBoolean boolean)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of float. Returns val.", :added "1.0"} aset-float setFloat float)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of double. Returns val.", :added "1.0"} aset-double setDouble double)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of short. Returns val.", :added "1.0"} aset-short setShort short)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of byte. Returns val.", :added "1.0"} aset-byte setByte byte)

(def-aset ^{:doc "Sets the value at the index/indices. Works on arrays of char. Returns val.", :added "1.0"} aset-char setChar char)

(defn make-array "Creates and returns an array of instances of the specified class of\r\n  the specified dimension(s).  Note that a class object is required.\r\n  Class objects can be obtained by using their imported or\r\n  fully-qualified name.  Class objects for the primitive types can be\r\n  obtained using, e.g., Integer/TYPE." {:added "1.0", :static true} ([type len] (. Array (newInstance type (int len)))) ([type dim & more-dims] (let [dims (cons dim more-dims) ^"[I" dimarray (make-array (. Integer TYPE) (count dims))] (dotimes [i (alength dimarray)] (aset-int dimarray i (nth dims i))) (. Array (newInstance type dimarray)))))

(defn to-array-2d "Returns a (potentially-ragged) 2-dimensional array of Objects\r\n  containing the contents of coll, which can be any Collection of any\r\n  Collection." {:added "1.0", :static true} [coll] (let [ret (make-array (. Class (forName "[Ljava.lang.Object;")) (. coll (size)))] (loop [i 0 xs (seq coll)] (when xs (aset ret i (to-array (first xs))) (recur (inc i) (next xs)))) ret))

(defn macroexpand-1 "If form represents a macro form, returns its expansion,\r\n  else returns form." {:added "1.0", :static true} [form] (t/macroexpand-1 form))

(defn macroexpand "Repeatedly calls macroexpand-1 on form until it no longer\r\n  represents a macro form, then returns it.  Note neither\r\n  macroexpand-1 nor macroexpand expand macros in subforms." {:added "1.0", :static true} [form] (let [ex (macroexpand-1 form)] (if (identical? ex form) form (macroexpand ex))))

(defn create-struct "Returns a structure basis object." {:added "1.0", :static true} [& keys] (t/create-slot-map keys))

(defmacro defstruct "Same as (def name (create-struct keys...))" {:added "1.0", :static true} [name & keys] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote def)) (clojure.core/list name) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/create-struct)) keys))))))))

(defn struct-map "Returns a new structmap instance with the keys of the\r\n  structure-basis. keyvals may contain all, some or none of the basis\r\n  keys - where values are not supplied they will default to nil.\r\n  keyvals can also contain keys not in the basis." {:added "1.0", :static true} [s & inits] (t/create-struct s inits))

(defn struct "Returns a new structmap instance with the keys of the\r\n  structure-basis. vals must be supplied for basis keys in order -\r\n  where values are not supplied they will default to nil." {:added "1.0", :static true} [s & vals] (t/construct-struct s vals))

(defn accessor "Returns a fn that, given an instance of a structmap with the basis,\r\n  returns the value at the key.  The key must be in the basis. The\r\n  returned function should be (slightly) more efficient than using\r\n  get, but such use of accessors should be limited to known\r\n  performance-critical areas." {:added "1.0", :static true} [s key] (t/get-accessor s key))

(defn load-reader "Sequentially read and evaluate the set of forms contained in the\r\n  stream/file" {:added "1.0", :static true} [rdr] (t/load-reader rdr))

(defn load-string "Sequentially read and evaluate the set of forms contained in the\r\n  string" {:added "1.0", :static true} [s] (let [rdr (-> (java.io.StringReader. s) (t/line-numbering-reader))] (load-reader rdr)))

(defn set? "Returns true if x implements IPersistentSet" {:added "1.0", :static true} [x] ([x] ^{:line 228, :column 45} (satisfies? p/ISet x) x))

(defn set "Returns a set of the distinct elements of coll." {:added "1.0", :static true} [coll] (if (set? coll) (with-meta coll nil) (if (instance? p/IReduceInit coll) (persistent! (.reduce ^p/IReduceInit coll conj! (transient #{}))) (persistent! (reduce1 conj! (transient #{}) coll)))))

(defn ^{:private true, :static true} filter-key [keyfn pred amap] (loop [ret {} es (seq amap)] (if es (if (pred (keyfn (first es))) (recur (assoc ret (key (first es)) (val (first es))) (next es)) (recur ret (next es))) ret)))

(defn find-ns "Returns the namespace named by the symbol or nil if it doesn't exist." {:added "1.0", :static true} [sym] (t/find-ns sym))

(defn create-ns "Create a new namespace named by the symbol if one doesn't already\r\n  exist, returns it or the already-existing namespace of the same\r\n  name." {:added "1.0", :static true} [sym] (t/find-or-create-ns sym))

(defn remove-ns "Removes the namespace named by the symbol. Use with caution.\r\n  Cannot be used to remove the clojure namespace." {:added "1.0", :static true} [sym] (t/remove-ns sym))

(defn all-ns "Returns a sequence of all namespaces." {:added "1.0", :static true} [] (t/all-ns))

(defn the-ns "If passed a namespace, returns it. Else, when passed a symbol,\r\n  returns the namespace named by it, throwing an exception if not\r\n  found." {:added "1.0", :static true} [x] (if ([x] ^{:line 253, :column 45} (t/namespace? x) x) x (or (find-ns x) (throw (Exception. (str "No namespace: " x " found"))))))

(defn ns-name "Returns the name of the namespace, a symbol." {:added "1.0", :static true} [ns] (.getName (the-ns ns)))

(defn ns-map "Returns a map of all the mappings for the namespace." {:added "1.0", :static true} [ns] (.getMappings (the-ns ns)))

(defn ns-unmap "Removes the mappings for the symbol from the namespace." {:added "1.0", :static true} [ns sym] (.unmap (the-ns ns) sym))

(defn ns-publics "Returns a map of the public intern mappings for the namespace." {:added "1.0", :static true} [ns] (let [ns (the-ns ns)] (filter-key val (fn [v] (and ([x] ^{:line 247, :column 45} (t/var? x) v) (= ns (.ns v)) (.isPublic v))) (ns-map ns))))

(defn ns-imports "Returns a map of the import mappings for the namespace." {:added "1.0", :static true} [ns] (filter-key val (partial instance? Class) (ns-map ns)))

(defn ns-interns "Returns a map of the intern mappings for the namespace." {:added "1.0", :static true} [ns] (let [ns (the-ns ns)] (filter-key val (fn [v] (and ([x] ^{:line 247, :column 45} (t/var? x) v) (= ns (.ns v)))) (ns-map ns))))

(defn refer "refers to all public vars of ns, subject to filters.\r\n  filters can include at most one each of:\r\n\r\n  :exclude list-of-symbols\r\n  :only list-of-symbols\r\n  :rename map-of-fromsymbol-tosymbol\r\n\r\n  For each public interned var in the namespace named by the symbol,\r\n  adds a mapping from the name of the var to the var to the current\r\n  namespace.  Throws an exception if name is already mapped to\r\n  something else in the current namespace. Filters can be used to\r\n  select a subset, via inclusion or exclusion, or to provide a mapping\r\n  to a symbol different from the var's name, in order to prevent\r\n  clashes. Use :use in the ns macro in preference to calling this directly." {:added "1.0"} [ns-sym & filters] (let [ns (or (find-ns ns-sym) (throw (clojure.core/ex-info (str "No namespace: " ns-sym) {}))) fs (apply hash-map filters) nspublics (ns-publics ns) rename (or (:rename fs) {}) exclude (set (:exclude fs)) to-do (if (= :all (:refer fs)) (keys nspublics) (or (:refer fs) (:only fs) (keys nspublics)))] (when (and to-do (not (instance? p/ISequential to-do))) (throw (clojure.core/ex-info ":only/:refer value must be a sequential collection of symbols" {}))) (doseq [sym to-do] (when-not (exclude sym) (let [v (nspublics sym)] (when-not v (throw (clojure.core/ex-info "Illegal access" {}))) (. *ns* (refer (or (rename sym) sym) v)))))))

(defn ns-refers "Returns a map of the refer mappings for the namespace." {:added "1.0", :static true} [ns] (let [ns (the-ns ns)] (filter-key val (fn [v] (and ([x] ^{:line 247, :column 45} (t/var? x) v) (not= ns (.ns v)))) (ns-map ns))))

(defn alias "Add an alias in the current namespace to another\r\n  namespace. Arguments are two symbols: the alias to be used, and\r\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\r\n  to calling this directly." {:added "1.0", :static true} [alias namespace-sym] (.addAlias *ns* alias (the-ns namespace-sym)))

(defn ns-aliases "Returns a map of the aliases for the namespace." {:added "1.0", :static true} [ns] (.getAliases (the-ns ns)))

(defn ns-unalias "Removes the alias for the symbol from the namespace." {:added "1.0", :static true} [ns sym] (.removeAlias (the-ns ns) sym))

(defn take-nth "Returns a lazy seq of every nth item in coll.  Returns a stateful\r\n  transducer when no collection is provided." {:added "1.0", :static true} ([n] (fn [rf] (let [iv (volatile! -1)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [i (vswap! iv inc)] (if (zero? (rem i n)) (rf result input) result))))))) ([n coll] (lazy-seq (when-let [s (seq coll)] (cons (first s) (take-nth n (drop n s)))))))

(defn interleave "Returns a lazy seq of the first item in each coll, then the second etc." {:added "1.0", :static true} ([] ()) ([c1] (lazy-seq c1)) ([c1 c2] (lazy-seq (let [s1 (seq c1) s2 (seq c2)] (when (and s1 s2) (cons (first s1) (cons (first s2) (interleave (rest s1) (rest s2)))))))) ([c1 c2 & colls] (lazy-seq (let [ss (map seq (conj colls c2 c1))] (when (every? identity ss) (concat (map first ss) (apply interleave (map rest ss))))))))

(defn var-get "Gets the value in the var object" {:added "1.0", :static true} [x] (. x (get)))

(defn var-set "Sets the value in the var object to val. The var must be\r\n thread-locally bound." {:added "1.0", :static true} [x val] (. x (set val)))

(defmacro with-local-vars "varbinding=> symbol init-expr\r\n\r\n  Executes the exprs in a context in which the symbols are bound to\r\n  vars with per-thread bindings to the init-exprs.  The symbols refer\r\n  to the var objects themselves, and must be accessed with var-get and\r\n  var-set" {:added "1.0"} [name-vals-vec & body] (assert-args (vector? name-vals-vec) "a vector for its binding" (even? (count name-vals-vec)) "an even number of forms in binding vector") (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (interleave (take-nth 2 name-vals-vec) (repeat (quote ^{:line 749, :column 10} (t/create-dynamic-var))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/Var)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/pushThreadBindings)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/hash-map)) name-vals-vec)))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote finally)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/Var)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/popThreadBindings))))))))))))))))))))))

(defn ns-resolve "Returns the var or Class to which a symbol will be resolved in the\r\n  namespace (unless found in the environment), else nil.  Note that\r\n  if the symbol is fully qualified, the var/Class to which it resolves\r\n  need not be present in the namespace." {:added "1.0", :static true} ([ns sym] (ns-resolve ns nil sym)) ([ns env sym] (when-not (contains? env sym) (t/maybe-resolve-in (the-ns ns) sym))))

(defn resolve "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)" {:added "1.0", :static true} ([sym] (ns-resolve *ns* sym)) ([env sym] (ns-resolve *ns* env sym)))

(defn array-map "Constructs an array-map. If any keys are equal, they are handled as\r\n  if by repeated uses of assoc." {:added "1.0", :static true} ([] t/empty-map) ([& keyvals] (let [ary (to-array keyvals)] (if (odd? (alength ary)) (throw (clojure.core/ex-info (str "No value supplied for key: " (last keyvals)) {})) (t/array-map-assoc ary)))))

(defn seq-to-map-for-destructuring "Builds a map from a seq as described in\r\n  https://clojure.org/reference/special_forms#keyword-arguments" {:added "1.11"} [s] (if (next s) (t/array-map-assoc (to-array s)) (if (seq s) (first s) t/empty-map)))

(defn destructure [bindings] (let [bents (partition 2 bindings) pb (fn pb [bvec b v] (let [pvec (fn [bvec b val] (let [gvec (gensym "vec__") gseq (gensym "seq__") gfirst (gensym "first__") has-rest (some #{(quote &)} b)] (loop [ret (let [ret (conj bvec gvec val)] (if has-rest (conj ret gseq (list (quote clojure.core/seq) gvec)) ret)) n 0 bs b seen-rest? false] (if (seq bs) (let [firstb (first bs)] (cond (= firstb (quote &)) (recur (pb ret (second bs) gseq) n (nnext bs) true) (= firstb :as) (pb ret (second bs) gvec) :else (if seen-rest? (throw (clojure.core/ex-info "Unsupported binding form, only :as can follow & parameter" {})) (recur (pb (if has-rest (conj ret gfirst (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list gseq)))) gseq (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/next)) (clojure.core/list gseq))))) ret) firstb (if has-rest gfirst (list (quote clojure.core/nth) gvec n nil))) (inc n) (next bs) seen-rest?)))) ret)))) pmap (fn [bvec b v] (let [gmap (gensym "map__") gmapseq (with-meta gmap {:tag (quote p/ISeq)}) defaults (:or b)] (loop [ret (-> bvec (conj gmap) (conj v) (conj gmap) (conj (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq?)) (clojure.core/list gmap))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/next)) (clojure.core/list gmapseq))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote t/array-map-assoc)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/to-array)) (clojure.core/list gmapseq))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list gmapseq))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list gmapseq))))) (clojure.core/list (quote t/empty-map)))))))))) (clojure.core/list gmap))))) ((fn [ret] (if (:as b) (conj ret (:as b) gmap) ret)))) bes (let [transforms (reduce1 (fn [transforms mk] (if (keyword? mk) (let [mkns (namespace mk) mkn (name mk)] (cond (= mkn "keys") (assoc transforms mk (fn* [%1] (keyword (or mkns (namespace %1)) (name %1)))) (= mkn "syms") (assoc transforms mk (fn* [%1] (list (quote quote) (symbol (or mkns (namespace %1)) (name %1))))) (= mkn "strs") (assoc transforms mk str) :else transforms)) transforms)) {} (keys b))] (reduce1 (fn [bes entry] (reduce1 (fn* [%1 %2] (assoc %1 %2 ((val entry) %2))) (dissoc bes (key entry)) ((key entry) bes))) (dissoc b :as :or) transforms))] (if (seq bes) (let [bb (key (first bes)) bk (val (first bes)) local (if ([x] ^{:line 252, :column 45} (t/named? x) bb) (with-meta (symbol nil (name bb)) (meta bb)) bb) bv (if (contains? defaults local) (list (quote clojure.core/get) gmap bk (defaults local)) (list (quote clojure.core/get) gmap bk))] (recur (if (ident? bb) (-> ret (conj local bv)) (pb ret bb bv)) (next bes))) ret))))] (cond (symbol? b) (-> bvec (conj b) (conj v)) (vector? b) (pvec bvec b v) (map? b) (pmap bvec b v) :else (throw (clojure.core/ex-info (str "Unsupported binding form: " b) {}))))) process-entry (fn [bvec b] (pb bvec (first b) (second b)))] (if (every? symbol? (map first bents)) bindings (reduce1 process-entry [] bents))))

(defmacro let "binding => binding-form init-expr\r\n  binding-form => name, or destructuring-form\r\n  destructuring-form => map-destructure-form, or seq-destructure-form\r\n\r\n  Evaluates the exprs in a lexical context in which the symbols in\r\n  the binding-forms are bound to their respective init-exprs or parts\r\n  therein.\r\n\r\n  See https://clojure.org/reference/special_forms#binding-forms for\r\n  more information about destructuring." {:added "1.0", :special-form true, :forms (quote [(let [bindings*] exprs*)])} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (even? (count bindings)) "an even number of forms in binding vector") (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote let*)) (clojure.core/list (destructure bindings)) body))))

(defn ^{:private true} maybe-destructured [params body] (if (every? symbol? params) (cons params body) (loop [params params new-params (with-meta [] (meta params)) lets []] (if params (if (symbol? (first params)) (recur (next params) (conj new-params (first params)) lets) (let [gparam (gensym "p__")] (recur (next params) (conj new-params gparam) (-> lets (conj (first params)) (conj gparam))))) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list new-params) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list lets) body)))))))))))

(defmacro fn "params => positional-params*, or positional-params* & rest-param\r\n  positional-param => binding-form\r\n  rest-param => binding-form\r\n  binding-form => name, or destructuring-form\r\n\r\n  Defines a function.\r\n\r\n  See https://clojure.org/reference/special_forms#fn for more information" {:added "1.0", :special-form true, :forms (quote [(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)])} [& sigs] (let [name (if (symbol? (first sigs)) (first sigs) nil) sigs (if name (next sigs) sigs) sigs (if (vector? (first sigs)) (list sigs) (if (seq? (first sigs)) sigs (throw (clojure.core/ex-info (if (seq sigs) (str "Parameter declaration " (first sigs) " should be a vector") (str "Parameter declaration missing")) {})))) psig (fn* [sig] (when (not (seq? sig)) (throw (clojure.core/ex-info (str "Invalid signature " sig " should be a list") {}))) (let [[params & body] sig _ (when (not (vector? params)) (throw (clojure.core/ex-info (if (seq? (first sigs)) (str "Parameter declaration " params " should be a vector") (str "Invalid signature " sig " should be a list")) {}))) conds (when (and (next body) (map? (first body))) (first body)) body (if conds (next body) body) conds (or conds (meta params)) pre (:pre conds) post (:post conds) body (if post (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote %)) (clojure.core/list (if (< 1 (count body)) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) body))) (first body)))))))) (map (fn* [c] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/assert)) (clojure.core/list c))))) post) (clojure.core/list (quote %))))))))) body) body (if pre (concat (map (fn* [c] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/assert)) (clojure.core/list c))))) pre) body) body)] (maybe-destructured params body))) new-sigs (map psig sigs)] (with-meta (if name (list* (quote fn*) name new-sigs) (cons (quote fn*) new-sigs)) (meta &form))))

(defmacro loop "Evaluates the exprs in a lexical context in which the symbols in\r\n  the binding-forms are bound to their respective init-exprs or parts\r\n  therein. Acts as a recur target." {:added "1.0", :special-form true, :forms (quote [(loop [bindings*] exprs*)])} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (even? (count bindings)) "an even number of forms in binding vector") (let [db (destructure bindings)] (if (= db bindings) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote loop*)) (clojure.core/list bindings) body))) (let [vs (take-nth 2 (drop 1 bindings)) bs (take-nth 2 bindings) gs (map (fn [b] (if (symbol? b) b (gensym))) bs) bfs (reduce1 (fn [ret [b v g]] (if (symbol? b) (conj ret g v) (conj ret g v b g))) [] (map vector bs vs gs))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list bfs) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote loop*)) (clojure.core/list (vec (interleave gs gs))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (vec (interleave bs gs))) body)))))))))))))))

(defmacro when-first "bindings => x xs\r\n\r\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once" {:added "1.0"} [bindings & body] (assert-args (vector? bindings) "a vector for its binding" (= 2 (count bindings)) "exactly 2 forms in binding vector") (let [[x xs] bindings] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote xs__478__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list xs)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list x) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list (quote xs__478__auto__))))))))))) body)))))))))

(defmacro lazy-cat "Expands to code which yields a lazy sequence of the concatenation\r\n  of the supplied colls.  Each coll expr is not evaluated until it is\r\n  needed. \r\n\r\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))" {:added "1.0"} [& colls] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/concat)) (map (fn* [%1] (list (quote clojure.core/lazy-seq) %1)) colls)))))

(defmacro for "List comprehension. Takes a vector of one or more\r\n   binding-form/collection-expr pairs, each followed by zero or more\r\n   modifiers, and yields a lazy sequence of evaluations of expr.\r\n   Collections are iterated in a nested fashion, rightmost fastest,\r\n   and nested coll-exprs can refer to bindings created in prior\r\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\r\n   :while test, :when test.\r\n\r\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))" {:added "1.0"} [seq-exprs body-expr] (assert-args (vector? seq-exprs) "a vector for its binding" (even? (count seq-exprs)) "an even number of forms in binding vector") (let [to-groups (fn [seq-exprs] (reduce1 (fn [groups [k v]] (if (keyword? k) (conj (pop groups) (conj (peek groups) [k v])) (conj groups [k v]))) [] (partition 2 seq-exprs))) err (fn [& msg] (throw (clojure.core/ex-info (apply str msg) {}))) emit-bind (fn emit-bind [[[bind expr & mod-pairs] & [[_ next-expr] :as next-groups]]] (let [giter (gensym "iter__") gxs (gensym "s__") do-mod (fn do-mod [[[k v :as pair] & etc]] (cond (= k :let) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list v) (clojure.core/list (do-mod etc))))) (= k :while) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list v) (clojure.core/list (do-mod etc))))) (= k :when) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list v) (clojure.core/list (do-mod etc)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/rest)) (clojure.core/list gxs)))))))))))) (keyword? k) (err "Invalid 'for' keyword " k) next-groups (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote iterys__479__auto__)) (clojure.core/list (emit-bind next-groups)) (clojure.core/list (quote fs__480__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote iterys__479__auto__)) (clojure.core/list next-expr)))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (quote fs__480__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/concat)) (clojure.core/list (quote fs__480__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list giter) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/rest)) (clojure.core/list gxs))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/rest)) (clojure.core/list gxs)))))))))))))))) :else (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/cons)) (clojure.core/list body-expr) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list giter) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/rest)) (clojure.core/list gxs))))))))))))))] (if next-groups (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list giter) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gxs)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/lazy-seq)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gxs) (clojure.core/list gxs)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-first)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list bind) (clojure.core/list gxs)))))) (clojure.core/list (do-mod mod-pairs))))))))))))))))) (let [gi (gensym "i__") gb (gensym "b__") do-cmod (fn do-cmod [[[k v :as pair] & etc]] (cond (= k :let) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list v) (clojure.core/list (do-cmod etc))))) (= k :while) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list v) (clojure.core/list (do-cmod etc))))) (= k :when) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list v) (clojure.core/list (do-cmod etc)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list gi)))))))))))) (keyword? k) (err "Invalid 'for' keyword " k) :else (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-append)) (clojure.core/list gb) (clojure.core/list body-expr))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list gi))))))))))))))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list giter) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gxs)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/lazy-seq)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gxs) (clojure.core/list gxs)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gxs) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/seq)) (clojure.core/list gxs)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunked-seq?)) (clojure.core/list gxs))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote c__481__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-first)) (clojure.core/list gxs))))) (clojure.core/list (quote size__482__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/int)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/count)) (clojure.core/list (quote c__481__auto__)))))))))) (clojure.core/list gb) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-buffer)) (clojure.core/list (quote size__482__auto__))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gi) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/int)) (clojure.core/list 0)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list gi) (clojure.core/list (quote size__482__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list bind) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .nth)) (clojure.core/list (quote c__481__auto__)) (clojure.core/list gi)))))))))) (clojure.core/list (do-cmod mod-pairs)))))) (clojure.core/list true))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-cons)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk)) (clojure.core/list gb))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list giter) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-rest)) (clojure.core/list gxs))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk-cons)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/chunk)) (clojure.core/list gb))))) (clojure.core/list nil))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list bind) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/first)) (clojure.core/list gxs)))))))))) (clojure.core/list (do-mod mod-pairs)))))))))))))))))))))))))))))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote iter__483__auto__)) (clojure.core/list (emit-bind (to-groups seq-exprs)))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote iter__483__auto__)) (clojure.core/list (second seq-exprs)))))))))))

(defmacro comment "Ignores body, yields nil" {:added "1.0"} [& body])

(defmacro with-out-str "Evaluates exprs in a context in which *out* is bound to a fresh\r\n  StringWriter.  Returns the string created by any nested printing\r\n  calls." {:added "1.0"} [& body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote s__484__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote new)) (clojure.core/list (quote java.io.StringWriter))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/binding)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/*out*)) (clojure.core/list (quote s__484__auto__))))))) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list (quote s__484__auto__))))))))))))))

(defmacro with-in-str "Evaluates body in a context in which *in* is bound to a fresh\r\n  StringReader initialized with the string s." {:added "1.0"} [s & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/with-open)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote s__485__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/->)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote java.io.StringReader.)) (clojure.core/list s))))) (clojure.core/list (quote t/line-numbering-reader))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/binding)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/*in*)) (clojure.core/list (quote s__485__auto__))))))) body))))))))

(defn pr-str "pr to a string, returning it" {:added "1.0", :static true} [& xs] (with-out-str (apply pr xs)))

(defn prn-str "prn to a string, returning it" {:added "1.0", :static true} [& xs] (with-out-str (apply prn xs)))

(defn print-str "print to a string, returning it" {:added "1.0", :static true} [& xs] (with-out-str (apply print xs)))

(defn println-str "println to a string, returning it" {:added "1.0", :static true} [& xs] (with-out-str (apply println xs)))

^{:line 796, :column 10} (comment "JVM imports removed")

(defn ^{:private true} elide-top-frames [^Throwable ex class-name] (let [tr (.getStackTrace ex)] (doto ex (.setStackTrace (when tr (into-array StackTraceElement (drop-while (fn* [%1] (= class-name (.getClassName %1))) tr)))))))

(defn ex-info "Create an instance of ExceptionInfo, a RuntimeException subclass\r\n   that carries a map of additional data." {:added "1.4"} ([msg map] (elide-top-frames (ExceptionInfo. msg map) "clojure.core$ex_info")) ([msg map cause] (elide-top-frames (ExceptionInfo. msg map cause) "clojure.core$ex_info")))

(defn ex-data "Returns exception data (a map) if ex is an IExceptionInfo.\r\n   Otherwise returns nil." {:added "1.4"} [ex] (when (instance? IExceptionInfo ex) (.getData ^IExceptionInfo ex)))

(defn ex-message "Returns the message attached to ex if ex is a Throwable.\r\n  Otherwise returns nil." {:added "1.10"} [ex] (when (instance? Throwable ex) (.getMessage ^Throwable ex)))

(defn ex-cause "Returns the cause of ex if ex is a Throwable.\r\n  Otherwise returns nil." {:tag Throwable, :added "1.10"} [ex] (when (instance? Throwable ex) (.getCause ^Throwable ex)))

(defmacro assert "Evaluates expression x and throws an AssertionError with optional\r\n  message if x does not evaluate to logical true.\r\n\r\n  Assertion checks are omitted from compiled code if '*assert*' is\r\n  false." {:added "1.0"} ([x] (when *assert* (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-not)) (clojure.core/list x) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote new)) (clojure.core/list (quote t/AssertionError)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list "Assert failed: ") (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/pr-str)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list x)))))))))))))))))))))))))) ([x message] (when *assert* (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-not)) (clojure.core/list x) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote new)) (clojure.core/list (quote t/AssertionError)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list "Assert failed: ") (clojure.core/list message) (clojure.core/list "\n") (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/pr-str)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list x)))))))))))))))))))))))))))

(defn test "test [v] finds fn at key :test in var metadata and calls it,\r\n  presuming failure will throw exception" {:added "1.0"} [v] (let [f (:test (meta v))] (if f (do (f) :ok) :no-test)))

(defn re-pattern "Returns an instance of java.util.regex.Pattern, for use, e.g. in\r\n  re-matcher." {:added "1.0", :static true} [s] (if (instance? java.util.regex.Pattern s) s (. java.util.regex.Pattern (compile s))))

(defn re-matcher "Returns an instance of java.util.regex.Matcher, for use, e.g. in\r\n  re-find." {:added "1.0", :static true} [re s] (. re (matcher s)))

(defn re-groups "Returns the groups from the most recent match/find. If there are no\r\n  nested groups, returns a string of the entire match. If there are\r\n  nested groups, returns a vector of the groups, the first element\r\n  being the entire match." {:added "1.0", :static true} [m] (let [gc (. m (groupCount))] (if (zero? gc) (. m (group)) (loop [ret [] c 0] (if (<= c gc) (recur (conj ret (. m (group c))) (inc c)) ret)))))

(defn re-seq "Returns a lazy sequence of successive matches of pattern in string,\r\n  using java.util.regex.Matcher.find(), each such match processed with\r\n  re-groups." {:added "1.0", :static true} [re s] (let [m (re-matcher re s)] ((fn step [] (when (. m (find)) (cons (re-groups m) (lazy-seq (step))))))))

(defn re-matches "Returns the match, if any, of string to pattern, using\r\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\r\n  groups." {:added "1.0", :static true} [re s] (let [m (re-matcher re s)] (when (. m (matches)) (re-groups m))))

(defn re-find "Returns the next regex match, if any, of string to pattern, using\r\n  java.util.regex.Matcher.find().  Uses re-groups to return the\r\n  groups." {:added "1.0", :static true} ([m] (when (. m (find)) (re-groups m))) ([re s] (let [m (re-matcher re s)] (re-find m))))

(defn rand "Returns a random floating point number between 0 (inclusive) and\r\n  n (default 1) (exclusive)." {:added "1.0", :static true} ([] (. Math (random))) ([n] (* n (rand))))

(defn rand-int "Returns a random integer between 0 (inclusive) and n (exclusive)." {:added "1.0", :static true} [n] (int (rand n)))

(defmacro defn- "same as defn, yielding non-public def" {:added "1.0"} [name & decls] (list* (quote clojure.core/defn) (with-meta name (assoc (meta name) :private true)) decls))

(defn tree-seq "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\r\n   branch? must be a fn of one arg that returns true if passed a node\r\n   that can have children (but may not).  children must be a fn of one\r\n   arg that returns a sequence of the children. Will only be called on\r\n   nodes for which branch? returns true. Root is the root node of the\r\n  tree." {:added "1.0", :static true} [branch? children root] (let [walk (fn walk [node] (lazy-seq (cons node (when (branch? node) (mapcat walk (children node))))))] (walk root)))

(defn file-seq "A tree seq on java.io.Files" {:added "1.0", :static true} [dir] (tree-seq (fn [^java.io.File f] (. f (isDirectory))) (fn [^java.io.File d] (seq (. d (listFiles)))) dir))

(defn xml-seq "A tree seq on the xml elements as per xml/parse" {:added "1.0", :static true} [root] (tree-seq (complement string?) (comp seq :content) root))

(defn special-symbol? "Returns true if s names a special form" {:added "1.0", :static true} [s] (contains? t/special-symbols s))

(defn var? "Returns true if v is of type clojure.lang.Var" {:added "1.0", :static true} [v] ([x] ^{:line 247, :column 45} (t/var? x) v))

(defn subs "Returns the substring of s beginning at start inclusive, and ending\r\n  at end (defaults to length of string), exclusive." {:added "1.0", :static true} ([s start] (. s (substring start))) ([s start end] (. s (substring start end))))

(defn max-key "Returns the x for which (k x), a number, is greatest.\r\n\r\n  If there are multiple such xs, the last one is returned." {:added "1.0", :static true} ([k x] x) ([k x y] (if (> (k x) (k y)) x y)) ([k x y & more] (let [kx (k x) ky (k y) [v kv] (if (> kx ky) [x kx] [y ky])] (loop [v v kv kv more more] (if more (let [w (first more) kw (k w)] (if (>= kw kv) (recur w kw (next more)) (recur v kv (next more)))) v)))))

(defn min-key "Returns the x for which (k x), a number, is least.\r\n\r\n  If there are multiple such xs, the last one is returned." {:added "1.0", :static true} ([k x] x) ([k x y] (if (< (k x) (k y)) x y)) ([k x y & more] (let [kx (k x) ky (k y) [v kv] (if (< kx ky) [x kx] [y ky])] (loop [v v kv kv more more] (if more (let [w (first more) kw (k w)] (if (<= kw kv) (recur w kw (next more)) (recur v kv (next more)))) v)))))

(defn distinct "Returns a lazy sequence of the elements of coll with duplicates removed.\r\n  Returns a stateful transducer when no collection is provided." {:added "1.0", :static true} ([] (fn [rf] (let [seen (volatile! #{})] (fn ([] (rf)) ([result] (rf result)) ([result input] (if (contains? (clojure.core/deref seen) input) result (do (vswap! seen conj input) (rf result input)))))))) ([coll] (let [step (fn step [xs seen] (lazy-seq ((fn [[f :as xs] seen] (when-let [s (seq xs)] (if (contains? seen f) (recur (rest s) seen) (cons f (step (rest s) (conj seen f)))))) xs seen)))] (step coll #{}))))

(defn replace "Given a map of replacement pairs and a vector/collection, returns a\r\n  vector/seq with any elements = a key in smap replaced with the\r\n  corresponding val in smap.  Returns a transducer when no collection\r\n  is provided." {:added "1.0", :static true} ([smap] (map (fn* [%1] (if-let [e (find smap %1)] (val e) %1)))) ([smap coll] (if (vector? coll) (reduce1 (fn [v i] (if-let [e (find smap (nth v i))] (assoc v i (val e)) v)) coll (range (count coll))) (map (fn* [%1] (if-let [e (find smap %1)] (val e) %1)) coll))))

(defmacro dosync "Runs the exprs (in an implicit do) in a transaction that encompasses\r\n  exprs and any nested calls.  Starts a transaction if none is already\r\n  running on this thread. Any uncaught exception will abort the\r\n  transaction and flow out of dosync. The exprs may be run more than\r\n  once, but any effects on Refs will be atomic." {:added "1.0"} [& exprs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/sync)) (clojure.core/list nil) exprs))))

(defmacro with-precision "Sets the precision and rounding mode to be used for BigDecimal operations.\r\n\r\n  Usage: (with-precision 10 (/ 1M 3))\r\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\r\n\r\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\r\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP." {:added "1.0"} [precision & exprs] (let [[body rm] (if (= (first exprs) :rounding) [(next (next exprs)) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote java.math.RoundingMode)) (clojure.core/list (second exprs)))))))))] [exprs nil])] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/binding)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/*math-context*)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote java.math.MathContext.)) (clojure.core/list precision) rm))))))))) body)))))

(defn mk-bound-fn {:private true} [sc test key] (fn [e] (test (.. sc comparator (compare (. sc entryKey e) key)) 0)))

(defn subseq "sc must be a sorted collection, test(s) one of <, <=, > or\r\n  >=. Returns a seq of those entries with keys ek for\r\n  which (test (.. sc comparator (compare ek key)) 0) is true" {:added "1.0", :static true} ([sc test key] (let [include (mk-bound-fn sc test key)] (if (#{> >=} test) (when-let [[e :as s] (. sc seqFrom key true)] (if (include e) s (next s))) (take-while include (. sc seq true))))) ([sc start-test start-key end-test end-key] (when-let [[e :as s] (. sc seqFrom start-key true)] (take-while (mk-bound-fn sc end-test end-key) (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))

(defn rsubseq "sc must be a sorted collection, test(s) one of <, <=, > or\r\n  >=. Returns a reverse seq of those entries with keys ek for\r\n  which (test (.. sc comparator (compare ek key)) 0) is true" {:added "1.0", :static true} ([sc test key] (let [include (mk-bound-fn sc test key)] (if (#{< <=} test) (when-let [[e :as s] (. sc seqFrom key false)] (if (include e) s (next s))) (take-while include (. sc seq false))))) ([sc start-test start-key end-test end-key] (when-let [[e :as s] (. sc seqFrom end-key false)] (take-while (mk-bound-fn sc start-test start-key) (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))

(defn repeatedly "Takes a function of no args, presumably with side effects, and\r\n  returns an infinite (or length n if supplied) lazy sequence of calls\r\n  to it" {:added "1.0", :static true} ([f] (lazy-seq (cons (f) (repeatedly f)))) ([n f] (take n (repeatedly f))))

(defn add-classpath "DEPRECATED \r\n\r\n  Adds the url (String or URL object) to the classpath per\r\n  URLClassLoader.addURL" {:added "1.0", :deprecated "1.1"} [url] (println "WARNING: add-classpath is deprecated") (t/add-url url))

(defn hash "Returns the hash code of its argument. Note this is the hash code\r\n  consistent with =, and thus is different than .hashCode for Integer,\r\n  Short, Byte and Clojure collections." {:added "1.0", :static true} [x] (p/-hash x))

(defn mix-collection-hash "Mix final collection hash for ordered or unordered collections.\r\n   hash-basis is the combined collection hash, count is the number\r\n   of elements included in the basis. Note this is the hash code\r\n   consistent with =, different from .hashCode.\r\n   See http://clojure.org/data_structures#hash for full algorithms." {:added "1.6", :static true} ^long [^long hash-basis ^long count] (t/mix-coll-hash hash-basis count))

(defn hash-ordered-coll "Returns the hash code, consistent with =, for an external ordered\r\n   collection implementing Iterable.\r\n   See http://clojure.org/data_structures#hash for full algorithms." {:added "1.6", :static true} ^long [coll] (t/hash-ordered coll))

(defn hash-unordered-coll "Returns the hash code, consistent with =, for an external unordered\r\n   collection implementing Iterable. For maps, the iterator should\r\n   return map entries whose hash is computed as\r\n     (hash-ordered-coll [k v]).\r\n   See http://clojure.org/data_structures#hash for full algorithms." {:added "1.6", :static true} ^long [coll] (t/hash-unordered coll))

(defn interpose "Returns a lazy seq of the elements of coll separated by sep.\r\n  Returns a stateful transducer when no collection is provided." {:added "1.0", :static true} ([sep] (fn [rf] (let [started (volatile! false)] (fn ([] (rf)) ([result] (rf result)) ([result input] (if (clojure.core/deref started) (let [sepr (rf result sep)] (if (reduced? sepr) sepr (rf sepr input))) (do (vreset! started true) (rf result input)))))))) ([sep coll] (drop 1 (interleave (repeat sep) coll))))

(defmacro definline "Experimental - like defmacro, except defines a named function whose\r\n  body is the expansion, calls to which may be expanded inline as if\r\n  it were a macro. Cannot be used with variadic (&) args." {:added "1.0"} [name & decl] (let [[pre-args [args expr]] (split-with (comp not vector?) decl)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/defn)) (clojure.core/list name) pre-args (clojure.core/list args) (clojure.core/list (apply (eval (list (quote clojure.core/fn) args expr)) args)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/alter-meta!)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list name))))) (clojure.core/list (quote clojure.core/assoc)) (clojure.core/list :inline) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list name) (clojure.core/list args) (clojure.core/list expr))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list name))))))))))

(defn empty "Returns an empty collection of the same category as coll, or nil" {:added "1.0", :static true} [coll] (when ([x] ^{:line 229, :column 49} (satisfies? p/ICollection x) coll) (.empty coll)))

(defmacro amap "Maps an expression across an array a, using an index named idx, and\r\n  return value named ret, initialized to a clone of a, then setting \r\n  each element of ret to the evaluation of expr, returning the new \r\n  array ret." {:added "1.0"} [a idx ret expr] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote a__486__auto__)) (clojure.core/list a) (clojure.core/list (quote l__487__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/alength)) (clojure.core/list (quote a__486__auto__)))))) (clojure.core/list ret) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/aclone)) (clojure.core/list (quote a__486__auto__))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list idx) (clojure.core/list 0)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list idx) (clojure.core/list (quote l__487__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/aset)) (clojure.core/list ret) (clojure.core/list idx) (clojure.core/list expr))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc)) (clojure.core/list idx))))))))))))) (clojure.core/list ret)))))))))))))

(defmacro areduce "Reduces an expression across an array a, using an index named idx,\r\n  and return value named ret, initialized to init, setting ret to the \r\n  evaluation of expr at each step, returning ret." {:added "1.0"} [a idx ret init expr] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote a__488__auto__)) (clojure.core/list a) (clojure.core/list (quote l__489__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/alength)) (clojure.core/list (quote a__488__auto__))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list idx) (clojure.core/list 0) (clojure.core/list ret) (clojure.core/list init)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/<)) (clojure.core/list idx) (clojure.core/list (quote l__489__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/unchecked-inc-int)) (clojure.core/list idx))))) (clojure.core/list expr))))) (clojure.core/list ret)))))))))))))

(defn float-array "Creates an array of floats" {:added "1.0"} ([size-or-seq] (t/float-array size-or-seq)) ([size init-val-or-seq] (t/float-array size init-val-or-seq)))

(defn boolean-array "Creates an array of booleans" {:added "1.1"} ([size-or-seq] (t/boolean-array size-or-seq)) ([size init-val-or-seq] (t/boolean-array size init-val-or-seq)))

(defn byte-array "Creates an array of bytes" {:added "1.1"} ([size-or-seq] (t/byte-array size-or-seq)) ([size init-val-or-seq] (t/byte-array size init-val-or-seq)))

(defn char-array "Creates an array of chars" {:added "1.1"} ([size-or-seq] (t/char-array size-or-seq)) ([size init-val-or-seq] (t/char-array size init-val-or-seq)))

(defn short-array "Creates an array of shorts" {:added "1.1"} ([size-or-seq] (t/short-array size-or-seq)) ([size init-val-or-seq] (t/short-array size init-val-or-seq)))

(defn double-array "Creates an array of doubles" {:added "1.0"} ([size-or-seq] (t/double-array size-or-seq)) ([size init-val-or-seq] (t/double-array size init-val-or-seq)))

(defn object-array "Creates an array of objects" {:added "1.2"} ([size-or-seq] (t/object-array size-or-seq)))

(defn int-array "Creates an array of ints" {:added "1.0"} ([size-or-seq] (t/int-array size-or-seq)) ([size init-val-or-seq] (t/int-array size init-val-or-seq)))

(defn long-array "Creates an array of longs" {:added "1.0"} ([size-or-seq] (t/long-array size-or-seq)) ([size init-val-or-seq] (t/long-array size init-val-or-seq)))

(definline booleans "Casts to boolean[]" {:added "1.1"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/booleans)) (clojure.core/list xs)))))

(definline bytes "Casts to bytes[]" {:added "1.1"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/bytes)) (clojure.core/list xs)))))

(definline chars "Casts to chars[]" {:added "1.1"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/chars)) (clojure.core/list xs)))))

(definline shorts "Casts to shorts[]" {:added "1.1"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/shorts)) (clojure.core/list xs)))))

(definline floats "Casts to float[]" {:added "1.0"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/floats)) (clojure.core/list xs)))))

(definline ints "Casts to int[]" {:added "1.0"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/ints)) (clojure.core/list xs)))))

(definline doubles "Casts to double[]" {:added "1.0"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/doubles)) (clojure.core/list xs)))))

(definline longs "Casts to long[]" {:added "1.0"} [xs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote clojure.numbers)) (clojure.core/list (quote clojure.core/longs)) (clojure.core/list xs)))))

(defn bytes? "Return true if x is a byte array" {:added "1.9"} [x] (if (nil? x) false (-> x class .getComponentType (= Byte/TYPE))))

^{:line 796, :column 10} (comment "JVM imports removed")

(defn seque "Creates a queued seq on another (presumably lazy) seq s. The queued\r\n  seq will produce a concrete seq in the background, and can get up to\r\n  n items ahead of the consumer. n-or-q can be an integer n buffer\r\n  size, or an instance of java.util.concurrent BlockingQueue. Note\r\n  that reading from a seque can block if the reader gets ahead of the\r\n  producer." {:added "1.0", :static true} ([s] (seque 100 s)) ([n-or-q s] (let [^BlockingQueue q (if (instance? BlockingQueue n-or-q) n-or-q (LinkedBlockingQueue. (int n-or-q))) NIL (Object.) agt (agent (lazy-seq s)) log-error (fn [q e] (if (.offer q q) (throw e) e)) fill (fn [s] (when s (if (instance? Exception s) (log-error q s) (try (loop [[x & xs :as s] (seq s)] (if s (if (.offer q (if (nil? x) NIL x)) (recur xs) s) (when-not (.offer q q) ()))) (catch Exception e (log-error q e)))))) drain (fn drain [] (lazy-seq (let [x (.take q)] (if (identical? x q) (do (clojure.core/deref agt) nil) (do (send-off agt fill) (release-pending-sends) (cons (if (identical? x NIL) nil x) (drain)))))))] (send-off agt fill) (drain))))

(defn class? "Returns true if x is an instance of Class" {:added "1.0", :static true} [x] (instance? Class x))

(defn- is-annotation? [c] (and (class? c) (.isAssignableFrom t/Annotation c)))

(defn- is-runtime-annotation? [c] (boolean (and (is-annotation? c) (when-let [^t/Retention r (.getAnnotation c t/Retention)] (= (.value r) t/retention-runtime)))))

(defn- descriptor [c] (clojure.asm.Type/getDescriptor c))

(declare process-annotation)

(defn- add-annotation [^clojure.asm.AnnotationVisitor av name v] (cond (vector? v) (let [avec (.visitArray av name)] (doseq [vval v] (add-annotation avec "value" vval)) (.visitEnd avec)) (symbol? v) (let [ev (eval v)] (cond (instance? t/Enum ev) (.visitEnum av name (descriptor (class ev)) (str ev)) (class? ev) (.visit av name (clojure.asm.Type/getType ev)) :else (throw (clojure.core/ex-info (str "Unsupported annotation value: " v " of class " (class ev)) {})))) (seq? v) (let [[nested nv] v c (resolve nested) nav (.visitAnnotation av name (descriptor c))] (process-annotation nav nv) (.visitEnd nav)) :else (.visit av name v)))

(defn- process-annotation [av v] (if (map? v) (doseq [[k v] v] (add-annotation av (name k) v)) (add-annotation av "value" v)))

(defn- add-annotations ([visitor m] (add-annotations visitor m nil)) ([visitor m i] (doseq [[k v] m] (when (symbol? k) (when-let [c (resolve k)] (when (is-annotation? c) (let [av (if i (.visitParameterAnnotation visitor i (descriptor c) (is-runtime-annotation? c)) (.visitAnnotation visitor (descriptor c) (is-runtime-annotation? c)))] (process-annotation av v) (.visitEnd av))))))))

(defn alter-var-root "Atomically alters the root binding of var v by applying f to its\r\n  current value plus any args" {:added "1.0", :static true} [v f & args] (.alterRoot v f args))

(defn bound? "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\r\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided." {:added "1.2", :static true} [& vars] (every? (fn* [%1] (.isBound %1)) vars))

(defn thread-bound? "Returns true if all of the vars provided as arguments have thread-local bindings.\r\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided." {:added "1.2", :static true} [& vars] (every? (fn* [%1] (.getThreadBinding %1)) vars))

(defn make-hierarchy "Creates a hierarchy object for use with derive, isa? etc." {:added "1.0", :static true} [] {:parents {}, :descendants {}, :ancestors {}})

(def ^{:private true} global-hierarchy (make-hierarchy))

(defn not-empty "If coll is empty, returns nil, else coll" {:added "1.0", :static true} [coll] (when (seq coll) coll))

(defn bases "Returns the immediate superclass and direct interfaces of c, if any" {:added "1.0", :static true} [c] (when c (let [i (seq (.getInterfaces c)) s (.getSuperclass c)] (if s (cons s i) i))))

(defn supers "Returns the immediate and indirect superclasses and interfaces of c, if any" {:added "1.0", :static true} [class] (loop [ret (set (bases class)) cs ret] (if (seq cs) (let [c (first cs) bs (bases c)] (recur (into1 ret bs) (into1 (disj cs c) bs))) (not-empty ret))))

(defn isa? "Returns true if (= child parent), or child is directly or indirectly derived from\r\n  parent, either via a Java type inheritance relationship or a\r\n  relationship established via derive. h must be a hierarchy obtained\r\n  from make-hierarchy, if not supplied defaults to the global\r\n  hierarchy" {:added "1.0"} ([child parent] (isa? global-hierarchy child parent)) ([h child parent] (or (= child parent) (and (class? parent) (class? child) (. parent isAssignableFrom child)) (contains? ((:ancestors h) child) parent) (and (class? child) (some (fn* [%1] (contains? ((:ancestors h) %1) parent)) (supers child))) (and (vector? parent) (vector? child) (= (count parent) (count child)) (loop [ret true i 0] (if (or (not ret) (= i (count parent))) ret (recur (isa? h (child i) (parent i)) (inc i))))))))

(defn parents "Returns the immediate parents of tag, either via a Java type\r\n  inheritance relationship or a relationship established via derive. h\r\n  must be a hierarchy obtained from make-hierarchy, if not supplied\r\n  defaults to the global hierarchy" {:added "1.0"} ([tag] (parents global-hierarchy tag)) ([h tag] (not-empty (let [tp (get (:parents h) tag)] (if (class? tag) (into1 (set (bases tag)) tp) tp)))))

(defn ancestors "Returns the immediate and indirect parents of tag, either via a Java type\r\n  inheritance relationship or a relationship established via derive. h\r\n  must be a hierarchy obtained from make-hierarchy, if not supplied\r\n  defaults to the global hierarchy" {:added "1.0"} ([tag] (ancestors global-hierarchy tag)) ([h tag] (not-empty (let [ta (get (:ancestors h) tag)] (if (class? tag) (let [superclasses (set (supers tag))] (reduce1 into1 superclasses (cons ta (map (fn* [%1] (get (:ancestors h) %1)) superclasses)))) ta)))))

(defn descendants "Returns the immediate and indirect children of tag, through a\r\n  relationship established via derive. h must be a hierarchy obtained\r\n  from make-hierarchy, if not supplied defaults to the global\r\n  hierarchy. Note: does not work on Java type inheritance\r\n  relationships." {:added "1.0"} ([tag] (descendants global-hierarchy tag)) ([h tag] (if (class? tag) (throw (clojure.core/ex-info "Can't get descendants of classes" {})) (not-empty (get (:descendants h) tag)))))

(defn derive "Establishes a parent/child relationship between parent and\r\n  tag. Parent must be a namespace-qualified symbol or keyword and\r\n  child can be either a namespace-qualified symbol or keyword or a\r\n  class. h must be a hierarchy obtained from make-hierarchy, if not\r\n  supplied defaults to, and modifies, the global hierarchy." {:added "1.0"} ([tag parent] (assert (namespace parent)) (assert (or (class? tag) (and ([x] ^{:line 252, :column 45} (t/named? x) tag) (namespace tag)))) (alter-var-root (var global-hierarchy) derive tag parent) nil) ([h tag parent] (assert (not= tag parent)) (assert (or (class? tag) ([x] ^{:line 252, :column 45} (t/named? x) tag))) (assert ([x] ^{:line 252, :column 45} (t/named? x) parent)) (let [tp (:parents h) td (:descendants h) ta (:ancestors h) tf (fn [m source sources target targets] (reduce1 (fn [ret k] (assoc ret k (reduce1 conj (get targets k #{}) (cons target (targets target))))) m (cons source (sources source))))] (or (when-not (contains? (tp tag) parent) (when (contains? (ta tag) parent) (throw (Exception. (print-str tag "already has" parent "as ancestor")))) (when (contains? (ta parent) tag) (throw (Exception. (print-str "Cyclic derivation:" parent "has" tag "as ancestor")))) {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent)), :ancestors (tf (:ancestors h) tag td parent ta), :descendants (tf (:descendants h) parent ta tag td)}) h))))

(declare flatten)

(defn underive "Removes a parent/child relationship between parent and\r\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\r\n  supplied defaults to, and modifies, the global hierarchy." {:added "1.0"} ([tag parent] (alter-var-root (var global-hierarchy) underive tag parent) nil) ([h tag parent] (let [parentMap (:parents h) childsParents (if (parentMap tag) (disj (parentMap tag) parent) #{}) newParents (if (not-empty childsParents) (assoc parentMap tag childsParents) (dissoc parentMap tag)) deriv-seq (flatten (map (fn* [%1] (cons (key %1) (interpose (key %1) (val %1)))) (seq newParents)))] (if (contains? (parentMap tag) parent) (reduce1 (fn* [%1 %2] (apply derive %1 %2)) (make-hierarchy) (partition 2 deriv-seq)) h))))

(defn distinct? "Returns true if no two of the arguments are =" {:added "1.0", :static true} ([x] true) ([x y] (not (= x y))) ([x y & more] (if (not= x y) (loop [s #{x y} [x & etc :as xs] more] (if xs (if (contains? s x) false (recur (conj s x) etc)) true)) false)))

(defn resultset-seq "Creates and returns a lazy sequence of structmaps corresponding to\r\n  the rows in the java.sql.ResultSet rs" {:added "1.0"} [^java.sql.ResultSet rs] (let [rsmeta (. rs (getMetaData)) idxs (range 1 (inc (. rsmeta (getColumnCount)))) keys (map (comp keyword (fn* [%1] (.toLowerCase %1))) (map (fn [i] (. rsmeta (getColumnLabel i))) idxs)) check-keys (or (apply distinct? keys) (throw (Exception. "ResultSet must have unique column labels"))) row-struct (apply create-struct keys) row-values (fn [] (map (fn [i] (. rs (getObject i))) idxs)) rows (fn thisfn [] (when (. rs (next)) (cons (apply struct row-struct (row-values)) (lazy-seq (thisfn)))))] (rows)))

(defn iterator-seq "Returns a seq on a java.util.Iterator. Note that most collections\r\n  providing iterators implement Iterable and thus support seq directly.\r\n  Seqs cache values, thus iterator-seq should not be used on any\r\n  iterator that repeatedly returns the same mutable object." {:added "1.0", :static true} [iter] (t/chunk-iterator-seq iter))

(defn enumeration-seq "Returns a seq on a java.util.Enumeration" {:added "1.0", :static true} [e] (t/enumeration-seq e))

(defn format "Formats a string using java.lang.String.format, see java.util.Formatter for format\r\n  string syntax" {:added "1.0", :static true} [fmt & args] (String/format fmt (to-array args)))

(defn printf "Prints formatted output, as per format" {:added "1.0", :static true} [fmt & args] (print (apply format fmt args)))

(declare gen-class)

(defmacro with-loading-context [& body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (quote loading__490__auto__)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/Var)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/pushThreadBindings)) (clojure.core/list (clojure.core/apply clojure.core/array-map (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote t/current-loader)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .getClassLoader)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .getClass)) (clojure.core/list (clojure.core/with-meta (quote loading__490__auto__) (clojure.core/apply clojure.core/array-map (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list :tag) (clojure.core/list (quote Object))))))))))))))))))))))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote finally)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .)) (clojure.core/list (quote t/Var)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/popThreadBindings))))))))))))))))))))))))))

(defmacro ns "Sets *ns* to the namespace named by name (unevaluated), creating it\r\n  if needed.  references can be zero or more of: (:refer-clojure ...)\r\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\r\n  with the syntax of refer-clojure/require/use/import/load/gen-class\r\n  respectively, except the arguments are unevaluated and need not be\r\n  quoted. (:gen-class ...), when supplied, defaults to :name\r\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\r\n  :init-impl-ns true. All options of gen-class are\r\n  supported. The :gen-class directive is ignored when not\r\n  compiling. If :gen-class is not supplied, when compiled only an\r\n  nsname__init.class will be generated. If :refer-clojure is not used, a\r\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\r\n  individual calls to in-ns/require/use/import:\r\n\r\n  (ns foo.bar\r\n    (:refer-clojure :exclude [ancestors printf])\r\n    (:require (clojure.contrib sql combinatorics))\r\n    (:use (my.lib this that))\r\n    (:import (java.util Date Timer Random)\r\n             (java.sql Connection Statement)))" {:arglists (quote ([name docstring? attr-map? references*])), :added "1.0"} [name & references] (let [process-reference (fn [[kname & args]] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (symbol "clojure.core" (clojure.core/name kname))) (map (fn* [%1] (list (quote quote) %1)) args))))) docstring (when (string? (first references)) (first references)) references (if docstring (next references) references) name (if docstring (vary-meta name assoc :doc docstring) name) metadata (when (map? (first references)) (first references)) references (if metadata (next references) references) name (if metadata (vary-meta name merge metadata) name) gen-class-clause (first (filter (fn* [%1] (= :gen-class (first %1))) references)) gen-class-call (when gen-class-clause (list* (quote portabilize-core-v2/gen-class) :name (.replace (str name) \- \_) :impl-ns name :main true (next gen-class-clause))) references (remove (fn* [%1] (= :gen-class (first %1))) references) name-metadata (meta name)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/in-ns)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name))))))))) (when name-metadata (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .resetMeta)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote t/find-ns)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name))))))))) (clojure.core/list name-metadata))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/with-loading-context)) (when gen-class-call (list gen-class-call)) (when (and (not= name (quote clojure.core)) (not-any? (fn* [%1] (= :refer-clojure (first %1))) references)) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/refer)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list (quote clojure.core)))))))))))))) (map process-reference references))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .equals)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list (quote clojure.core)))))))))) (clojure.core/list nil) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote do)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/dosync)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/commute)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/deref)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list (quote clojure.core/*loaded-libs*)))))))))) (clojure.core/list (quote clojure.core/conj)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list name))))))))))))) (clojure.core/list nil))))))))))))))

(defmacro refer-clojure "Same as (refer 'clojure.core <filters>)" {:added "1.0"} [& filters] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/refer)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote quote)) (clojure.core/list (quote clojure.core)))))) filters))))

(defmacro defonce "defs name to have the root value of the expr iff the named var has no root value,\r\n  else expr is unevaluated" {:added "1.0"} [name expr] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote v__491__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote def)) (clojure.core/list name)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when-not)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote .hasRoot)) (clojure.core/list (quote v__491__auto__)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote def)) (clojure.core/list name) (clojure.core/list expr)))))))))))))

(defonce ^{:private true, :doc "A ref to a sorted set of symbols representing loaded libs", :dynamic true} *loaded-libs* (ref (sorted-set)))

(defonce ^{:private true, :doc "A stack of paths currently being loaded by this thread", :dynamic true} *pending-paths* ())

(defonce ^{:private true, :doc "True while a verbose load is pending", :dynamic true} *loading-verbosely* false)

(defn- throw-if "Throws a CompilerException with a message if pred is true" [pred fmt & args] (when pred (let [message (apply format fmt args) exception (Exception. message) raw-trace (.getStackTrace exception) boring? (fn* [%1] (not= (.getMethodName %1) "doInvoke")) trace (into-array StackTraceElement (drop 2 (drop-while boring? raw-trace)))] (.setStackTrace exception trace) (throw (t/compiler-exception *file* (.deref t/current-line) (.deref t/current-column) exception)))))

(defn- libspec? "Returns true if x is a libspec" [x] (or (symbol? x) (and (vector? x) (or (nil? (second x)) (keyword? (second x))))))

(defn- prependss "Prepends a symbol or a seq to coll" [x coll] (if (symbol? x) (cons x coll) (concat x coll)))

(defn- root-resource "Returns the root directory path for a lib" {} [lib] (str \/ (.. (name lib) (replace \- \_) (replace \. \/))))

(defn- root-directory "Returns the root resource path for a lib" [lib] (let [d (root-resource lib)] (subs d 0 (.lastIndexOf d "/"))))

(def ^{:redef true, :declared true} load)

(defn- load-one "Loads a lib given its name. If need-ns, ensures that the associated\r\n  namespace exists after loading. If require, records the load so any\r\n  duplicate loads can be skipped." [lib need-ns require] (load (root-resource lib)) (throw-if (and need-ns (not (find-ns lib))) "namespace '%s' not found after loading '%s'" lib (root-resource lib)) (when require (dosync (commute *loaded-libs* conj lib))))

(defn- load-all "Loads a lib given its name and forces a load of any libs it directly or\r\n  indirectly loads. If need-ns, ensures that the associated namespace\r\n  exists after loading. If require, records the load so any duplicate loads\r\n  can be skipped." [lib need-ns require] (dosync (commute *loaded-libs* (fn* [%1 %2] (reduce1 conj %1 %2)) (binding [*loaded-libs* (ref (sorted-set))] (load-one lib need-ns require) (clojure.core/deref *loaded-libs*)))))

(defn- load-lib "Loads a lib with options" [prefix lib & options] (throw-if (and prefix (pos? (.indexOf (name lib) (int \.)))) "Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods" (name lib) prefix) (let [lib (if prefix (symbol (str prefix \. lib)) lib) opts (apply hash-map options) {:keys [as reload reload-all require use verbose as-alias]} opts loaded (contains? (clojure.core/deref *loaded-libs*) lib) need-ns (or as use) load (cond reload-all load-all reload load-one (not loaded) (cond need-ns load-one as-alias (fn [lib _need _require] (create-ns lib)) :else load-one)) filter-opts (select-keys opts (quote (:exclude :only :rename :refer))) undefined-on-entry (not (find-ns lib))] (binding [*loading-verbosely* (or *loading-verbosely* verbose)] (if load (try (load lib need-ns require) (catch Exception e (when undefined-on-entry (remove-ns lib)) (throw e))) (throw-if (and need-ns (not (find-ns lib))) "namespace '%s' not found" lib)) (when (and need-ns *loading-verbosely*) (printf "(clojure.core/in-ns '%s)\n" (ns-name *ns*))) (when as (when *loading-verbosely* (printf "(clojure.core/alias '%s '%s)\n" as lib)) (alias as lib)) (when as-alias (when *loading-verbosely* (printf "(clojure.core/alias '%s '%s)\n" as-alias lib)) (alias as-alias lib)) (when (or use (:refer filter-opts)) (when *loading-verbosely* (printf "(clojure.core/refer '%s" lib) (doseq [opt filter-opts] (printf " %s '%s" (key opt) (print-str (val opt)))) (printf ")\n")) (apply refer lib (mapcat seq filter-opts))))))

(defn- load-libs "Loads libs, interpreting libspecs, prefix lists, and flags for\r\n  forwarding to load-lib" [& args] (let [flags (filter keyword? args) opts (interleave flags (repeat true)) args (filter (complement keyword?) args)] (let [supported #{:as-alias :use :as :require :verbose :reload :reload-all :refer} unsupported (seq (remove supported flags))] (throw-if unsupported (apply str "Unsupported option(s) supplied: " (interpose \, unsupported)))) (throw-if (not (seq args)) "Nothing specified to load") (doseq [arg args] (if (libspec? arg) (apply load-lib nil (prependss arg opts)) (let [[prefix & args] arg] (throw-if (nil? prefix) "prefix cannot be nil") (doseq [arg args] (apply load-lib prefix (prependss arg opts))))))))

(defn- check-cyclic-dependency "Detects and rejects non-trivial cyclic load dependencies. The\r\n  exception message shows the dependency chain with the cycle\r\n  highlighted. Ignores the trivial case of a file attempting to load\r\n  itself because that can occur when a gen-class'd class loads its\r\n  implementation." [path] (when (some #{path} (rest *pending-paths*)) (let [pending (map (fn* [%1] (if (= %1 path) (str "[ " %1 " ]") %1)) (cons path *pending-paths*)) chain (apply str (interpose "->" pending))] (throw-if true "Cyclic load dependency: %s" chain))))

(defn require "Loads libs, skipping any that are already loaded. Each argument is\r\n  either a libspec that identifies a lib, a prefix list that identifies\r\n  multiple libs whose names share a common prefix, or a flag that modifies\r\n  how all the identified libs are loaded. Use :require in the ns macro\r\n  in preference to calling this directly.\r\n\r\n  Libs\r\n\r\n  A 'lib' is a named set of resources in classpath whose contents define a\r\n  library of Clojure code. Lib names are symbols and each lib is associated\r\n  with a Clojure namespace and a Java package that share its name. A lib's\r\n  name also locates its root directory within classpath using Java's\r\n  package name to classpath-relative path mapping. All resources in a lib\r\n  should be contained in the directory structure under its root directory.\r\n  All definitions a lib makes should be in its associated namespace.\r\n\r\n  'require loads a lib by loading its root resource. The root resource path\r\n  is derived from the lib name in the following manner:\r\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\r\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\r\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\r\n  root resource should contain code to create the lib's\r\n  namespace (usually by using the ns macro) and load any additional\r\n  lib resources.\r\n\r\n  Libspecs\r\n\r\n  A libspec is a lib name or a vector containing a lib name followed by\r\n  options expressed as sequential keywords and arguments.\r\n\r\n  Recognized options:\r\n  :as takes a symbol as its argument and makes that symbol an alias to the\r\n    lib's namespace in the current namespace.\r\n  :as-alias takes a symbol as its argument and aliases like :as, however\r\n    the lib will not be loaded. If the lib has not been loaded, a new\r\n    empty namespace will be created (as with create-ns).\r\n  :refer takes a list of symbols to refer from the namespace or the :all\r\n    keyword to bring in all public vars.\r\n\r\n  Prefix Lists\r\n\r\n  It's common for Clojure code to depend on several libs whose names have\r\n  the same prefix. When specifying libs, prefix lists can be used to reduce\r\n  repetition. A prefix list contains the shared prefix followed by libspecs\r\n  with the shared prefix removed from the lib names. After removing the\r\n  prefix, the names that remain must not contain any periods.\r\n\r\n  Flags\r\n\r\n  A flag is a keyword.\r\n  Recognized flags: :reload, :reload-all, :verbose\r\n  :reload forces loading of all the identified libs even if they are\r\n    already loaded (has no effect on libspecs using :as-alias)\r\n  :reload-all implies :reload and also forces loading of all libs that the\r\n    identified libs directly or indirectly load via require or use\r\n    (has no effect on libspecs using :as-alias)\r\n  :verbose triggers printing information about each load, alias, and refer\r\n\r\n  Example:\r\n\r\n  The following would load the libraries clojure.zip and clojure.set\r\n  abbreviated as 's'.\r\n\r\n  (require '(clojure zip [set :as s]))" {:added "1.0"} [& args] (apply load-libs :require args))

(defn- serialized-require "Like 'require', but serializes loading.\r\n  Interim function preferred over 'require' for known asynchronous loads.\r\n  Future changes may make these equivalent." {:added "1.10"} [& args] (locking t/require-lock (apply require args)))

(defn requiring-resolve "Resolves namespace-qualified sym per 'resolve'. If initial resolve\r\nfails, attempts to require sym's namespace and retries." {:added "1.10"} [sym] (if (qualified-symbol? sym) (or (resolve sym) (do (-> sym namespace symbol serialized-require) (resolve sym))) (throw (clojure.core/ex-info (str "Not a qualified symbol: " sym) {}))))

(defn use "Like 'require, but also refers to each lib's namespace using\r\n  clojure.core/refer. Use :use in the ns macro in preference to calling\r\n  this directly.\r\n\r\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\r\n  The arguments and semantics for :exclude, :only, and :rename are the same\r\n  as those documented for clojure.core/refer." {:added "1.0"} [& args] (apply load-libs :require :use args))

(defn loaded-libs "Returns a sorted set of symbols naming the currently loaded libs" {:added "1.0"} [] (clojure.core/deref *loaded-libs*))

(defn load "Loads Clojure code from resources in classpath. A path is interpreted as\r\n  classpath-relative if it begins with a slash or relative to the root\r\n  directory for the current namespace otherwise." {:redef true, :added "1.0"} [& paths] (doseq [path paths] (let [path (if (.startsWith path "/") path (str (root-directory (ns-name *ns*)) \/ path))] (when *loading-verbosely* (printf "(clojure.core/load \"%s\")\n" path) (flush)) (check-cyclic-dependency path) (when-not (= path (first *pending-paths*)) (binding [*pending-paths* (conj *pending-paths* path)] (t/load-resource (.substring path 1)))))))

(defn compile "Compiles the namespace named by the symbol lib into a set of\r\n  classfiles. The source for the lib must be in a proper\r\n  classpath-relative directory. The output files will go into the\r\n  directory specified by *compile-path*, and that directory too must\r\n  be in the classpath." {:added "1.0"} [lib] (binding [*compile-files* true] (load-one lib true true)) lib)

(defn get-in "Returns the value in a nested associative structure,\r\n  where ks is a sequence of keys. Returns nil if the key\r\n  is not present, or the not-found value if supplied." {:added "1.2", :static true} ([m ks] (reduce1 get m ks)) ([m ks not-found] (loop [sentinel (Object.) m m ks (seq ks)] (if ks (let [m (get m (first ks) sentinel)] (if (identical? sentinel m) not-found (recur sentinel m (next ks)))) m))))

(defn assoc-in "Associates a value in a nested associative structure, where ks is a\r\n  sequence of keys and v is the new value and returns a new nested structure.\r\n  If any levels do not exist, hash-maps will be created." {:added "1.0", :static true} [m [k & ks] v] (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))

(defn update-in "'Updates' a value in a nested associative structure, where ks is a\r\n  sequence of keys and f is a function that will take the old value\r\n  and any supplied args and return the new value, and returns a new\r\n  nested structure.  If any levels do not exist, hash-maps will be\r\n  created." {:added "1.0", :static true} ([m ks f & args] (let [up (fn up [m ks f args] (let [[k & ks] ks] (if ks (assoc m k (up (get m k) ks f args)) (assoc m k (apply f (get m k) args)))))] (up m ks f args))))

(defn update "'Updates' a value in an associative structure, where k is a\r\n  key and f is a function that will take the old value\r\n  and any supplied args and return the new value, and returns a new\r\n  structure.  If the key does not exist, nil is passed as the old value." {:added "1.7", :static true} ([m k f] (assoc m k (f (get m k)))) ([m k f x] (assoc m k (f (get m k) x))) ([m k f x y] (assoc m k (f (get m k) x y))) ([m k f x y z] (assoc m k (f (get m k) x y z))) ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))

(defn coll? "Returns true if x implements IPersistentCollection" {:added "1.0", :static true} [x] ([x] ^{:line 229, :column 49} (satisfies? p/ICollection x) x))

(defn list? "Returns true if x implements IPersistentList" {:added "1.0", :static true} [x] ([x] ^{:line 230, :column 45} (t/list? x) x))

(defn seqable? "Return true if the seq function is supported for x" {:added "1.9"} [x] (t/seqable? x))

(defn ifn? "Returns true if x implements IFn. Note that many data structures\r\n  (e.g. sets and maps) implement IFn" {:added "1.0", :static true} [x] (instance? p/IFn x))

(defn fn? "Returns true if x implements Fn, i.e. is an object created via fn." {:added "1.0", :static true} [x] ([x] ^{:line 237, :column 45} (satisfies? p/IFn x) x))

(defn associative? "Returns true if coll implements Associative" {:added "1.0", :static true} [coll] ([x] ^{:line 239, :column 45} (satisfies? p/IAssociative x) coll))

(defn sequential? "Returns true if coll implements Sequential" {:added "1.0", :static true} [coll] (instance? p/ISequential coll))

(defn sorted? "Returns true if coll implements Sorted" {:added "1.0", :static true} [coll] ([x] ^{:line 241, :column 45} (satisfies? p/ISorted x) coll))

(defn counted? "Returns true if coll implements count in constant time" {:added "1.0", :static true} [coll] ([x] ^{:line 234, :column 45} (satisfies? p/ICounted x) coll))

(defn empty? "Returns true if coll has no items. To check the emptiness of a seq,\r\n  please use the idiom (seq x) rather than (not (empty? x))" {:added "1.0", :static true} [coll] (if (counted? coll) (zero? (count coll)) (not (seq coll))))

(defn reversible? "Returns true if coll implements Reversible" {:added "1.0", :static true} [coll] ([x] ^{:line 240, :column 45} (satisfies? p/IReversible x) coll))

(defn indexed? "Return true if coll implements Indexed, indicating efficient lookup by index" {:added "1.9"} [coll] ([x] ^{:line 235, :column 45} (satisfies? p/IIndexed x) coll))

(def ^{:doc "bound in a repl thread to the most recent value printed", :added "1.0", :dynamic true} *1)

(def ^{:doc "bound in a repl thread to the second most recent value printed", :added "1.0", :dynamic true} *2)

(def ^{:doc "bound in a repl thread to the third most recent value printed", :added "1.0", :dynamic true} *3)

(def ^{:doc "bound in a repl thread to the most recent exception caught by the repl", :added "1.0", :dynamic true} *e)

(def ^{:doc "Bound to true in a repl thread", :added "1.12", :dynamic true} *repl* false)

(defn trampoline "trampoline can be used to convert algorithms requiring mutual\r\n  recursion without stack consumption. Calls f with supplied args, if\r\n  any. If f returns a fn, calls that fn with no arguments, and\r\n  continues to repeat, until the return value is not a fn, then\r\n  returns that non-fn value. Note that if you want to return a fn as a\r\n  final value, you must wrap it in some data structure and unpack it\r\n  after trampoline returns." {:added "1.0", :static true} ([f] (let [ret (f)] (if (fn? ret) (recur ret) ret))) ([f & args] (trampoline (fn* [] (apply f args)))))

(defn intern "Finds or creates a var named by the symbol name in the namespace\r\n  ns (which can be a symbol or a namespace), setting its root binding\r\n  to val if supplied. The namespace must exist. The var will adopt any\r\n  metadata from the name symbol.  Returns the var." {:added "1.0", :static true} ([ns name] (let [v (t/intern-var (the-ns ns) name)] (when (meta name) (.setMeta v (meta name))) v)) ([ns name val] (let [v (t/intern-var (the-ns ns) name val)] (when (meta name) (.setMeta v (meta name))) v)))

(defmacro while "Repeatedly executes body while test expression is true. Presumes\r\n  some side-effect will cause test to become false/nil. Returns nil" {:added "1.0"} [test & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/loop)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/when)) (clojure.core/list test) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote recur))))))))))))))

(defn memoize "Returns a memoized version of a referentially transparent function. The\r\n  memoized version of the function keeps a cache of the mapping from arguments\r\n  to results and, when calls with the same arguments are repeated often, has\r\n  higher performance at the expense of higher memory use." {:added "1.0", :static true} [f] (let [mem (atom {})] (fn [& args] (if-let [e (find (clojure.core/deref mem) args)] (val e) (let [ret (apply f args)] (swap! mem assoc args ret) ret)))))

(defmacro condp "Takes a binary predicate, an expression, and a set of clauses.\r\n  Each clause can take the form of either:\r\n\r\n  test-expr result-expr\r\n\r\n  test-expr :>> result-fn\r\n\r\n  Note :>> is an ordinary keyword.\r\n\r\n  For each clause, (pred test-expr expr) is evaluated. If it returns\r\n  logical true, the clause is a match. If a binary clause matches, the\r\n  result-expr is returned, if a ternary clause matches, its result-fn,\r\n  which must be a unary function, is called with the result of the\r\n  predicate as its argument, the result of that call being the return\r\n  value of condp. A single default expression can follow the clauses,\r\n  and its value will be returned if no clause matches. If no default\r\n  expression is provided and no clause matches, an\r\n  IllegalArgumentException is thrown." {:added "1.0"} [pred expr & clauses] (let [gpred (gensym "pred__") gexpr (gensym "expr__") emit (fn emit [pred expr args] (let [[[a b c :as clause] more] (split-at (if (= :>> (second args)) 3 2) args) n (count clause)] (cond (= 0 n) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote ex-info)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list "No matching clause: ") (clojure.core/list expr)))))))))))) (= 1 n) a (= 2 n) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list pred) (clojure.core/list a) (clojure.core/list expr))))) (clojure.core/list b) (clojure.core/list (emit pred expr more))))) :else (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/if-let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote p__492__auto__)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list pred) (clojure.core/list a) (clojure.core/list expr)))))))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list c) (clojure.core/list (quote p__492__auto__)))))) (clojure.core/list (emit pred expr more))))))))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list gpred) (clojure.core/list pred) (clojure.core/list gexpr) (clojure.core/list expr)))))) (clojure.core/list (emit gpred gexpr clauses)))))))

(alter-meta! (var *agent*) assoc :added "1.0")

(alter-meta! (var in-ns) assoc :added "1.0")

(alter-meta! (var load-file) assoc :added "1.0")

(defmacro add-doc-and-meta {:private true} [name docstring meta] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/alter-meta!)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote var)) (clojure.core/list name))))) (clojure.core/list (quote clojure.core/merge)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/assoc)) (clojure.core/list meta) (clojure.core/list :doc) (clojure.core/list docstring)))))))))

(add-doc-and-meta *file* "The path of the file being evaluated, as a String.\r\n\r\n  When there is no file, e.g. in the REPL, the value is not defined." {:added "1.0"})

(add-doc-and-meta *command-line-args* "A sequence of the supplied command line arguments, or nil if\r\n  none were supplied" {:added "1.0"})

(add-doc-and-meta *warn-on-reflection* "When set to true, the compiler will emit warnings when reflection is\r\n  needed to resolve Java method calls or field accesses.\r\n\r\n  Defaults to false." {:added "1.0"})

(add-doc-and-meta *compile-path* "Specifies the directory where 'compile' will write out .class\r\n  files. This directory must be in the classpath for 'compile' to\r\n  work.\r\n\r\n  Defaults to \"classes\"" {:added "1.0"})

(add-doc-and-meta *compile-files* "Set to true when compiling files, false otherwise." {:added "1.0"})

(add-doc-and-meta *unchecked-math* "While bound to true, compilations of +, -, *, inc, dec and the\r\n  coercions will be done without overflow checks. While bound\r\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\r\n  when compilation uses boxed math. Default: false." {:added "1.3"})

(add-doc-and-meta *compiler-options* "A map of keys to options.\r\n  Note, when binding dynamically make sure to merge with previous value.\r\n  Supported options:\r\n  :elide-meta - a collection of metadata keys to elide during compilation.\r\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\r\n  :direct-linking - set to true to use direct static invocation of functions, rather than vars\r\n    Note that call sites compiled with direct linking will not be affected by var redefinition.\r\n    Use ^:redef (or ^:dynamic) on a var to prevent direct linking and allow redefinition.\r\n  See https://clojure.org/reference/compilation for more information." {:added "1.4"})

(add-doc-and-meta *ns* "A clojure.lang.Namespace object representing the current namespace." {:added "1.0"})

(add-doc-and-meta *in* "A java.io.Reader object representing standard input for read operations.\r\n\r\n  Defaults to System/in, wrapped in a LineNumberingPushbackReader" {:added "1.0"})

(add-doc-and-meta *out* "A java.io.Writer object representing standard output for print operations.\r\n\r\n  Defaults to System/out, wrapped in an OutputStreamWriter" {:added "1.0"})

(add-doc-and-meta *err* "A java.io.Writer object representing standard error for print operations.\r\n\r\n  Defaults to System/err, wrapped in a PrintWriter" {:added "1.0"})

(add-doc-and-meta *flush-on-newline* "When set to true, output will be flushed whenever a newline is printed.\r\n\r\n  Defaults to true." {:added "1.0"})

(add-doc-and-meta *print-meta* "If set to logical true, when printing an object, its metadata will also\r\n  be printed in a form that can be read back by the reader.\r\n\r\n  Defaults to false." {:added "1.0"})

(add-doc-and-meta *print-dup* "When set to logical true, objects will be printed in a way that preserves\r\n  their type when read in later.\r\n\r\n  Defaults to false." {:added "1.0"})

(add-doc-and-meta *print-readably* "When set to logical false, strings and characters will be printed with\r\n  non-alphanumeric characters converted to the appropriate escape sequences.\r\n\r\n  Defaults to true" {:added "1.0"})

(add-doc-and-meta *read-eval* "Defaults to true (or value specified by system property, see below)\r\n  ***This setting implies that the full power of the reader is in play,\r\n  including syntax that can cause code to execute. It should never be\r\n  used with untrusted sources. See also: clojure.edn/read.***\r\n\r\n  When set to logical false in the thread-local binding,\r\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\r\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\r\n\r\n  The default binding can be controlled by the system property\r\n  'clojure.read.eval' System properties can be set on the command line\r\n  like this:\r\n\r\n  java -Dclojure.read.eval=false ...\r\n\r\n  The system property can also be set to 'unknown' via\r\n  -Dclojure.read.eval=unknown, in which case the default binding\r\n  is :unknown and all reads will fail in contexts where *read-eval*\r\n  has not been explicitly bound to either true or false. This setting\r\n  can be a useful diagnostic tool to ensure that all of your reads\r\n  occur in considered contexts. You can also accomplish this in a\r\n  particular scope by binding *read-eval* to :unknown\r\n  " {:added "1.0"})

(add-doc-and-meta *assert* "When set to logical false, 'assert' will omit assertion checks in\r\n  compiled code. Defaults to true." {:added "1.0"})

(defn future? "Returns true if x is a future" {:added "1.1", :static true} [x] (instance? java.util.concurrent.Future x))

(defn future-done? "Returns true if future f is done" {:added "1.1", :static true} [f] (.isDone f))

(defmacro letfn "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\r\n\r\n  Takes a vector of function specs and a body, and generates a set of\r\n  bindings of functions to their names. All of the names are available\r\n  in all of the definitions of the functions, as well as the body." {:added "1.0", :forms (quote [(letfn [fnspecs*] exprs*)]), :special-form true, :url nil} [fnspecs & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote letfn*)) (clojure.core/list (vec (interleave (map first fnspecs) (map (fn* [%1] (cons (quote clojure.core/fn) %1)) fnspecs)))) body))))

(defn fnil "Takes a function f, and returns a function that calls f, replacing\r\n  a nil first argument to f with the supplied value x. Higher arity\r\n  versions can replace arguments in the second and third\r\n  positions (y, z). Note that the function f can take any number of\r\n  arguments, not just the one(s) being nil-patched." {:added "1.2", :static true} ([f x] (fn ([a] (f (if (nil? a) x a))) ([a b] (f (if (nil? a) x a) b)) ([a b c] (f (if (nil? a) x a) b c)) ([a b c & ds] (apply f (if (nil? a) x a) b c ds)))) ([f x y] (fn ([a b] (f (if (nil? a) x a) (if (nil? b) y b))) ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c)) ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds)))) ([f x y z] (fn ([a b] (f (if (nil? a) x a) (if (nil? b) y b))) ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c))) ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))

(defn zipmap "Returns a map with the keys mapped to the corresponding vals." {:added "1.0", :static true} [keys vals] (loop [map (transient {}) ks (seq keys) vs (seq vals)] (if (and ks vs) (recur (assoc! map (first ks) (first vs)) (next ks) (next vs)) (persistent! map))))

(defn- shift-mask [shift mask x] (-> x (bit-shift-right shift) (bit-and mask)))

(def ^{:private true} max-mask-bits 13)

(def ^{:private true} max-switch-table-size (bit-shift-left 1 max-mask-bits))

(defn- maybe-min-hash "takes a collection of hashes and returns [shift mask] or nil if none found" [hashes] (first (filter (fn [[s m]] (apply distinct? (map (fn* [%1] (shift-mask s m %1)) hashes))) (for [mask (map (fn* [%1] (dec (bit-shift-left 1 %1))) (range 1 (inc max-mask-bits))) shift (range 0 31)] [shift mask]))))

(defn- case-map "Transforms a sequence of test constants and a corresponding sequence of then\r\n  expressions into a sorted map to be consumed by case*. The form of the map\r\n  entries are {(case-f test) [(test-f test) then]}." [case-f test-f tests thens] (into1 (sorted-map) (zipmap (map case-f tests) (map vector (map test-f tests) thens))))

(defn- fits-table? "Returns true if the collection of ints can fit within the\r\n  max-table-switch-size, false otherwise." [ints] (< (- (apply max (seq ints)) (apply min (seq ints))) max-switch-table-size))

(defn- prep-ints "Takes a sequence of int-sized test constants and a corresponding sequence of\r\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\r\n  case-map is a map of int case values to [test then] tuples, and switch-type\r\n  is either :sparse or :compact." [tests thens] (if (fits-table? tests) [0 0 (case-map int int tests thens) :compact] (let [[shift mask] (or (maybe-min-hash (map int tests)) [0 0])] (if (zero? mask) [0 0 (case-map int int tests thens) :sparse] [shift mask (case-map (fn* [%1] (shift-mask shift mask (int %1))) int tests thens) :compact]))))

(defn- merge-hash-collisions "Takes a case expression, default expression, and a sequence of test constants\r\n  and a corresponding sequence of then expressions. Returns a tuple of\r\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\r\n  input test constants with the same hash is replaced with a single test\r\n  constant (the case int), and their respective thens are combined into:\r\n  (condp = expr\r\n    test-1 then-1\r\n    ...\r\n    test-n then-n\r\n    default).\r\n  The skip-check is a set of case ints for which post-switch equivalence\r\n  checking must not be done (the cases holding the above condp thens)." [expr-sym default tests thens] (let [buckets (loop [m {} ks tests vs thens] (if (and ks vs) (recur (update m (p/-hash (first ks)) (fnil conj []) [(first ks) (first vs)]) (next ks) (next vs)) m)) assoc-multi (fn [m h bucket] (let [testexprs (mapcat (fn [kv] [(list (quote quote) (first kv)) (second kv)]) bucket) expr (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/condp)) (clojure.core/list (quote clojure.core/=)) (clojure.core/list expr-sym) testexprs (clojure.core/list default))))] (assoc m h expr))) hmap (reduce1 (fn [m [h bucket]] (if (== 1 (count bucket)) (assoc m (ffirst bucket) (second (first bucket))) (assoc-multi m h bucket))) {} buckets) skip-check (->> buckets (filter (fn* [%1] (< 1 (count (second %1))))) (map first) (into1 #{}))] [(keys hmap) (vals hmap) skip-check]))

(defn- prep-hashes "Takes a sequence of test constants and a corresponding sequence of then\r\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\r\n  where case-map is a map of int case values to [test then] tuples, switch-type\r\n  is either :sparse or :compact, and skip-check is a set of case ints for which\r\n  post-switch equivalence checking must not be done (occurs with hash\r\n  collisions)." [expr-sym default tests thens] (let [hashcode (fn* [%1] (p/-hash %1)) hashes (into1 #{} (map hashcode tests))] (if (== (count tests) (count hashes)) (if (fits-table? hashes) [0 0 (case-map hashcode identity tests thens) :compact] (let [[shift mask] (or (maybe-min-hash hashes) [0 0])] (if (zero? mask) [0 0 (case-map hashcode identity tests thens) :sparse] [shift mask (case-map (fn* [%1] (shift-mask shift mask (hashcode %1))) identity tests thens) :compact]))) (let [[tests thens skip-check] (merge-hash-collisions expr-sym default tests thens) [shift mask case-map switch-type] (prep-hashes expr-sym default tests thens) skip-check (if (zero? mask) skip-check (into1 #{} (map (fn* [%1] (shift-mask shift mask %1)) skip-check)))] [shift mask case-map switch-type skip-check]))))

(defmacro case "Takes an expression, and a set of clauses.\r\n\r\n  Each clause can take the form of either:\r\n\r\n  test-constant result-expr\r\n\r\n  (test-constant1 ... test-constantN)  result-expr\r\n\r\n  The test-constants are not evaluated. They must be compile-time\r\n  literals, and need not be quoted.  If the expression is equal to a\r\n  test-constant, the corresponding result-expr is returned. A single\r\n  default expression can follow the clauses, and its value will be\r\n  returned if no clause matches. If no default expression is provided\r\n  and no clause matches, an IllegalArgumentException is thrown.\r\n\r\n  Unlike cond and condp, case does a constant-time dispatch, the\r\n  clauses are not considered sequentially.  All manner of constant\r\n  expressions are acceptable in case, including numbers, strings,\r\n  symbols, keywords, and (Clojure) composites thereof. Note that since\r\n  lists are used to group multiple constants that map to the same\r\n  expression, a vector can be used to match a list if needed. The\r\n  test-constants need not be all of the same type." {:added "1.2"} [e & clauses] (let [ge (with-meta (gensym) {}) default (if (odd? (count clauses)) (last clauses) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote throw)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote ex-info)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/str)) (clojure.core/list "No matching clause: ") (clojure.core/list ge)))))))))))))] (if (> 2 (count clauses)) (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list ge) (clojure.core/list e)))))) (clojure.core/list default)))) (let [pairs (partition 2 clauses) assoc-test (fn assoc-test [m test expr] (if (contains? m test) (throw (clojure.core/ex-info (str "Duplicate case test constant: " test) {})) (assoc m test expr))) pairs (reduce1 (fn [m [test expr]] (if (seq? test) (reduce1 (fn* [%1 %2] (assoc-test %1 %2 expr)) m test) (assoc-test m test expr))) {} pairs) tests (keys pairs) thens (vals pairs) mode (cond (every? (fn* [%1] (and (integer? %1) (<= Integer/MIN_VALUE %1 Integer/MAX_VALUE))) tests) :ints (every? keyword? tests) :identity :else :hashes)] (condp = mode :ints (let [[shift mask imap switch-type] (prep-ints tests thens)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list ge) (clojure.core/list e)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote case*)) (clojure.core/list ge) (clojure.core/list shift) (clojure.core/list mask) (clojure.core/list default) (clojure.core/list imap) (clojure.core/list switch-type) (clojure.core/list :int))))))))) :hashes (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list ge) (clojure.core/list e)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote case*)) (clojure.core/list ge) (clojure.core/list shift) (clojure.core/list mask) (clojure.core/list default) (clojure.core/list imap) (clojure.core/list switch-type) (clojure.core/list :hash-equiv) (clojure.core/list skip-check))))))))) :identity (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list ge) (clojure.core/list e)))))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote case*)) (clojure.core/list ge) (clojure.core/list shift) (clojure.core/list mask) (clojure.core/list default) (clojure.core/list imap) (clojure.core/list switch-type) (clojure.core/list :hash-identity) (clojure.core/list skip-check))))))))))))))

(alter-meta! (find-ns (quote clojure.core)) assoc :doc "Fundamental library of the Clojure language")

(load "core_proxy")

(load "core_print")

(load "genclass")

(load "core_deftype")

(load "core/protocols")

(load "gvec")

(defn stream-reduce! "Works like reduce but takes a java.util.stream.BaseStream as its source.\r\n  Honors 'reduced', is a terminal operation on the stream" {:added "1.12"} ([f s] (clojure.core.protocols/iterator-reduce! (.iterator s) f)) ([f init s] (clojure.core.protocols/iterator-reduce! (.iterator s) f init)))

(defn stream-seq! "Takes a java.util.stream.BaseStream instance s and returns a seq of its\r\n  contents. This is a terminal operation on the stream." {:added "1.12"} [stream] (iterator-seq (.iterator stream)))

(defn stream-transduce! "Works like transduce but takes a java.util.stream.BaseStream as its source.\r\n  This is a terminal operation on the stream." {:added "1.12"} ([xform f stream] (stream-transduce! xform f (f) stream)) ([xform f init stream] (let [f (xform f) ret (stream-reduce! f init stream)] (f ret))))

(defn stream-into! "Returns a new coll consisting of coll with all of the items of the\r\n  stream conjoined. This is a terminal operation on the stream." {:added "1.12"} ([to stream] (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) to) (with-meta (persistent! (stream-reduce! conj! (transient to) stream)) (meta to)) (stream-reduce! conj to stream))) ([to xform stream] (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) to) (with-meta (persistent! (stream-transduce! xform conj! (transient to) stream)) (meta to)) (stream-transduce! xform conj to stream))))

(defmacro ^{:private true} when-class [class-name & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote try)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote Class/forName)) (clojure.core/list class-name))))) body (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote catch)) (clojure.core/list (quote t/ClassNotFoundException)) (clojure.core/list (quote ___493__auto__))))))))))

(when-class "java.sql.Timestamp" (load "instant"))

(defprotocol Inst (inst-ms* [inst]))

(extend-protocol Inst java.util.Date (inst-ms* [inst] (.getTime inst)))

(defn inst-ms "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT" {:added "1.9"} [inst] (inst-ms* inst))

(defn inst? "Return true if x satisfies Inst" {:added "1.9"} [x] (satisfies? Inst x))

(extend-protocol clojure.core/Inst java.time.Instant (inst-ms* [inst] (.toEpochMilli ^java.time.Instant inst)))

(load "uuid")

(defn uuid? "Return true if x is a java.util.UUID" {:added "1.9"} [x] (instance? java.util.UUID x))

(defn random-uuid {:doc "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\r\n\r\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", :added "1.11"} [] (java.util.UUID/randomUUID))

(defn reduce "f should be a function of 2 arguments. If val is not supplied,\r\n  returns the result of applying f to the first 2 items in coll, then\r\n  applying f to that result and the 3rd item, etc. If coll contains no\r\n  items, f must accept no arguments as well, and reduce returns the\r\n  result of calling f with no arguments.  If coll has only 1 item, it\r\n  is returned and f is not called.  If val is supplied, returns the\r\n  result of applying f to val and the first item in coll, then\r\n  applying f to that result and the 2nd item, etc. If coll contains no\r\n  items, returns val and f is not called." {:added "1.0"} ([f coll] (if ([x] ^{:line 255, :column 45} (satisfies? p/IReduce x) coll) (.reduce coll f) (clojure.core.protocols/coll-reduce coll f))) ([f val coll] (if (instance? p/IReduceInit coll) (.reduce ^p/IReduceInit coll f val) (clojure.core.protocols/coll-reduce coll f val))))

(extend-protocol clojure.core.protocols/IKVReduce nil (kv-reduce [_ f init] init) Object (kv-reduce [amap f init] (reduce (fn [ret me] (f ret (.getKey me) (.getValue me))) init amap)) p/IKVReduce (kv-reduce [amap f init] (.kvreduce amap f init)))

(defn reduce-kv "Reduces an associative collection. f should be a function of 3\r\n  arguments. Returns the result of applying f to init, the first key\r\n  and the first value in coll, then applying f to that result and the\r\n  2nd key and value, etc. If coll contains no entries, returns init\r\n  and f is not called. Note that reduce-kv is supported on vectors,\r\n  where the keys will be the ordinals." {:added "1.4"} ([f init coll] (clojure.core.protocols/kv-reduce coll f init)))

(defn completing "Takes a reducing function f of 2 args and returns a fn suitable for\r\n  transduce by adding an arity-1 signature that calls cf (default -\r\n  identity) on the result argument." {:added "1.7"} ([f] (completing f identity)) ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))

(defn transduce "reduce with a transformation of f (xf). If init is not\r\n  supplied, (f) will be called to produce it. f should be a reducing\r\n  step function that accepts both 1 and 2 arguments, if it accepts\r\n  only 2 you can add the arity-1 with 'completing'. Returns the result\r\n  of applying (the transformed) xf to init and the first item in coll,\r\n  then applying xf to that result and the 2nd item, etc. If coll\r\n  contains no items, returns init and f is not called. Note that\r\n  certain transforms may inject or skip items." {:added "1.7"} ([xform f coll] (transduce xform f (f) coll)) ([xform f init coll] (let [f (xform f) ret (if (instance? p/IReduceInit coll) (.reduce ^p/IReduceInit coll f init) (clojure.core.protocols/coll-reduce coll f init))] (f ret))))

(defn into "Returns a new coll consisting of to with all of the items of\r\n  from conjoined. A transducer may be supplied.\r\n  (into x) returns x. (into) returns []." {:added "1.0", :static true} ([] []) ([to] to) ([to from] (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) to) (with-meta (persistent! (reduce conj! (transient to) from)) (meta to)) (reduce conj to from))) ([to xform from] (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) to) (let [tm (meta to) rf (fn ([coll] (-> (persistent! coll) (with-meta tm))) ([coll v] (conj! coll v)))] (transduce xform rf (transient to) from)) (transduce xform conj to from))))

(defn mapv "Returns a vector consisting of the result of applying f to the\r\n  set of first items of each coll, followed by applying f to the set\r\n  of second items in each coll, until any one of the colls is\r\n  exhausted.  Any remaining items in other colls are ignored. Function\r\n  f should accept number-of-colls arguments." {:added "1.4", :static true} ([f coll] (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll) persistent!)) ([f c1 c2] (into [] (map f c1 c2))) ([f c1 c2 c3] (into [] (map f c1 c2 c3))) ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))

(defn filterv "Returns a vector of the items in coll for which\r\n  (pred item) returns logical true. pred must be free of side-effects." {:added "1.4", :static true} [pred coll] (-> (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll) persistent!))

(require (quote [clojure.java.io :as jio]))

(defn- normalize-slurp-opts [opts] (if (string? (first opts)) (do (println "WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc).") [:encoding (first opts)]) opts))

(defn slurp "Opens a reader on f and reads all its contents, returning a string.\r\n  See clojure.java.io/reader for a complete list of supported arguments." {:added "1.0"} ([f & opts] (let [opts (normalize-slurp-opts opts) sw (java.io.StringWriter.)] (with-open [^java.io.Reader r (apply jio/reader f opts)] (jio/copy r sw) (.toString sw)))))

(defn spit "Opposite of slurp.  Opens f with writer, writes content, then\r\n  closes f. Options passed to clojure.java.io/writer." {:added "1.2"} [f content & options] (with-open [^java.io.Writer w (apply jio/writer f options)] (.write w (str content))))

(defn future-call "Takes a function of no args and yields a future object that will\r\n  invoke the function in another thread, and will cache the result and\r\n  return it on all subsequent calls to deref/@. If the computation has\r\n  not yet finished, calls to deref/@ will block, unless the variant\r\n  of deref with timeout is used. See also - realized?." {:added "1.1", :static true} [f] (let [f (binding-conveyor-fn f) fut (.submit t/solo-executor ^Callable f)] (reify p/IDeref (deref [_] (deref-future fut)) p/IBlockingDeref (deref [_ timeout-ms timeout-val] (deref-future fut timeout-ms timeout-val)) p/IPending (isRealized [_] (.isDone fut)) java.util.concurrent.Future (get [_] (.get fut)) (get [_ timeout unit] (.get fut timeout unit)) (isCancelled [_] (.isCancelled fut)) (isDone [_] (.isDone fut)) (cancel [_ interrupt?] (.cancel fut interrupt?)))))

(defmacro future "Takes a body of expressions and yields a future object that will\r\n  invoke the body in another thread, and will cache the result and\r\n  return it on all subsequent calls to deref/@. If the computation has\r\n  not yet finished, calls to deref/@ will block, unless the variant of\r\n  deref with timeout is used. See also - realized?." {:added "1.1"} [& body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/future-call)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (clojure.core/with-meta (quote ^{:once true} fn*) (clojure.core/apply clojure.core/array-map (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list :once) (clojure.core/list true))))))) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) body))))))))

(defn future-cancel "Cancels the future, if possible." {:added "1.1", :static true} [f] (.cancel f true))

(defn future-cancelled? "Returns true if future f is cancelled" {:added "1.1", :static true} [f] (.isCancelled f))

(defn pmap "Like map, except f is applied in parallel. Semi-lazy in that the\r\n  parallel computation stays ahead of the consumption, but doesn't\r\n  realize the entire result unless required. Only useful for\r\n  computationally intensive functions where the time of f dominates\r\n  the coordination overhead." {:added "1.0", :static true} ([f coll] (let [n (+ 2 (.. Runtime getRuntime availableProcessors)) rets (map (fn* [%1] (future (f %1))) coll) step (fn step [[x & xs :as vs] fs] (lazy-seq (if-let [s (seq fs)] (cons (deref x) (step xs (rest s))) (map deref vs))))] (step rets (drop n rets)))) ([f coll & colls] (let [step (fn step [cs] (lazy-seq (let [ss (map seq cs)] (when (every? identity ss) (cons (map first ss) (step (map rest ss)))))))] (pmap (fn* [%1] (apply f %1)) (step (cons coll colls))))))

(defn pcalls "Executes the no-arg fns in parallel, returning a lazy sequence of\r\n  their values" {:added "1.0", :static true} [& fns] (pmap (fn* [%1] (%1)) fns))

(defmacro pvalues "Returns a lazy sequence of the values of the exprs, which are\r\n  evaluated in parallel" {:added "1.0", :static true} [& exprs] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote portabilize-core-v2/pcalls)) (map (fn* [%1] (list (quote clojure.core/fn) [] %1)) exprs)))))

(let [properties (with-open [version-stream (.getResourceAsStream (t/base-loader) "clojure/version.properties")] (doto (new java.util.Properties) (.load version-stream))) version-string (.getProperty properties "version") [_ major minor incremental qualifier snapshot] (re-matches #"(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9_]+))?(?:-(SNAPSHOT))?" version-string) clojure-version {:major (Integer/valueOf major), :minor (Integer/valueOf minor), :incremental (Integer/valueOf incremental), :qualifier (if (= qualifier "SNAPSHOT") nil qualifier)}] (def ^{:dynamic true} *clojure-version* (if (.contains version-string "SNAPSHOT") (p/-assoc clojure-version :interim true) clojure-version)))

(add-doc-and-meta *clojure-version* "The version info for Clojure core, as a map containing :major :minor \r\n  :incremental and :qualifier keys. Feature releases may increment \r\n  :minor and/or :major, bugfix releases will increment :incremental. \r\n  Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\"" {:added "1.0"})

(defn clojure-version "Returns clojure version as a printable string." {:added "1.0"} [] (str (:major *clojure-version*) "." (:minor *clojure-version*) (when-let [i (:incremental *clojure-version*)] (str "." i)) (when-let [q (:qualifier *clojure-version*)] (when (pos? (count q)) (str "-" q))) (when (:interim *clojure-version*) "-SNAPSHOT")))

(defn promise "Returns a promise object that can be read with deref/@, and set,\r\n  once only, with deliver. Calls to deref/@ prior to delivery will\r\n  block, unless the variant of deref with timeout is used. All\r\n  subsequent derefs will return the same delivered value without\r\n  blocking. See also - realized?." {:added "1.1", :static true} [] (let [d (java.util.concurrent.CountDownLatch. 1) v (atom d)] (reify p/IDeref (deref [_] (.await d) (clojure.core/deref v)) p/IBlockingDeref (deref [_ timeout-ms timeout-val] (if (.await d timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS) (clojure.core/deref v) timeout-val)) p/IPending (isRealized [this] (zero? (.getCount d))) p/IFn (invoke [this x] (when (and (pos? (.getCount d)) (compare-and-set! v d x)) (.countDown d) this)))))

(defn deliver "Delivers the supplied value to the promise, releasing any pending\r\n  derefs. A subsequent call to deliver on a promise will have no effect." {:added "1.1", :static true} [promise val] (promise val))

(defn flatten "Takes any nested combination of sequential things (lists, vectors,\r\n  etc.) and returns their contents as a single, flat lazy sequence.\r\n  (flatten nil) returns an empty sequence." {:added "1.2", :static true} [x] (filter (complement sequential?) (rest (tree-seq sequential? seq x))))

(defn group-by "Returns a map of the elements of coll keyed by the result of\r\n  f on each element. The value at each key will be a vector of the\r\n  corresponding elements, in the order they appeared in coll." {:added "1.2", :static true} [f coll] (persistent! (reduce (fn [ret x] (let [k (f x)] (assoc! ret k (conj (get ret k []) x)))) (transient {}) coll)))

(defn partition-by "Applies f to each value in coll, splitting it each time f returns a\r\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\r\n   transducer when no collection is provided." {:added "1.2", :static true} ([f] (fn [rf] (let [a (java.util.ArrayList.) pv (volatile! :portabilize-core-v2/none)] (fn ([] (rf)) ([result] (let [result (if (.isEmpty a) result (let [v (vec (.toArray a))] (.clear a) (unreduced (rf result v))))] (rf result))) ([result input] (let [pval (clojure.core/deref pv) val (f input)] (vreset! pv val) (if (or (identical? pval :portabilize-core-v2/none) (= val pval)) (do (.add a input) result) (let [v (vec (.toArray a))] (.clear a) (let [ret (rf result v)] (when-not (reduced? ret) (.add a input)) ret))))))))) ([f coll] (lazy-seq (when-let [s (seq coll)] (let [fst (first s) fv (f fst) run (cons fst (take-while (fn* [%1] (= fv (f %1))) (next s)))] (cons run (partition-by f (lazy-seq (drop (count run) s)))))))))

(defn frequencies "Returns a map from distinct items in coll to the number of times\r\n  they appear." {:added "1.2", :static true} [coll] (persistent! (reduce (fn [counts x] (assoc! counts x (inc (get counts x 0)))) (transient {}) coll)))

(defn reductions "Returns a lazy seq of the intermediate values of the reduction (as\r\n  per reduce) of coll by f, starting with init." {:added "1.2"} ([f coll] (lazy-seq (if-let [s (seq coll)] (reductions f (first s) (rest s)) (list (f))))) ([f init coll] (if (reduced? init) (list (clojure.core/deref init)) (cons init (lazy-seq (when-let [s (seq coll)] (reductions f (f init (first s)) (rest s))))))))

(defn rand-nth "Return a random element of the (sequential) collection. Will have\r\n  the same performance characteristics as nth for the given\r\n  collection." {:added "1.2", :static true} [coll] (nth coll (rand-int (count coll))))

(defn partition-all "Returns a lazy sequence of lists like partition, but may include\r\n  partitions with fewer than n items at the end.  Returns a stateful\r\n  transducer when no collection is provided." {:added "1.2", :static true} ([^long n] (fn [rf] (let [a (java.util.ArrayList. n)] (fn ([] (rf)) ([result] (let [result (if (.isEmpty a) result (let [v (vec (.toArray a))] (.clear a) (unreduced (rf result v))))] (rf result))) ([result input] (.add a input) (if (= n (.size a)) (let [v (vec (.toArray a))] (.clear a) (rf result v)) result)))))) ([n coll] (partition-all n n coll)) ([n step coll] (lazy-seq (when-let [s (seq coll)] (let [seg (doall (take n s))] (cons seg (partition-all n step (nthrest s step))))))))

(defn splitv-at "Returns a vector of [(into [] (take n) coll) (drop n coll)]" {:added "1.12"} [n coll] [(into [] (take n) coll) (drop n coll)])

(defn partitionv "Returns a lazy sequence of vectors of n items each, at offsets step\r\n  apart. If step is not supplied, defaults to n, i.e. the partitions\r\n  do not overlap. If a pad collection is supplied, use its elements as\r\n  necessary to complete last partition upto n items. In case there are\r\n  not enough padding elements, return a partition with less than n items." {:added "1.12"} ([n coll] (partitionv n n coll)) ([n step coll] (lazy-seq (when-let [s (seq coll)] (let [p (into [] (take n) s)] (when (= n (count p)) (cons p (partitionv n step (nthrest s step)))))))) ([n step pad coll] (lazy-seq (when-let [s (seq coll)] (let [p (into [] (take n) s)] (if (= n (count p)) (cons p (partitionv n step pad (nthrest s step))) (list (into [] (take n) (concat p pad)))))))))

(defn partitionv-all "Returns a lazy sequence of vector partitions, but may include\r\n  partitions with fewer than n items at the end.\r\n  Returns a stateful transducer when no collection is provided." {:added "1.12"} ([n] (partition-all n)) ([n coll] (partitionv-all n n coll)) ([n step coll] (lazy-seq (when-let [s (seq coll)] (let [seg (into [] (take n) coll)] (cons seg (partitionv-all n step (drop step s))))))))

(defn shuffle "Return a random permutation of coll" {:added "1.2", :static true} [coll] (let [al (java.util.ArrayList. coll)] (java.util.Collections/shuffle al) (t/vec (.toArray al))))

(defn map-indexed "Returns a lazy sequence consisting of the result of applying f to 0\r\n  and the first item of coll, followed by applying f to 1 and the second\r\n  item in coll, etc, until coll is exhausted. Thus function f should\r\n  accept 2 arguments, index and item. Returns a stateful transducer when\r\n  no collection is provided." {:added "1.2", :static true} ([f] (fn [rf] (let [i (volatile! -1)] (fn ([] (rf)) ([result] (rf result)) ([result input] (rf result (f (vswap! i inc) input))))))) ([f coll] (letfn [(mapi [idx coll] (lazy-seq (when-let [s (seq coll)] (if (chunked-seq? s) (let [c (chunk-first s) size (int (count c)) b (chunk-buffer size)] (dotimes [i size] (chunk-append b (f (+ idx i) (.nth c i)))) (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s)))) (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))] (mapi 0 coll))))

(defn keep "Returns a lazy sequence of the non-nil results of (f item). Note,\r\n  this means false return values will be included.  f must be free of\r\n  side-effects.  Returns a transducer when no collection is provided." {:added "1.2", :static true} ([f] (fn [rf] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [v (f input)] (if (nil? v) result (rf result v))))))) ([f coll] (lazy-seq (when-let [s (seq coll)] (if (chunked-seq? s) (let [c (chunk-first s) size (count c) b (chunk-buffer size)] (dotimes [i size] (let [x (f (.nth c i))] (when-not (nil? x) (chunk-append b x)))) (chunk-cons (chunk b) (keep f (chunk-rest s)))) (let [x (f (first s))] (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))

(defn keep-indexed "Returns a lazy sequence of the non-nil results of (f index item). Note,\r\n  this means false return values will be included.  f must be free of\r\n  side-effects.  Returns a stateful transducer when no collection is\r\n  provided." {:added "1.2", :static true} ([f] (fn [rf] (let [iv (volatile! -1)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [i (vswap! iv inc) v (f i input)] (if (nil? v) result (rf result v)))))))) ([f coll] (letfn [(keepi [idx coll] (lazy-seq (when-let [s (seq coll)] (if (chunked-seq? s) (let [c (chunk-first s) size (count c) b (chunk-buffer size)] (dotimes [i size] (let [x (f (+ idx i) (.nth c i))] (when-not (nil? x) (chunk-append b x)))) (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s)))) (let [x (f idx (first s))] (if (nil? x) (keepi (inc idx) (rest s)) (cons x (keepi (inc idx) (rest s)))))))))] (keepi 0 coll))))

(defn bounded-count "If coll is counted? returns its count, else will count at most the first n\r\n  elements of coll using its seq" {:added "1.9"} [n coll] (if (counted? coll) (count coll) (loop [i 0 s (seq coll)] (if (and s (< i n)) (recur (inc i) (next s)) i))))

(defn every-pred "Takes a set of predicates and returns a function f that returns true if all of its\r\n  composing predicates return a logical true value against all of its arguments, else it returns\r\n  false. Note that f is short-circuiting in that it will stop execution on the first\r\n  argument that triggers a logical false result against the original predicates." {:added "1.3"} ([p] (fn ep1 ([] true) ([x] (boolean (p x))) ([x y] (boolean (and (p x) (p y)))) ([x y z] (boolean (and (p x) (p y) (p z)))) ([x y z & args] (boolean (and (ep1 x y z) (every? p args)))))) ([p1 p2] (fn ep2 ([] true) ([x] (boolean (and (p1 x) (p2 x)))) ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y)))) ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))) ([x y z & args] (boolean (and (ep2 x y z) (every? (fn* [%1] (and (p1 %1) (p2 %1))) args)))))) ([p1 p2 p3] (fn ep3 ([] true) ([x] (boolean (and (p1 x) (p2 x) (p3 x)))) ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y) (p3 x) (p3 y)))) ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z) (p3 x) (p3 y) (p3 z)))) ([x y z & args] (boolean (and (ep3 x y z) (every? (fn* [%1] (and (p1 %1) (p2 %1) (p3 %1))) args)))))) ([p1 p2 p3 & ps] (let [ps (list* p1 p2 p3 ps)] (fn epn ([] true) ([x] (every? (fn* [%1] (%1 x)) ps)) ([x y] (every? (fn* [%1] (and (%1 x) (%1 y))) ps)) ([x y z] (every? (fn* [%1] (and (%1 x) (%1 y) (%1 z))) ps)) ([x y z & args] (boolean (and (epn x y z) (every? (fn* [%1] (every? %1 args)) ps))))))))

(defn some-fn "Takes a set of predicates and returns a function f that returns the first logical true value\r\n  returned by one of its composing predicates against any of its arguments, else it returns\r\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\r\n  argument that triggers a logical true result against the original predicates." {:added "1.3"} ([p] (fn sp1 ([] nil) ([x] (p x)) ([x y] (or (p x) (p y))) ([x y z] (or (p x) (p y) (p z))) ([x y z & args] (or (sp1 x y z) (some p args))))) ([p1 p2] (fn sp2 ([] nil) ([x] (or (p1 x) (p2 x))) ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y))) ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))) ([x y z & args] (or (sp2 x y z) (some (fn* [%1] (or (p1 %1) (p2 %1))) args))))) ([p1 p2 p3] (fn sp3 ([] nil) ([x] (or (p1 x) (p2 x) (p3 x))) ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y) (p3 x) (p3 y))) ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z) (p3 x) (p3 y) (p3 z))) ([x y z & args] (or (sp3 x y z) (some (fn* [%1] (or (p1 %1) (p2 %1) (p3 %1))) args))))) ([p1 p2 p3 & ps] (let [ps (list* p1 p2 p3 ps)] (fn spn ([] nil) ([x] (some (fn* [%1] (%1 x)) ps)) ([x y] (some (fn* [%1] (or (%1 x) (%1 y))) ps)) ([x y z] (some (fn* [%1] (or (%1 x) (%1 y) (%1 z))) ps)) ([x y z & args] (or (spn x y z) (some (fn* [%1] (some %1 args)) ps)))))))

(defn- ^{:dynamic true} assert-valid-fdecl "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn." [fdecl] (when (empty? fdecl) (throw (clojure.core/ex-info "Parameter declaration missing" {}))) (let [argdecls (map (fn* [%1] (if (seq? %1) (first %1) (throw (clojure.core/ex-info (if (seq? (first fdecl)) (str "Invalid signature \"" %1 "\" should be a list") (str "Parameter declaration \"" %1 "\" should be a vector")) {})))) fdecl) bad-args (seq (remove (fn* [%1] (vector? %1)) argdecls))] (when bad-args (throw (clojure.core/ex-info (str "Parameter declaration \"" (first bad-args) "\" should be a vector") {})))))

(defn with-redefs-fn "Temporarily redefines Vars during a call to func.  Each val of\r\n  binding-map will replace the root value of its key which must be\r\n  a Var.  After func is called with no args, the root values of all\r\n  the Vars will be set back to their old values.  These temporary\r\n  changes will be visible in all threads.  Useful for mocking out\r\n  functions during testing." {:added "1.3"} [binding-map func] (let [root-bind (fn [m] (doseq [[a-var a-val] m] (.bindRoot a-var a-val))) old-vals (zipmap (keys binding-map) (map (fn* [%1] (.getRawRoot %1)) (keys binding-map)))] (try (root-bind binding-map) (func) (finally (root-bind old-vals)))))

(defmacro with-redefs "binding => var-symbol temp-value-expr\r\n\r\n  Temporarily redefines Vars while executing the body.  The\r\n  temp-value-exprs will be evaluated and each resulting value will\r\n  replace in parallel the root value of its Var.  After the body is\r\n  executed, the root values of all the Vars will be set back to their\r\n  old values.  These temporary changes will be visible in all threads.\r\n  Useful for mocking out functions during testing." {:added "1.3"} [bindings & body] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/with-redefs-fn)) (clojure.core/list (zipmap (map (fn* [%1] (list (quote var) %1)) (take-nth 2 bindings)) (take-nth 2 (next bindings)))) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/fn)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat))))) body))))))))

(defn realized? "Returns true if a value has been produced for a promise, delay, future or lazy sequence." {:added "1.3"} [^p/IPending x] (.isRealized x))

(defmacro cond-> "Takes an expression and a set of test/form pairs. Threads expr (via ->)\r\n  through each form for which the corresponding test\r\n  expression is true. Note that, unlike cond branching, cond-> threading does\r\n  not short circuit after the first true test expression." {:added "1.5"} [expr & clauses] (assert (even? (count clauses))) (let [g (gensym) steps (map (fn [[test step]] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list test) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/->)) (clojure.core/list g) (clojure.core/list step))))) (clojure.core/list g))))) (partition 2 clauses))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list g) (clojure.core/list expr) (interleave (repeat g) (butlast steps))))))) (clojure.core/list (if (empty? steps) g (last steps))))))))

(defmacro cond->> "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\r\n  through each form for which the corresponding test expression\r\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\r\n  after the first true test expression." {:added "1.5"} [expr & clauses] (assert (even? (count clauses))) (let [g (gensym) steps (map (fn [[test step]] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list test) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/->>)) (clojure.core/list g) (clojure.core/list step))))) (clojure.core/list g))))) (partition 2 clauses))] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list g) (clojure.core/list expr) (interleave (repeat g) (butlast steps))))))) (clojure.core/list (if (empty? steps) g (last steps))))))))

(defmacro as-> "Binds name to expr, evaluates the first form in the lexical context\r\n  of that binding, then binds name to that result, repeating for each\r\n  successive form, returning the result of the last form." {:added "1.5"} [expr name & forms] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list name) (clojure.core/list expr) (interleave (repeat name) (butlast forms))))))) (clojure.core/list (if (empty? forms) name (last forms)))))))

(defmacro some-> "When expr is not nil, threads it into the first form (via ->),\r\n  and when that result is not nil, through the next etc" {:added "1.5"} [expr & forms] (let [g (gensym) steps (map (fn [step] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/nil?)) (clojure.core/list g))))) (clojure.core/list nil) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/->)) (clojure.core/list g) (clojure.core/list step))))))))) forms)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list g) (clojure.core/list expr) (interleave (repeat g) (butlast steps))))))) (clojure.core/list (if (empty? steps) g (last steps))))))))

(defmacro some->> "When expr is not nil, threads it into the first form (via ->>),\r\n  and when that result is not nil, through the next etc" {:added "1.5"} [expr & forms] (let [g (gensym) steps (map (fn [step] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote if)) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/nil?)) (clojure.core/list g))))) (clojure.core/list nil) (clojure.core/list (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/->>)) (clojure.core/list g) (clojure.core/list step))))))))) forms)] (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list (quote clojure.core/let)) (clojure.core/list (clojure.core/vec (clojure.core/sequence (clojure.core/seq (clojure.core/concat (clojure.core/list g) (clojure.core/list expr) (interleave (repeat g) (butlast steps))))))) (clojure.core/list (if (empty? steps) g (last steps))))))))

(defn ^{:private true} preserving-reduced [rf] (fn* [%1 %2] (let [ret (rf %1 %2)] (if (reduced? ret) (reduced ret) ret))))

(defn cat "A transducer which concatenates the contents of each input, which must be a\r\n  collection, into the reduction." {:added "1.7"} [rf] (let [rrf (preserving-reduced rf)] (fn ([] (rf)) ([result] (rf result)) ([result input] (reduce rrf result input)))))

(defn halt-when "Returns a transducer that ends transduction when pred returns true\r\n  for an input. When retf is supplied it must be a fn of 2 arguments -\r\n  it will be passed the (completed) result so far and the input that\r\n  triggered the predicate, and its return value (if it does not throw\r\n  an exception) will be the return value of the transducer. If retf\r\n  is not supplied, the input that triggered the predicate will be\r\n  returned. If the predicate never returns true the transduction is\r\n  unaffected." {:added "1.9"} ([pred] (halt-when pred nil)) ([pred retf] (fn [rf] (fn ([] (rf)) ([result] (if (and (map? result) (contains? result :portabilize-core-v2/halt)) (:portabilize-core-v2/halt result) (rf result))) ([result input] (if (pred input) (reduced #:portabilize-core-v2{:halt (if retf (retf (rf result) input) input)}) (rf result input)))))))

(defn dedupe "Returns a lazy sequence removing consecutive duplicates in coll.\r\n  Returns a transducer when no collection is provided." {:added "1.7"} ([] (fn [rf] (let [pv (volatile! :portabilize-core-v2/none)] (fn ([] (rf)) ([result] (rf result)) ([result input] (let [prior (clojure.core/deref pv)] (vreset! pv input) (if (= prior input) result (rf result input)))))))) ([coll] (sequence (dedupe) coll)))

(defn random-sample "Returns items from coll with random probability of prob (0.0 -\r\n  1.0).  Returns a transducer when no collection is provided." {:added "1.7"} ([prob] (filter (fn [_] (< (rand) prob)))) ([prob coll] (filter (fn [_] (< (rand) prob)) coll)))

(deftype Eduction [xform coll] Iterable (iterator [_] (t/transformer-iterator xform (t/iterator coll))) p/IReduceInit (reduce [_ f init] (transduce xform (completing f) init coll)) p/ISequential)

(defn eduction "Returns a reducible/iterable application of the transducers\r\n  to the items in coll. Transducers are applied in order as if\r\n  combined with comp. Note that these applications will be\r\n  performed every time reduce/iterator is called." {:arglists (quote ([xform* coll])), :added "1.7"} [& xforms] (Eduction. (apply comp (butlast xforms)) (last xforms)))

(defmethod print-method Eduction [c ^Writer w] (if *print-readably* (do (print-sequential "(" pr-on " " ")" c w)) (print-object c w)))

(defn run! "Runs the supplied procedure (via reduce), for purposes of side\r\n  effects, on successive items in the collection. Returns nil" {:added "1.7"} [proc coll] (reduce (fn* [%1 %2] (proc %2)) nil coll) nil)

(defn iteration "Creates a seqable/reducible via repeated calls to step,\r\n  a function of some (continuation token) 'k'. The first call to step\r\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\r\n  (vf ret) will be included in the iteration, else iteration will\r\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\r\n  will be passed to the next step call, else iteration will terminate.\r\n\r\n  This can be used e.g. to consume APIs that return paginated or batched data.\r\n\r\n   step - (possibly impure) fn of 'k' -> 'ret'\r\n\r\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\r\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\r\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\r\n   :initk - the first value passed to step, default 'nil'\r\n\r\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\r\n  If step with initk is unreproducible it is on the consumer to not consume twice." {:added "1.11"} [step & {:keys [somef vf kf initk], :or {vf identity, kf identity, somef some?, initk nil}}] (reify p/ISeqable (seq [_] ((fn next [ret] (when (somef ret) (cons (vf ret) (when-some [k (kf ret)] (lazy-seq (next (step k))))))) (step initk))) p/IReduceInit (reduce [_ rf init] (loop [acc init ret (step initk)] (if (somef ret) (let [acc (rf acc (vf ret))] (if (reduced? acc) (clojure.core/deref acc) (if-some [k (kf ret)] (recur acc (step k)) acc))) acc)))))

(defn tagged-literal? "Return true if the value is the data representation of a tagged literal" {:added "1.7"} [value] ([x] ^{:line 257, :column 45} (t/tagged-literal? x) value))

(defn tagged-literal "Construct a data representation of a tagged literal from a\r\n  tag symbol and a form." {:added "1.7"} [tag form] (t/tagged-literal tag form))

(defn reader-conditional? "Return true if the value is the data representation of a reader conditional" {:added "1.7"} [value] ([x] ^{:line 258, :column 45} (t/reader-conditional? x) value))

(defn reader-conditional "Construct a data representation of a reader conditional.\r\n  If true, splicing? indicates read-cond-splicing." {:added "1.7"} [form splicing?] (t/reader-conditional form splicing?))

(def ^{:added "1.4"} default-data-readers "Default map of data reader functions provided by Clojure. May be\r\n  overridden by binding *data-readers*." (merge {(quote uuid) (var clojure.uuid/default-uuid-reader)} (when-class "java.sql.Timestamp" {(quote inst) (var clojure.instant/read-instant-date)})))

(def ^{:added "1.4", :dynamic true} *data-readers* "Map from reader tag symbols to data reader Vars.\r\n\r\n  When Clojure starts, it searches for files named 'data_readers.clj'\r\n  and 'data_readers.cljc' at the root of the classpath. Each such file\r\n  must contain a literal map of symbols, like this:\r\n\r\n      {foo/bar my.project.foo/bar\r\n       foo/baz my.project/baz}\r\n\r\n  The first symbol in each pair is a tag that will be recognized by\r\n  the Clojure reader. The second symbol in the pair is the\r\n  fully-qualified name of a Var which will be invoked by the reader to\r\n  parse the form following the tag. For example, given the\r\n  data_readers.clj file above, the Clojure reader would parse this\r\n  form:\r\n\r\n      #foo/bar [1 2 3]\r\n\r\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\r\n  data reader function is invoked on the form AFTER it has been read\r\n  as a normal Clojure data structure by the reader.\r\n\r\n  Reader tags without namespace qualifiers are reserved for\r\n  Clojure. Default reader tags are defined in\r\n  clojure.core/default-data-readers but may be overridden in\r\n  data_readers.clj, data_readers.cljc, or by rebinding this Var." {})

(def ^{:added "1.5", :dynamic true} *default-data-reader-fn* "When no data reader is found for a tag and *default-data-reader-fn*\r\n  is non-nil, it will be called with two arguments,\r\n  the tag and the value.  If *default-data-reader-fn* is nil (the\r\n  default), an exception will be thrown for the unknown tag." nil)

(defn- data-reader-urls [] (let [cl (.. Thread currentThread getContextClassLoader)] (concat (enumeration-seq (.getResources cl "data_readers.clj")) (enumeration-seq (.getResources cl "data_readers.cljc")))))

(defn- data-reader-var [sym] (intern (create-ns (symbol (namespace sym))) (symbol (name sym))))

(defn- load-data-reader-file [mappings ^java.net.URL url] (with-open [rdr (t/line-numbering-reader (java.io.InputStreamReader. (.openStream url) "UTF-8"))] (binding [*file* (.getFile url)] (let [read-opts (if (.endsWith (.getPath url) "cljc") {:eof nil, :read-cond :allow} {:eof nil}) new-mappings (read read-opts rdr)] (when (not (map? new-mappings)) (throw (ex-info (str "Not a valid data-reader map") {:url url}))) (reduce (fn [m [k v]] (when (not (symbol? k)) (throw (ex-info (str "Invalid form in data-reader file") {:url url, :form k}))) (let [v-var (data-reader-var v)] (when (and (contains? mappings k) (not= (mappings k) v-var)) (throw (ex-info "Conflicting data-reader mapping" {:url url, :conflict k, :mappings m}))) (assoc m k v-var))) mappings new-mappings)))))

(defn- load-data-readers [] (alter-var-root (var *data-readers*) (fn [mappings] (reduce load-data-reader-file mappings (data-reader-urls)))))

(try (load-data-readers) (catch Throwable t (.printStackTrace t) (throw t)))

(defn uri? "Return true if x is a java.net.URI" {:added "1.9"} [x] (instance? java.net.URI x))

(defonce ^{:private true} tapset (atom #{}))

(defonce ^{:private true} tapq (java.util.concurrent.ArrayBlockingQueue. 1024))

(defonce ^{:private true} tap-loop (delay (doto (Thread. (fn* [] (let [t (.take tapq) x (if (identical? :portabilize-core-v2/tap-nil t) nil t) taps (clojure.core/deref tapset)] (doseq [tap taps] (try (tap x) (catch Throwable ex))) (recur))) "clojure.core/tap-loop") (.setDaemon true) (.start))))

(defn add-tap "adds f, a fn of one argument, to the tap set. This function will be called with anything sent via tap>.\r\n  This function may (briefly) block (e.g. for streams), and will never impede calls to tap>,\r\n  but blocking indefinitely may cause tap values to be dropped.\r\n  Remember f in order to remove-tap" {:added "1.10"} [f] (force tap-loop) (swap! tapset conj f) nil)

(defn remove-tap "Remove f from the tap set." {:added "1.10"} [f] (swap! tapset disj f) nil)

(defn tap> "sends x to any taps. Will not block. Returns true if there was room in the queue,\r\n  false if not (dropped)." {:added "1.10"} [x] (force tap-loop) (.offer tapq (if (nil? x) :portabilize-core-v2/tap-nil x)))

(defn update-vals "m f => {k (f v) ...}\r\n\r\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\r\n  are mapped to result of applying f to the corresponding values of m." {:added "1.11"} [m f] (with-meta (persistent! (reduce-kv (fn [acc k v] (assoc! acc k (f v))) (if ([x] ^{:line 242, :column 47} (satisfies? p/IEditableCollection x) m) (transient m) (transient {})) m)) (meta m)))

(defn update-keys "m f => {(f k) v ...}\r\n\r\n  Given a map m and a function f of 1-argument, returns a new map whose\r\n  keys are the result of applying f to the keys of m, mapped to the\r\n  corresponding values of m.\r\n  f must return a unique key for each key of m, else the behavior is undefined." {:added "1.11"} [m f] (let [ret (persistent! (reduce-kv (fn [acc k v] (assoc! acc (f k) v)) (transient {}) m))] (with-meta ret (meta m))))

(defn- parsing-err "Construct message for parsing for non-string parsing error" [val] (str "Expected string, got " (if (nil? val) "nil" (-> val class .getName))))

(defn parse-long {:doc "Parse string of decimal digits with optional leading -/+ and return a\r\n  Long value, or nil if parse fails", :added "1.11"} [s] (if (string? s) (try (Long/valueOf s) (catch NumberFormatException _ nil)) (throw (clojure.core/ex-info (parsing-err s) {}))))

(defn parse-double {:doc "Parse string with floating point components and return a Double value,\r\n  or nil if parse fails.\r\n\r\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", :added "1.11"} [s] (if (string? s) (try (Double/valueOf s) (catch NumberFormatException _ nil)) (throw (clojure.core/ex-info (parsing-err s) {}))))

(defn parse-uuid {:doc "Parse a string representing a UUID and return a java.util.UUID instance,\r\n  or nil if parse fails.\r\n\r\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", :added "1.11"} [s] (try (java.util.UUID/fromString s) (catch IllegalArgumentException _ nil)))

(defn parse-boolean {:doc "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", :added "1.11"} [s] (if (string? s) (case s "true" true "false" false nil) (throw (clojure.core/ex-info (parsing-err s) {}))))

(defn NaN? {:doc "Returns true if num is NaN, else false", :added "1.11"} [^double num] (Double/isNaN num))

(defn infinite? {:doc "Returns true if num is negative or positive infinity, else false", :added "1.11"} [^double num] (Double/isInfinite num))

