;; test/eval.clj â€” Eval tests (ported from T_ASSERT in test.c)
;;
;; Uses builtins: is, group
;; These test the eval/apply/collections/macros subsystem.

;; eval: basic
(group "clj eval: basic")
(is 42 42)
(is -7 -7)
(is true true)
(is nil nil)
(is 6 (+ 1 2 3))
(is 1 (if true 1 2))
(is 2 (if false 1 2))
(is 30 (let [x 10 y 20] (+ x y)))
(is 25 ((fn [x] (* x x)) 5))
(defn sq [x] (* x x)) (is 49 (sq 7))
(is 3 (and 1 2 3))
(is 5 (or false nil 5))

;; collections
(group "clj collections")
(is [1 2 3] [1 2 3])
(is [] [])
(is [[1 2] [3 4]] [[1 2] [3 4]])
(is {:a 1 :b 2} {:a 1 :b 2})
(is {} {})
(is :foo :foo)
(is 1 (get {:a 1 :b 2} :a))
(is 20 (get [10 20 30] 1))
(is nil (get {:a 1} :z))
(is 2 (get (assoc {:a 1} :b 2) :b))
(is 99 (get (assoc [10 20 30] 1 99) 1))
(is [1 2 3] (conj [1 2] 3))
(is 1 (first (conj (list 2 3) 1)))
(is 30 (nth [10 20 30] 2))
(is 20 (nth (list 10 20 30) 1))
(is 3 (count [1 2 3]))
(is 2 (count {:a 1 :b 2}))
(is 4 (count (list 1 2 3 4)))
(is [1 2 3] (vec (list 1 2 3)))
(is true (empty? []))
(is false (empty? [1]))

;; collections: advanced
(group "clj collections: advanced")
(is 3 (count (keys {:a 1 :b 2 :c 3})))
(is 3 (count (vals {:a 1 :b 2 :c 3})))
(is true (contains? {:a 1} :a))
(is false (contains? {:a 1} :b))
(is true (vector? [1 2]))
(is true (map? {:a 1}))
(is true (keyword? :foo))
(is false (vector? 42))
(is [1 2 3] (into [] (list 1 2 3)))
(is 10 (get (hash-map :x 10 :y 20) :x))

;; core forms
(group "clj core forms")
(is "yes" (cond (< 5 3) "no" (> 5 3) "yes"))
(is 42 (cond false 1 :else 42))
(is nil (cond false 1))
(is 42 (when (> 5 3) 42))
(is nil (when (< 5 3) 42))
(is 3 (when true 1 2 3))
(is "hello world" (str "hello" " " "world"))
(is "x=42" (str "x=" 42))
(is 5 (count (range 5)))
(is 0 (first (range 5)))
(is 3 (first (range 3 7)))
(is 4 (count (range 3 7)))
(is 45 (loop [i 0 s 0] (if (= i 10) s (recur (inc i) (+ s i)))))
(is [0 1 2 3 4] (loop [v [] i 0] (if (= i 5) v (recur (conj v i) (inc i)))))
(is 3 (loop [i 0 t 0] (if (= i 3) t (recur (inc i) (+ t (loop [j 0 s 0] (if (= j i) s (recur (inc j) (+ s 1)))))))))
(is 42 (inc 41))
(is 42 (dec 43))
(is true (zero? 0))
(is true (pos? 5))
(is true (neg? -3))
(is 4.0 (+ 1.5 2.5))
(is 7.0 (* 2 3.5))
(is true (< 1.5 2.0))

;; coll protocol
(group "clj coll protocol")
(is 10 (first [10 20 30]))
(is 20 (first (rest [10 20 30])))
(is true (nil? (first [])))
(is 45 (reduce + 0 (range 10)))
(is 6 (first (map (fn [x] (* x 2)) (list 3 4 5))))
(is 3 (count (filter (fn [x] (> x 2)) (list 1 2 3 4 5))))

;; transient
(group "clj transient")
(is 3 (let [m {:a 1 :b 2}] (let [t (transient m)] (let [t2 (assoc! t :c 3)] (get (persistent! t2) :c)))))
(is nil (let [m {:a 1 :b 2}] (let [t (transient m)] (assoc! t :c 3) (get m :c))))
(is 3 (let [t (transient {})] (assoc! t :a 1) (assoc! t :b 2) (assoc! t :c 3) (count (persistent! t))))
(is 99 (let [t (transient {:a 1})] (assoc! t :a 99) (get (persistent! t) :a)))
(is 42 (let [t (transient {})] (assoc! t :x 42) (let [p (persistent! t)] (get p :x))))
(is 17 (let [t (transient {})] (assoc! t :a 1) (assoc! t :b 2) (assoc! t :c 3) (assoc! t :d 4) (assoc! t :e 5) (assoc! t :f 6) (assoc! t :g 7) (assoc! t :h 8) (assoc! t :i 9) (assoc! t :j 10) (assoc! t :k 11) (assoc! t :l 12) (assoc! t :m 13) (assoc! t :n 14) (assoc! t :o 15) (assoc! t :p 16) (assoc! t :q 17) (count (persistent! t))))
(is 2 (get (assoc {:a 1} :b 2) :b))
(is 1 (let [t (transient {})] (assoc! t :x 1) (get (persistent! t) :x)))
(is 1 (let [t (transient {})] (assoc! t :v [1 2 3]) (first (get (persistent! t) :v))))
(is 3 (let [m (persistent! (let [t (transient {:a 1})] (assoc! t :b 2) t))] (+ (get m :a) (get m :b))))

;; hof+pvec
(group "clj hof+pvec")
(is true (vector? (range 5)))
(is 2 (get (range 5) 2))
(is 45 (reduce + 0 (range 10)))
(is 4950 (reduce + 0 (range 100)))
(is 6 (first (map (fn [x] (* x 2)) [3 4 5])))
(is 30 (reduce + 0 (map (fn [x] (* x x)) (range 5))))
(is 3 (count (filter (fn [x] (> x 2)) [1 2 3 4 5])))
(is 49 (count (filter (fn [x] (> x 50)) (range 100))))
(is 5 (count (into [] (range 5))))
(is 20 (reduce + 0 (filter (fn [x] (= 0 (mod x 2))) (range 10))))

;; macros
(group "clj macros")
(defmacro my-when [t & body] (list 'if t (cons 'do body)))
(is true (macro? my-when))
(is false (macro? +))
(is 42 (my-when true 42))
(is nil (my-when false 42))
(is 3 (my-when (> 5 3) 1 2 3))
(defmacro my-unless [t & body] (list 'if t nil (cons 'do body)))
(is 42 (my-unless false 42))
(is nil (my-unless true 42))
;; macroexpand-1
(is (list 'if true (list 'do 42)) (macroexpand-1 (list 'my-when true 42)))
;; cond as macro
(defmacro my-cond [& cs] (if (nil? cs) nil (list 'if (first cs) (first (rest cs)) (cons 'my-cond (rest (rest cs))))))
(is "yes" (my-cond (< 5 3) "no" (> 5 3) "yes"))
(is 42 (my-cond false 1 :else 42))
(is nil (my-cond false 1))
;; gensym
(let [g1 (gensym) g2 (gensym)] (is false (= g1 g2)))
;; nested macro
(is 3 (my-when true (my-when true 3)))
;; macro with let
(defmacro my-let1 [name val & body] (list 'let [name val] (cons 'do body)))
(is 42 (my-let1 x 42 x))
;; syntax-quote
(is (list 1 2 3) `(1 2 3))
(let [x 42] (is (list 1 42 3) `(1 ~x 3)))
(let [xs (list 2 3)] (is (list 1 2 3 4) `(1 ~@xs 4)))
(let [x 1 y 2] (is [1 2 3] `[~x ~y 3]))
(let [xs (list 2 3)] (is [1 2 3 4] `[1 ~@xs 4]))
(let [v 42] (is {:a 42} `{:a ~v}))
;; syntax-quote macros
(defmacro sq-when [t & body] `(if ~t (do ~@body)))
(is 42 (sq-when true 42))
(is nil (sq-when false 42))
(is 3 (sq-when true 1 2 3))
(defmacro sq-unless [t & body] `(if ~t nil (do ~@body)))
(is 42 (sq-unless false 42))
(is nil (sq-unless true 42))
;; threading macro with syntax-quote
(defmacro my-> [x & forms] (if (empty? forms) x (let [f (first forms)] `(my-> (~f ~x) ~@(rest forms)))))
(is 7 (my-> 5 inc inc))
(is 3 (my-> 5 dec dec))

;; analyze=true: constant folding + dead branch
(group "clj analyze=true")
(is 7 (+ (* 2 3) 1))
(is 42 (if true 42 (/ 1 0)))
(def x (+ 10 20)) (is 30 x)

;; stdlib functions (no self-hosted colls needed)
(group "clj stdlib (clj)")
(is 20 (second [10 20 30]))
(is 3 (count (take 3 [1 2 3 4 5])))
(is 30 (first (drop 2 [10 20 30 40])))
(is 4 (some (fn [x] (if (> x 3) x nil)) [1 2 3 4 5]))
(is nil (some (fn [x] (if (> x 10) x nil)) [1 2 3]))
(is true (every? pos? [1 2 3]))
(is false (every? pos? [1 -2 3]))
(is 42 (identity 42))
(is 7 ((constantly 7) 1 2 3))
(is true ((complement nil?) 42))
(is 2 (count (partition 2 [1 2 3 4 5])))
(is 6 (count (interleave [1 2 3] [:a :b :c])))
(is 2 (get (zipmap [:a :b] [1 2]) :b))
(is 3 (get (frequencies [:a :b :a :c :b :a]) :a))
(is 2 (count (get (group-by (fn [x] (if (> x 2) :big :small)) [1 2 3 4]) :big)))
(is 6 (count (mapcat (fn [x] [x x]) [1 2 3])))
(is 4 (count (distinct [:a :b :a :c :b :d])))
